
===========================================================================
!=                                                                       *!=*

  Description

Determines if one value is not equal to another.

  Syntax

(a != b ? v1 : v2)

where a, b, v1 and v2 may be expressions, but a, b not audio-rate.


===========================================================================
#define                                                             *#define*

  Description

Macros are textual replacements which are made in the orchestra as it is
being read. The macro system in Csound is a very simple one, and uses
the characters # and $ to define and call macros. This can save typing,
and can lead to a coherent structure and consistent style. This is
similar to, but independent of, the macro system in the score language.

#define NAME -- defines a simple macro. The name of the macro must begin
with a letter and can consist of any combination of letters and numbers.
Case is significant. This form is limiting, in that the variable names
are fixed. More flexibility can be obtained by using a macro with
arguments, described below.

#define NAME(a' b' c') -- defines a macro with arguments. This can be
used in more complex situations. The name of the macro must begin with a
letter and can consist of any combination of letters and numbers. Within
the replacement text, the arguments can be substituted by the form: $A.
In fact, the implementation defines the arguments as simple macros.
There may be up to 5 arguments, and the names may be any choice of
letters. Remember that case is significant in macro names.

  Syntax

#define NAME # replacement text #

#define NAME(a' b' c') # replacement text #


===========================================================================
#include                                                           *#include*

  Description

Includes an external file for processing.

  Syntax

#include “filename”


===========================================================================
#undef                                                               *#undef*

  Description

Macros are textual replacements which are made in the orchestra as it is
being read. The macro system in Csound is a very simple one, and uses
the characters # and $ to define and call macros. This can save typing,
and can lead to a coherent structure and consistent style. This is
similar to, but independent of, the macro system in the score language.

#undef NAME -- undefines a macro name. If a macro is no longer required,
it can be undefined with #undef NAME.

  Syntax

#undef NAME


===========================================================================
#ifdef                                                               *#ifdef*

  Description

If a macro is defined then #ifdef can incorporate text into an orchestra
upto the next #end. This is similar to, but independent of, the macro
system in the score language.

  Syntax

#ifdef NAME

....

#else 

....

#end 


===========================================================================
#ifndef                                                             *#ifndef*

  Description

If the specified macro is not defined then #ifndef can incorporate text
into an orchestra upto the next #end. This is similar to, but
independent of, the macro system in the score language.

  Syntax

#ifndef NAME

....

#else 

....

#end 


===========================================================================
$NAME                                                                 *$NAME*

  Description

Macros are textual replacements which are made in the orchestra as it is
being read. The macro system in Csound is a very simple one, and uses
the characters # and $ to define and call macros. This can save typing,
and can lead to a coherent structure and consistent style. This is
similar to, but independent of, the macro system in the score language.

$NAME -- calls a defined macro. To use a macro, the name is used
following a $ character. The name is terminated by the first character
which is neither a letter nor a number. If it is necessary for the name
not to terminate with a space, a period, which will be ignored, can be
used to terminate the name. The string, $NAME., is replaced by the
replacement text from the definition. The replacement text can also
include macro calls.

  Syntax

$NAME 


===========================================================================
%                                                                         *%*

  Description

Arithmetic operators perform operations of change-sign (negate),
don't-change-sign, logical AND logical OR, add, subtract, multiply and
divide. Note that a value or an expression may fall between two of these
operators, either of which could take it as its left or right argument,
as in

a + b * c.

In such cases three rules apply:

1. * and / bind to their neighbors more strongly than + and −. Thus the
above expression is taken as

a + (b * c)

with * taking b and c and then + taking a and b * c.

2. + and − bind more strongly than &&, which in turn is stronger than ||:

a && b - c || d

is taken as

(a && (b - c)) || d

3. When both operators bind equally strongly, the operations are done
left to right:

a - b - c

is taken as

(a - b) - c

Parentheses may be used as above to force particular groupings.

The operator % returns the value of a reduced by b, so that the result,
in absolute value, is less than the absolute value of b, by repeated
subtraction. This is the same as modulus function in integers. New in
Csound version 3.50.

  Syntax

a % b  (no rate restriction)

where the arguments a and b may be further expressions.


===========================================================================
&&                                                                       *&&*

  Description

Arithmetic operators perform operations of change-sign (negate),
don't-change-sign, logical AND logical OR, add, subtract, multiply and
divide. Note that a value or an expression may fall between two of these
operators, either of which could take it as its left or right argument,
as in

a + b * c.

In such cases three rules apply:

1. * and / bind to their neighbors more strongly than + and −. Thus the
above expression is taken as

a + (b * c)

with * taking b and c and then + taking a and b * c.

2. + and − bind more strongly than &&, which in turn is stronger than ||:

a && b - c || d

is taken as

(a && (b - c)) || d

3. When both operators bind equally strongly, the operations are done
left to right:

a - b - c

is taken as

(a - b) - c

Parentheses may be used as above to force particular groupings.

  Syntax

a && b  (logical AND; not audio-rate)

where the arguments a and b may be further expressions.


===========================================================================
>                                                                         *>*

  Description

Determines if one value is greater than another.

  Syntax

(a >  b ? v1 : v2)

where a, b, v1 and v2 may be expressions, but a, b not audio-rate.


===========================================================================
>=                                                                       *>=*

  Description

Determines if one value is greater than or equal to another.

  Syntax

(a >= b ? v1 : v2)

where a, b, v1 and v2 may be expressions, but a, b not audio-rate.


===========================================================================
<                                                                         *<*

  Description

Determines if one value is less than another.

  Syntax

(a <  b ? v1 : v2)

where a, b, v1 and v2 may be expressions, but a, b not audio-rate.


===========================================================================
<=                                                                       *<=*

  Description

Determines if one value is less than or equal to another.

  Syntax

(a <= b ? v1 : v2)

where a, b, v1 and v2 may be expressions, but a, b not audio-rate.


===========================================================================
*                                                                         ***

  Description

Arithmetic operators perform operations of change-sign (negate),
don't-change-sign, logical AND logical OR, add, subtract, multiply and
divide. Note that a value or an expression may fall between two of these
operators, either of which could take it as its left or right argument,
as in

a + b * c.

In such cases three rules apply:

1. * and / bind to their neighbors more strongly than + and −. Thus the
above expression is taken as

a + (b * c)

with * taking b and c and then + taking a and b * c.

2. + and − bind more strongly than &&, which in turn is stronger than ||:

a && b - c || d

is taken as

(a && (b - c)) || d

3. When both operators bind equally strongly, the operations are done
left to right:

a - b - c

is taken as

(a - b) - c

Parentheses may be used as above to force particular groupings.

  Syntax

a *  b  (no rate restriction)

where the arguments a and b may be further expressions.


===========================================================================
+                                                                         *+*

  Description

Arithmetic operators perform operations of change-sign (negate),
do-no-change-sign, logical AND logical OR, add, subtract, multiply and
divide. Note that a value or an expression may fall between two of these
operators, either of which could take it as its left or right argument,
as in

a + b * c.

In such cases three rules apply:

1. * and / bind to their neighbors more strongly than + and −. Thus the
above expression is taken as

a + (b * c)

with * taking b and c and then + taking a and b * c.

2. + and − bind more strongly than &&, which in turn is stronger than ||:

a && b - c || d

is taken as

(a && (b - c)) || d

3. When both operators bind equally strongly, the operations are done
left to right:

a - b - c

is taken as

(a - b) - c

Parentheses may be used as above to force particular groupings.

  Syntax

+a  (no rate restriction)

a + b  (no rate restriction)

where the arguments a and b may be further expressions.


===========================================================================
-                                                                         *-*

  Description

Arithmetic operators perform operations of change-sign (negate),
don't-change-sign, logical AND logical OR, add, subtract, multiply and
divide. Note that a value or an expression may fall between two of these
operators, either of which could take it as its left or right argument,
as in

a + b * c.

In such cases three rules apply:

1. * and / bind to their neighbors more strongly than + and −. Thus the
above expression is taken as

a + (b * c)

with * taking b and c and then + taking a and b * c.

2. + and − bind more strongly than &&, which in turn is stronger than ||:

a && b - c || d

is taken as

(a && (b - c)) || d

3. When both operators bind equally strongly, the operations are done
left to right:

a - b - c

is taken as

(a - b) - c

Parentheses may be used as above to force particular groupings.

  Syntax

−a  (no rate restriction)

a − b  (no rate restriction)

where the arguments a and b may be further expressions.


===========================================================================
/                                                                         */*

  Description

Arithmetic operators perform operations of change-sign (negate),
don't-change-sign, logical AND logical OR, add, subtract, multiply and
divide. Note that a value or an expression may fall between two of these
operators, either of which could take it as its left or right argument,
as in

a + b * c.

In such cases three rules apply:

1. * and / bind to their neighbors more strongly than + and −. Thus the
above expression is taken as

a + (b * c)

with * taking b and c and then + taking a and b * c.

2. + and − bind more strongly than &&, which in turn is stronger than ||:

a && b - c || d

is taken as

(a && (b - c)) || d

3. When both operators bind equally strongly, the operations are done
left to right:

a - b - c

is taken as

(a - b) - c

Parentheses may be used as above to force particular groupings.

  Syntax

a /  b  (no rate restriction)

where the arguments a and b may be further expressions.


===========================================================================
=                                                                         *=*

  Syntax

ares = xarg

ires = iarg

kres = karg

ires, ... = iarg, ...

kres, ... = karg, ...

table [ kval] = karg

  Description

Performs a simple assignment.


===========================================================================
+=                                                                       *+=*

  Syntax

ares += xarg

ires += iarg

kres += karg

table [ kval] += karg

  Description

Performs an add and assign.


===========================================================================
==                                                                       *==*

  Description

Compares two values for equality.

  Syntax

(a == b ? v1 : v2)

where a, b, v1 and v2 may be expressions, but a, b not audio-rate.


===========================================================================
^                                                                         *^*

  Description

Arithmetic operators perform operations of change-sign (negate),
don't-change-sign, logical AND logical OR, add, subtract, multiply and
divide. Note that a value or an expression may fall between two of these
operators, either of which could take it as its left or right argument,
as in

a + b * c.

In such cases three rules apply:

1. * and / bind to their neighbors more strongly than + and −. Thus the
above expression is taken as

a + (b * c)

with * taking b and c and then + taking a and b * c.

2. + and − bind more strongly than &&, which in turn is stronger than ||:

a && b - c || d

is taken as

(a && (b - c)) || d

3. When both operators bind equally strongly, the operations are done
left to right:

a - b - c

is taken as

(a - b) - c

Parentheses may be used as above to force particular groupings.

The operator ^ raises a to the b power. b may not be audio-rate. Use
with caution as precedence may not work correctly. See pow. (New in
Csound version 3.493.)

  Syntax

a ^  b  (b not audio-rate)

where the arguments a and b may be further expressions.


===========================================================================
||                                                                       *||*

  Description

Arithmetic operators perform operations of change-sign (negate),
don't-change-sign, logical AND logical OR, add, subtract, multiply and
divide. Note that a value or an expression may fall between two of these
operators, either of which could take it as its left or right argument,
as in

a + b * c.

In such cases three rules apply:

1. * and / bind to their neighbors more strongly than + and −. Thus the
above expression is taken as

a + (b * c)

with * taking b and c and then + taking a and b * c.

2. + and − bind more strongly than &&, which in turn is stronger than ||:

a && b - c || d

is taken as

(a && (b - c)) || d

3. When both operators bind equally strongly, the operations are done
left to right:

a - b - c

is taken as

(a - b) - c

Parentheses may be used as above to force particular groupings.

  Syntax

a || b  (logical OR; not audio-rate)

where the arguments a and b may be further expressions.


===========================================================================
0dbfs                                                                 *0dbfs*

  Description

Sets the value of 0 decibels using full scale amplitude.

  Syntax

0dbfs = iarg

0dbfs 


===========================================================================
<<                                                                       *<<*

  Description

The bitshift operators shift the bits to the left or to the right the
number of bits given.

The priority of these operators is less binding that the arithmetic
ones, but more binding that the comparisons.

Parentheses may be used as above to force particular groupings.

  Syntax

a << b  (bitshift left)

where the arguments a and b may be further expressions.


===========================================================================
>>                                                                       *>>*

  Description

The bitshift operators shift the bits to the left or to the right the
number of bits given.

The priority of these operators is less binding that the arithmetic
ones, but more binding that the comparisons.

Parentheses may be used as above to force particular groupings.

  Syntax

a >> b  (bitshift left)

where the arguments a and b may be further expressions.


===========================================================================
&                                                                         *&*

  Description

The bitwise operators perform operations of bitwise AND, bitwise OR,
bitwise NOT and bitwise non-equivalence.

  Syntax

a & b  (bitwise AND)

where the arguments a and b may be further expressions. They are
converted to the nearest integer to machine precision and then the
operation is performed.


===========================================================================
|                                                                         *|*

  Description

The bitwise operators perform operations of bitwise AND, bitwise OR,
bitwise NOT and bitwise non-equivalence.

  Syntax

a | b  (bitwise OR)

where the arguments a and b may be further expressions. They are
converted to the nearest integer to machine precision and then the
operation is performed.


===========================================================================
¬                                                                         *¬*

  Description

The bitwise operators perform operations of bitwise AND, bitwise OR,
bitwise NOT and bitwise non-equivalence.

The priority of these operators is less binding that the arithmetic
ones, but more binding that the comparisons.

Parentheses may be used as above to force particular groupings.

  Syntax

~ a  (bitwise NOT)

where the argument a may be a further expression. It is converted to the
nearest integer to machine precision and then the operation is performed.


===========================================================================
#                                                                         *#*

  Description

The bitwise operators perform operations of bitwise AND, bitwise OR,
bitwise NOT and bitwise non-equivalence.

The priority of these operators is less binding that the arithmetic
ones, but more binding that the comparisons.

Parentheses may be used as above to force particular groupings.

  Syntax

a # b  (bitwise NON EQUIVALENCE)

where the arguments a and b may be further expressions. They are
converted to the nearest integer to machine precision and then the
operation is performed.


===========================================================================
a                                                                         *a*

  Description

Converts a k-rate parameter to an a-rate value with interpolation.

  Syntax

a(x) (control-rate args only)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
abs                                                                     *abs*

  Description

Returns the absolute value of x.

  Syntax

abs(x) (no rate restriction)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
active                                                               *active*

  Description

Returns the number of active instances of an instrument with options to
ignore releasing instances.

  Syntax

ir active insnum [,iopt [,inorel]]

ir active Sinsname [,iopt [,inorel]]

kres active kinsnum [,iopt [,inorel]]


===========================================================================
adsr                                                                   *adsr*

  Description

Calculates the classical ADSR envelope using linear segments.

  Syntax

ares adsr iatt, idec, islev, irel [, idel]

kres adsr iatt, idec, islev, irel [, idel]


===========================================================================
adsyn                                                                 *adsyn*

  Description

Output is an additive set of individually controlled sinusoids, using an
oscillator bank.

  Syntax

ares adsyn kamod, kfmod, ksmod, ifilcod


===========================================================================
adsynt                                                               *adsynt*

  Description

Performs additive synthesis with an arbitrary number of partials, not
necessarily harmonic.

  Syntax

ares adsynt kamp, kcps, iwfn, ifreqfn, iampfn, icnt [, iphs]


===========================================================================
adsynt2                                                             *adsynt2*

  Description

Performs additive synthesis with an arbitrary number of partials, not
necessarily harmonic. (see adsynt for detailed manual)

  Syntax

ar adsynt2 kamp, kcps, iwfn, ifreqfn, iampfn, icnt [, iphs]


===========================================================================
aftouch                                                             *aftouch*

  Description

Get the current after-touch value for this channel.

  Syntax

kaft aftouch [imin] [, imax]


===========================================================================
alpass                                                               *alpass*

  Description

Reverberates an input signal with a flat frequency response.

  Syntax

ares alpass asig, xrvt, ilpt [, iskip] [, insmps]


===========================================================================
alwayson                                                           *alwayson*

  Description

Activates the indicated instrument in the orchestra header, without need
for an i statement. Instruments must be activated in the same order as
they are defined.

The alwayson opcode is designed to simplify the definition of re-usable
orchestras with signal processing or effects chains and networks.

  Syntax

 alwayson Tinstrument [p4, ..., pn]


===========================================================================
ampdb                                                                 *ampdb*

  Description

Returns the amplitude equivalent of the decibel value x. Thus:

  * 60 dB = 1000

  * 66 dB = 1995.262

  * 72 dB = 3891.07

  * 78 dB = 7943.279

  * 84 dB = 15848.926

  * 90 dB = 31622.764

  Syntax

ampdb(x)  (no rate restriction)


===========================================================================
ampdbfs                                                             *ampdbfs*

  Description

Returns the amplitude equivalent of the full scale decibel (dB FS) value
x. The logarithmic full scale decibel values will be converted to linear
16-bit signed integer values from −32,768 to +32,767.

  Syntax

ampdbfs(x)  (no rate restriction)


===========================================================================
ampmidi                                                             *ampmidi*

  Description

Get the velocity of the current MIDI event.

  Syntax

iamp ampmidi iscal [, ifn]


===========================================================================
ampmidid                                                           *ampmidid*

  Description

Musically map MIDI velocity to peak amplitude within a specified dynamic
range in decibels.

  Syntax

iamplitude ampmidid ivelocity, idecibels

kamplitude ampmidid kvelocity, idecibels


===========================================================================
areson                                                               *areson*

  Description

A notch filter whose transfer functions are the complements of the reson
opcode.

  Syntax

ares areson asig, kcf, kbw [, iscl] [, iskip]

ares areson asig, acf, kbw [, iscl] [, iskip]

ares areson asig, kcf, abw [, iscl] [, iskip]

ares areson asig, acf, abw [, iscl] [, iskip]


===========================================================================
aresonk                                                             *aresonk*

  Description

A notch filter whose transfer functions are the complements of the reson
opcode.

  Syntax

kres aresonk ksig, kcf, kbw [, iscl] [, iskip]


===========================================================================
atone                                                                 *atone*

  Description

A hi-pass filter whose transfer functions are the complements of the
tone opcode.

  Syntax

ares atone asig, khp [, iskip]


===========================================================================
atonek                                                               *atonek*

  Description

A hi-pass filter whose transfer functions are the complements of the
tonek opcode.

  Syntax

kres atonek ksig, khp [, iskip]


===========================================================================
atonex                                                               *atonex*

  Description

atonex is equivalent to a filter consisting of more layers of atone with
the same arguments, serially connected. Using a stack of a larger number
of filters allows a sharper cutoff. They are faster than using a larger
number instances in a Csound orchestra of the old opcodes, because only
one initialization and k- cycle are needed at time and the audio loop
falls entirely inside the cache memory of processor.

  Syntax

ares atonex asig, khp [, inumlayer] [, iskip]

ares atonex asig, ahp [, inumlayer] [, iskip]


===========================================================================
ATSadd                                                               *ATSadd*

  Description

ATSadd reads from an ATS analysis file and uses the data to perform
additive synthesis using an internal array of interpolating oscillators.

  Syntax

ar ATSadd ktimepnt, kfmod, iatsfile, ifn, ipartials[, ipartialoffset, \
        ipartialincr, igatefn]


===========================================================================
ATSaddnz                                                           *ATSaddnz*

  Description

ATSaddnz reads from an ATS analysis file and uses the data to perform
additive synthesis using a modified randi function.

  Syntax

ar ATSaddnz ktimepnt, iatsfile, ibands[, ibandoffset, ibandincr]


===========================================================================
ATSbufread                                                       *ATSbufread*

  Description

ATSbufread reads data from and ATS data file and stores it in an
internal data table of frequency, amplitude pairs.

  Syntax

ATSbufread ktimepnt, kfmod, iatsfile, ipartials[, ipartialoffset, \
          ipartialincr]


===========================================================================
ATScross                                                           *ATScross*

  Description

ATScross uses data from an ATS analysis file and data from an ATSbufread
to perform cross synthesis.

  Syntax

ar ATScross ktimepnt, kfmod, iatsfile, ifn, kmylev, kbuflev, ipartials \
          [, ipartialoffset, ipartialincr]


===========================================================================
ATSinfo                                                             *ATSinfo*

  Description

atsinfo reads data out of the header of an ATS file.

  Syntax

idata ATSinfo iatsfile, ilocation


===========================================================================
ATSinterpread                                                 *ATSinterpread*

  Description

ATSinterpread allows a user to determine the frequency envelope of any
ATSbufread.

  Syntax

kamp ATSinterpread kfreq


===========================================================================
ATSread                                                             *ATSread*

  Description

ATSread returns the amplitude (kamp) and frequency (kfreq) information
of a user specified partial contained in the ATS analysis file at the
time indicated by the time pointer ktimepnt.

  Syntax

kfreq, kamp ATSread ktimepnt, iatsfile, ipartial


===========================================================================
ATSreadnz                                                         *ATSreadnz*

  Description

ATSreadnz returns the energy (kenergy) of a user specified noise band
(1-25 bands) at the time indicated by the time pointer ktimepnt.

  Syntax

kenergy ATSreadnz ktimepnt, iatsfile, iband


===========================================================================
ATSpartialtap                                                 *ATSpartialtap*

  Description

ATSpartialtap takes a partial number and returns a frequency, amplitude
pair. The frequency and amplitude data comes from an ATSbufread opcode.

  Syntax

kfrq, kamp ATSpartialtap ipartialnum


===========================================================================
ATSsinnoi                                                         *ATSsinnoi*

  Description

ATSsinnoi reads data from an ATS data file and uses the information to
synthesize sines and noise together.

  Syntax

ar ATSsinnoi ktimepnt, ksinlev, knzlev, kfmod, iatsfile, ipartials \
          [, ipartialoffset, ipartialincr]


===========================================================================
babo                                                                   *babo*

  Description

babo stands for ball-within-the-box. It is a physical model reverberator
based on the paper by Davide Rocchesso "The Ball within the Box: a
sound-processing metaphor", Computer Music Journal, Vol 19, N.4,
pp.45-47, Winter 1995.

The resonator geometry can be defined, along with some response
characteristics, the position of the listener within the resonator, and
the position of the sound source.

  Syntax

a1, a2 babo asig, ksrcx, ksrcy, ksrcz, irx, iry, irz [, idiff] [, ifno]


===========================================================================
balance                                                             *balance*

  Description

The rms power of asig can be interrogated, set, or adjusted to match
that of a comparator signal.

  Syntax

ares balance asig, acomp [, ihp] [, iskip]


===========================================================================
bamboo                                                               *bamboo*

  Description

bamboo is a semi-physical model of a bamboo sound. It is one of the
PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event
Modeling) is an algorithmic approach for simulating collisions of
multiple independent sound producing objects.

  Syntax

ares bamboo kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \
      [, ifreq1] [, ifreq2]


===========================================================================
barmodel                                                           *barmodel*

  Description

Audio output is a tone similar to a struck metal bar, using a physical
model developed from solving the partial differential equation. There
are controls over the boundary conditions as well as the bar
characteristics.

  Syntax

ares barmodel kbcL, kbcR, iK, ib, kscan, iT30, ipos, ivel, iwid


===========================================================================
bbcutm                                                               *bbcutm*

  Description

The BreakBeat Cutter automatically generates cut-ups of a source audio
stream in the style of drum and bass/jungle breakbeat manipulations.
There are two versions, for mono (bbcutm) or stereo (bbcuts) sources.
Whilst originally based on breakbeat cutting, the opcode can be applied
to any type of source audio.

The prototypical cut sequence favoured over one bar with eighth note
subdivisions would be

3+ 3R + 2

where we take a 3 unit block from the source's start, repeat it, then 2
units from the 7th and 8th eighth notes of the source.

We talk of rendering phrases (a sequence of cuts before reaching a new
phrase at the beginning of a bar) and units (as subdivision th notes).

The opcode comes most alive when multiple synchronised versions are used
simultaneously.

  Syntax

a1 bbcutm asource, ibps, isubdiv, ibarlength, iphrasebars, inumrepeats \
      [, istutterspeed] [, istutterchance] [, ienvchoice ]


===========================================================================
bbcuts                                                               *bbcuts*

  Description

The BreakBeat Cutter automatically generates cut-ups of a source audio
stream in the style of drum and bass/jungle breakbeat manipulations.
There are two versions, for mono (bbcutm) or stereo (bbcuts) sources.
Whilst originally based on breakbeat cutting, the opcode can be applied
to any type of source audio.

The prototypical cut sequence favoured over one bar with eighth note
subdivisions would be

3+ 3R + 2

where we take a 3 unit block from the source's start, repeat it, then 2
units from the 7th and 8th eighth notes of the source.

We talk of rendering phrases (a sequence of cuts before reaching a new
phrase at the beginning of a bar) and units (as subdivision th notes).

The opcode comes most alive when multiple synchronised versions are used
simultaneously.

  Syntax

a1,a2 bbcuts asource1, asource2, ibps, isubdiv, ibarlength, iphrasebars, \
      inumrepeats [, istutterspeed] [, istutterchance] [, ienvchoice]


===========================================================================
betarand                                                           *betarand*

  Description

Beta distribution random number generator (positive values only). This
is an x-class noise generator.

  Syntax

ares betarand krange, kalpha, kbeta

ires betarand krange, kalpha, kbeta

kres betarand krange, kalpha, kbeta


===========================================================================
bexprnd                                                             *bexprnd*

  Description

Exponential distribution random number generator. This is an x-class
noise generator.

  Syntax

ares bexprnd krange

ires bexprnd krange

kres bexprnd krange


===========================================================================
bformenc1                                                         *bformenc1*

  Description

Codes a signal into the ambisonic B format

  Syntax

aw, ax, ay, az bformenc1 asig, kalpha, kbeta

aw, ax, ay, az, ar, as, at, au, av bformenc1 asig, kalpha, kbeta

aw, ax, ay, az, ar, as, at, au, av, ak, al, am, an, ao, ap, aq bformenc1 \
      asig, kalpha, kbeta

aarray[] bformenc1 asig, kalpha, kbeta


===========================================================================
bformdec1                                                         *bformdec1*

  Description

Decodes an ambisonic B format signal into loudspeaker specific signals.

  Syntax

ao1, ao2 bformdec1 isetup, aw, ax, ay, az [, ar, as, at, au, av \
      [, abk, al, am, an, ao, ap, aq]]

ao1, ao2, ao3, ao4 bformdec1 isetup, aw, ax, ay, az [, ar, as, at, \
      au, av [, abk, al, am, an, ao, ap, aq]]

ao1, ao2, ao3, ao4, ao5 bformdec1 isetup, aw, ax, ay, az [, ar, as, \
      at, au, av [, abk, al, am, an, ao, ap, aq]]

ao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8 bformdec1 isetup, aw, ax, ay, az \
      [, ar, as, at, au, av [, abk, al, am, an, ao, ap,
    aq]]]

aout[] bformdec1 isetup, abform[]


===========================================================================
binit                                                                 *binit*

  Description

The binit opcode takes an input containg a TRACKS pv streaming signal
(as generated, for instance by partials) and converts it into a
equal-bandwidth bin-frame containing amplitude and frequency pairs
(PVS_AMP_FREQ), suitable for overlap-add resynthesis (such as performed
by pvsynth) or further PVS streaming phase vocoder signal
transformations. For each frequency bin, it will look for a suitable
track signal to fill it; if not found, the bin will be empty (0
amplitude). If more than one track fits a certain bin, the one with
highest amplitude will be chosen. This means that not all of the input
signal is actually 'binned', the operation is lossy. However, in many
situations this loss is not perceptually relevant.

  Syntax

fsig binit fin, isize


===========================================================================
biquad                                                               *biquad*

  Description

A sweepable general purpose biquadratic digital filter.

  Syntax

ares biquad asig, kb0, kb1, kb2, ka0, ka1, ka2 [, iskip]


===========================================================================
biquada                                                             *biquada*

  Description

A sweepable general purpose biquadratic digital filter.

  Syntax

ares biquada asig, ab0, ab1, ab2, aa0, aa1, aa2 [, iskip]


===========================================================================
birnd                                                                 *birnd*

  Description

Returns a random number in a bi-polar range.

  Syntax

birnd(x) (init- or control-rate only)

Where the argument within the parentheses may be an expression. These
value converters sample a global random sequence, but do not reference
seed. The result can be a term in a further expression.


===========================================================================
bqrez                                                                 *bqrez*

  Description

A second-order multi-mode filter.

  Syntax

ares bqrez asig, xfco, xres [, imode] [, iskip]


===========================================================================
butbp                                                                 *butbp*

  Description

Same as the butterbp opcode.

  Syntax

ares butbp asig, kfreq, kband [, iskip]

===========================================================================
butbr                                                                 *butbr*

  Description

Same as the butterbr opcode.

  Syntax

ares butbr asig, kfreq, kband [, iskip]

===========================================================================
buthp                                                                 *buthp*

  Description

Same as the butterhp opcode.

  Syntax

ares buthp asig, kfreq [, iskip]

ares buthp asig, afreq [, iskip]

===========================================================================
butlp                                                                 *butlp*

  Description

Same as the butterlp opcode.

  Syntax

ares butlp asig, kfreq [, iskip]

ares butlp asig, afreq [, iskip]

===========================================================================
butterbp                                                           *butterbp*

  Description

Implementation of a second-order band-pass Butterworth filter. This
opcode can also be written as butbp.

  Syntax

ares butterbp asig, xfreq, xband [, iskip]


===========================================================================
butterbr                                                           *butterbr*

  Description

Implementation of a second-order band-reject Butterworth filter. This
opcode can also be written as butbr.

  Syntax

ares butterbr asig, xfreq, xband [, iskip]


===========================================================================
butterhp                                                           *butterhp*

  Description

Implementation of second-order high-pass Butterworth filter. This opcode
can also be written as buthp.

  Syntax

ares butterhp asig, kfreq [, iskip]

ares butterhp asig, afreq [, iskip]


===========================================================================
butterlp                                                           *butterlp*

  Description

Implementation of a second-order low-pass Butterworth filter. This
opcode can also be written as butlp.

  Syntax

ares butterlp asig, kfreq [, iskip]

ares butterlp asig, afreq [, iskip]


===========================================================================
button                                                               *button*

  Description

Sense on-screen controls. Requires Winsound or TCL/TK.

  Syntax

kres button knum


===========================================================================
buzz                                                                   *buzz*

  Description

Output is a set of harmonically related sine partials.

  Syntax

ares buzz xamp, xcps, knh, ifn [, iphs]


===========================================================================
c2r                                                                     *c2r*

  Description

Converts a complex-valued input array into a real-valued array, by
removing its imaginary part. The output array will be halt the size of
the input. This is a utility operation to facilitate complex-valued
operations where the result is purely real.

  Syntax

kout[] c2r kin[]


===========================================================================
cabasa                                                               *cabasa*

  Description

cabasa is a semi-physical model of a cabasa sound. It is one of the
PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event
Modeling) is an algorithmic approach for simulating collisions of
multiple independent sound producing objects.

  Syntax

ares cabasa iamp, idettack [, inum] [, idamp] [, imaxshake]


===========================================================================
cauchy                                                               *cauchy*

  Description

Cauchy distribution random number generator. This is an x-class noise
generator.

  Syntax

ares cauchy kalpha

ires cauchy kalpha

kres cauchy kalpha


===========================================================================
cauchyi                                                             *cauchyi*

  Description

Cauchy distribution random number generator with controlled
interpolation between values. This is an x-class noise generator.

  Syntax

ares cauchyi klambda, xamp, xcps

ires cauchyi klambda, xamp, xcps

kres cauchyi klambda, xamp, xcps


===========================================================================
ceil                                                                   *ceil*

  Description

Returns the smallest integer not less than x

  Syntax

ceil(x) (init-, control-, or audio-rate arg allowed)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
cell                                                                   *cell*

  Description

One-Dimensional Cellular Automaton. This opcode is the modified version
of vcella by Gabriel Maldonado.

  Syntax

cell ktrig, kreinit, ioutFunc, initStateFunc, iRuleFunc, ielements


===========================================================================
cent                                                                   *cent*

  Description

Calculates a factor to raise/lower a frequency by a given amount of cents.

  Syntax

cent(x) 

This function works at a-rate, i-rate, and k-rate.


===========================================================================
centroid                                                           *centroid*

  Description

Calculate the spectral centroid of an audio signal on a given trigger.

  Syntax

kcent centroid asig, ktrig, ifftsize


===========================================================================
ceps                                                                   *ceps*

  Description

  Syntax

keps[] ceps kmags[][, icoefs]


===========================================================================
cepsinv                                                             *cepsinv*

  Description

  Syntax

kenv cepsinv keps[]


===========================================================================
cggoto                                                               *cggoto*

  Description

Transfer control to label on every pass. (Combination of cigoto and ckgoto)

  Syntax

cggoto condition, label

where label is in the same instrument block and is not an expression,
and where condition uses one of the Relational operators (<,=, <=, ==,
!=) (and = for convenience, see also under Conditional Values).


===========================================================================
chanctrl                                                           *chanctrl*

  Description

Get the current value of a controller and optionally map it onto
specified range.

  Syntax

ival chanctrl ichnl, ictlno [, ilow] [, ihigh]

kval chanctrl ichnl, ictlno [, ilow] [, ihigh]


===========================================================================
changed                                                             *changed*

  Description

This opcode outputs a trigger signal that informs when any one of its
k-rate arguments has changed. Useful with valuator widgets or MIDI
controllers.

  Syntax

ktrig changed kvar1 [, kvar2,..., kvarN]


===========================================================================
changed2                                                           *changed2*

  Description

This opcode outputs a trigger signal that informs when any one of its
k-rate arguments has changed, or a value in an array. Useful with
valuator widgets or MIDI controllers.

  Syntax

ktrig changed2 kvar1 [, kvar2,..., kvarN]

ktrig changed2 karr[]

ktrig changed2 aarr[]


===========================================================================
chani                                                                 *chani*

  Description

Reads data from a channel of the inward software bus.

  Syntax

kval chani kchan

aval chani kchan


===========================================================================
chano                                                                 *chano*

  Description

Send data to a channel of the outward software bus.

  Syntax

chano kval, kchan

chano aval, kchan


===========================================================================
chebyshevpoly                                                 *chebyshevpoly*

  Description

The chebyshevpoly opcode calculates the value of a polynomial expression
with a single a-rate input variable that is made up of a linear
combination of the first N Chebyshev polynomials of the first kind. Each
Chebyshev polynomial, Tn(x), is weighted by a k-rate coefficient, kn, so
that the opcode is calculating a sum of any number of terms in the form
kn*Tn(x). Thus, the chebyshevpoly opcode allows for the waveshaping of
an audio signal with a dynamic transfer function that gives precise
control over the harmonic content of the output.

  Syntax

aout chebyshevpoly ain, k0 [, k1 [, k2 [...]]]


===========================================================================
checkbox                                                           *checkbox*

  Description

Sense on-screen controls. Requires Winsound or TCL/TK.

  Syntax

kres checkbox knum


===========================================================================
chn                                                                     *chn*

  Description

Declare a channel of the named software bus, with setting optional
parameters in the case of a control channel. If the channel does not
exist yet, it is created, with an inital value of zero or empty string.
Otherwise, the type (control, audio, or string) of the existing channel
must match the declaration, or an init error occurs. The input/output
mode of an existing channel is updated so that it becomes the bitwise OR
of the previous and the newly specified value.

  Syntax

 chn_k Sname, imode[, itype, idflt, imin, ima, ix, iy, iwidth, iheight, Sattributes]

 chn_a Sname, imode

 chn_S Sname, imode


===========================================================================
chnclear                                                           *chnclear*

  Description

Clears an audio channel of the named software bus to zero. Implies
declaring the channel with imode=2 (see also chn_a).

  Syntax

chnclear Sname


===========================================================================
chnexport                                                         *chnexport*

  Description

Export a global variable as a channel of the bus; the channel should not
already exist, otherwise an init error occurs. This opcode is normally
called from the orchestra header, and allows the host application to
read or write orchestra variables directly, without having to use chnget
or chnset to copy data.

  Syntax

gival chnexport Sname, imode[, itype, idflt, imin, imax]

gkval chnexport Sname, imode[, itype, idflt, imin, imax]

gaval chnexport Sname, imode

gSval chnexport Sname, imode


===========================================================================
chnget                                                               *chnget*

  Description

Reads data from a channel of the inward named software bus. Implies
declaring the channel with imode=1 (see also chn_k, chn_a, and chn_S).

  Syntax

ival chnget Sname

kval chnget Sname

aval chnget Sname

Sval chnget Sname


===========================================================================
chnmix                                                               *chnmix*

  Description

Adds an audio signal to a channel of the named software bus. Implies
declaring the channel with imode=2 (see also chn_a).

  Syntax

chnmix aval, Sname


===========================================================================
chnparams                                                         *chnparams*

  Description

Query parameters of a channel (if it does not exist, all returned values
are zero).

  Syntax

itype, imode, ictltype, idflt, imin, imax chnparams


===========================================================================
chnset                                                               *chnset*

  Description

Write to a channel of the named software bus. Implies declaring the
channel with imod=2 (see also chn_k, chn_a, and chn_S).

  Syntax

chnset ival, Sname

chnset kval, Sname

chnset aval, Sname

chnset Sval, Sname


===========================================================================
chuap                                                                 *chuap*

  Description

Simulates Chua's oscillator, an LRC oscillator with an active resistor,
proved capable of bifurcation and chaotic attractors, with k-rate
control of circuit elements.

  Syntax

aI3, aV2, aV1 chuap kL, kR0, kC1, kG, kGa, kGb, kE, kC2, iI3, iV2, iV1, ktime_step


===========================================================================
cigoto                                                               *cigoto*

  Description

During the i-time pass only, conditionally transfer control to the
statement labeled by label.

  Syntax

cigoto condition, label

where label is in the same instrument block and is not an expression,
and where condition uses one of the Relational operators (<,=, <=, ==,
!=) (and = for convenience, see also under Conditional Values).


===========================================================================
ckgoto                                                               *ckgoto*

  Description

During the p-time passes only, conditionally transfer control to the
statement labeled by label.

  Syntax

ckgoto condition, label

where label is in the same instrument block and is not an expression,
and where condition uses one of the Relational operators (<,=, <=, ==,
!=) (and = for convenience, see also under Conditional Values).


===========================================================================
clear                                                                 *clear*

  Description

clear zeroes a list of audio signals.

  Syntax

clear avar1 [, avar2] [, avar3] [...]


===========================================================================
clfilt                                                               *clfilt*

  Description

Implements the classical standard analog filter types: low-pass and
high-pass. They are implemented with the four classical kinds of
filters: Butterworth, Chebyshev Type I, Chebyshev Type II, and
Elliptical. The number of poles may be any even number from 2 to 80.

  Syntax

ares clfilt asig, kfreq, itype, inpol [, ikind] [, ipbr] [, isba] [, iskip]


===========================================================================
clip                                                                   *clip*

  Description

Clips an a-rate signal to a predefined limit, in a “soft” manner, using
one of three methods.

  Syntax

ares clip asig, imeth, ilimit [, iarg]


===========================================================================
clockoff                                                           *clockoff*

  Description

Stops one of a number of internal clocks.

  Syntax

clockoff inum


===========================================================================
clockon                                                             *clockon*

  Description

Starts one of a number of internal clocks.

  Syntax

clockon inum


===========================================================================
cmplxprod                                                         *cmplxprod*

  Description

Calculates the complex product of two arrays of the same size and in
real-imaginary interleaved format.

  Syntax

kout[] cmplxprod kin1[], kin2[]


===========================================================================
cngoto                                                               *cngoto*

  Description

Transfers control on every pass when the condition is not true.

  Syntax

cngoto condition, label

where label is in the same instrument block and is not an expression,
and where condition uses one of the Relational operators (<,=, <=, ==,
!=) (and = for convenience, see also under Conditional Values).


===========================================================================
comb                                                                   *comb*

  Description

Reverberates an input signal with a “colored” frequency response.

  Syntax

ares comb asig, krvt, ilpt [, iskip] [, insmps]


===========================================================================
combinv                                                             *combinv*

  Description

Reverberates an input signal with a “colored” frequency response with a
FIR filter.

  Syntax

ares combinv asig, krvt, ilpt [, iskip] [, insmps]


===========================================================================
compilecsd                                                       *compilecsd*

  Description

Compilecsd will read a CSD file and compile one or more instruments at
init time, which will be added to the running engine. In case of
existing instrument numbers or names, these will be replaced, but any
instance still running of the old instrument definition will still
perform until it terminates. In addition, it will read the score (if it
exists) contained in the CSD file and add it to the list of events to be
performed by Csound. The opcode ignores any section in the CSD file that
is not the orchestra or the score.

  Syntax

ires compilecsd Sfilename


===========================================================================
compileorc                                                       *compileorc*

  Description

Compileorc will compile one or more instruments at init time, which will
be added to the running engine. In case of existing instrument numbers
or names, these will be replaced, but any instance still running of the
old instrument definition will still perform until it terminates.

  Syntax

ires compileorc Sfilename


===========================================================================
compilestr                                                       *compilestr*

  Description

Compilestr will compile one or more instruments at init time, which will
be added to the running engine. In case of existing instrument numbers
or names, these will be replaced, but any instance still running of the
old instrument definition will still perform until it terminates. Only
new instances will use the new definition. Multi-line strings are
accepted, using {{ }} to enclose the string.

  Syntax

ires compilestr Sorch


===========================================================================
compress                                                           *compress*

  Description

This unit functions as an audio compressor, limiter, expander, or noise
gate, using either soft-knee or hard-knee mapping, and with dynamically
variable performance characteristics. It takes two audio input signals,
aasig and acsig, the first of which is modified by a running analysis of
the second. Both signals can be the same, or the first can be modified
by a different controlling signal.

compress first examines the controlling acsig by performing envelope
detection. This is directed by two control values katt and krel,
defining the attack and release time constants (in seconds) of the
detector. The detector rides the peaks (not the RMS) of the control
signal. Typical values are .01 and .1, the latter usually being similar
to ilook.

The running envelope is next converted to decibels, then passed through
a mapping function to determine what compresser action (if any) should
be taken. The mapping function is defined by four decibel control
values. These are given as positive values, where 0 db corresponds to an
amplitude of 0dbfs/32768, and 90 db corresponds to an amplitude of 0dbfs.

  Syntax

ar compress aasig, acsig, kthresh, kloknee, khiknee, kratio, katt, krel, ilook


===========================================================================
compress2                                                         *compress2*

  Description

This unit functions as an audio compressor, limiter, expander, or noise
gate, using either soft-knee or hard-knee mapping, and with dynamically
variable performance characteristics. It takes two audio input signals,
aasig and acsig, the first of which is modified by a running analysis of
the second. Both signals can be the same, or the first can be modified
by a different controlling signal.

compress2 first examines the controlling acsig by performing envelope
detection. This is directed by two control values katt and krel,
defining the attack and release time constants (in seconds) of the
detector. The detector rides the peaks (not the RMS) of the control
signal. Typical values are .01 and .1, the latter usually being similar
to ilook.

The running envelope is next converted to decibels, then passed through
a mapping function to determine what compresser action (if any) should
be taken. The mapping function is defined by four decibel control
values. These are given as positive values, where 0 db corresponds to an
amplitude of 0dbfs.

  Syntax

ar compress2 aasig, acsig, kthresh, kloknee, khiknee, kratio, katt, krel, ilook


===========================================================================
connect                                                             *connect*

  Description

The connect opcode, valid only in the orchestra header, sends the
signals from the indicated outlet in all instances of the indicated
source instrument to the indicated inlet in all instances of the
indicated sink instrument. Each inlet instance receives the sum of the
signals in all outlet instances. Thus multiple instances of an outlet
may fan in to one instance of an inlet, or one instance of an outlet may
fan out to multiple instances of an inlet.

When Csound creates a new instance of an instrument template, new
instances of its connections also are created.

  Syntax

connect Tsource1, Soutlet1, Tsink1, Sinlet1


===========================================================================
control                                                             *control*

  Description

Configurable slider controls for realtime user input. Requires Winsound
or TCL/TK. control reads a slider's value.

  Syntax

kres control knum


===========================================================================
convle                                                               *convle*

  Description

Same as the convolve opcode.

===========================================================================
convolve                                                           *convolve*

  Description

Output is the convolution of signal ain and the impulse response
contained in ifilcod. If more than one output signal is supplied, each
will be convolved with the same impulse response. Note that it is
considerably more efficient to use one instance of the operator when
processing a mono input to create stereo, or quad, outputs.

Note: this opcode can also be written as convle.

  Syntax

ar1 [, ar2] [, ar3] [, ar4] convolve ain, ifilcod [, ichannel]


===========================================================================
copya2ftab                                                       *copya2ftab*

  Description

The copya2ftab opcode takes a k-array and copies the contents to an
f-table.

  Syntax

copya2ftab kftbl, tab


===========================================================================
copyf2array                                                     *copyf2array*

  Description

The copyf2array opcode takes an f-table and copies the contents to a t-var.

  Syntax

copyf2array tab, kftbl


===========================================================================
cos                                                                     *cos*

  Description

Returns the cosine of x (x in radians).

  Syntax

cos(x) (no rate restriction)


===========================================================================
cosseg                                                               *cosseg*

  Description

Trace a series of line segments between specified points with cosine
interpolation.

  Syntax

ares cosseg ia, idur1, ib [, idur2] [, ic] [...]

kres cosseg ia, idur1, ib [, idur2] [, ic] [...]


===========================================================================
cossegb                                                             *cossegb*

  Description

Trace a series of line segments between specified absolute points with
cosine interpolation.

  Syntax

ares cossegb ia, itim1, ib [, itim2] [, ic] [...]

kres cossegb ia, itim1, ib [, itim2] [, ic] [...]


===========================================================================
cossegr                                                             *cossegr*

  Description

Trace a series of line segments between specified points with cosine
interpolation, including a release segment.

  Syntax

ares cossegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz

kres cossegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz


===========================================================================
cosh                                                                   *cosh*

  Description

Returns the hyperbolic cosine of x (x in radians).

  Syntax

cosh(x) (no rate restriction)


===========================================================================
cosinv                                                               *cosinv*

  Description

Returns the arccosine of x (x in radians).

  Syntax

cosinv(x) (no rate restriction)


===========================================================================
cps2pch                                                             *cps2pch*

  Description

Converts a pitch-class value into cycles-per-second (Hz) for equal
divisions of the octave.

  Syntax

icps cps2pch ipch, iequal


===========================================================================
cpsmidi                                                             *cpsmidi*

  Description

Get the note number of the current MIDI event, expressed in
cycles-per-second.

  Syntax

icps cpsmidi


===========================================================================
cpsmidib                                                           *cpsmidib*

  Description

Get the note number of the current MIDI event and modify it by the
current pitch-bend value, express it in cycles-per-second.

  Syntax

icps cpsmidib [irange]

kcps cpsmidib [irange]


===========================================================================
cpsmidinn                                                         *cpsmidinn*

  Description

Converts a Midi note number value to cycles-per-second.

  Syntax

cpsmidinn (MidiNoteNumber)  (init- or control-rate args only)

where the argument within the parentheses may be a further expression.


===========================================================================
cpsoct                                                               *cpsoct*

  Description

Converts an octave-point-decimal value to cycles-per-second.

  Syntax

cpsoct (oct)  (no rate restriction)

where the argument within the parentheses may be a further expression.


===========================================================================
cpspch                                                               *cpspch*

  Description

Converts a pitch-class value to cycles-per-second.

  Syntax

cpspch (pch)  (init- or control-rate args only)

where the argument within the parentheses may be a further expression.


===========================================================================
cpstmid                                                             *cpstmid*

  Description

This unit is similar to cpsmidi, but allows fully customized
micro-tuning scales.

  Syntax

icps cpstmid ifn


===========================================================================
cpstun                                                               *cpstun*

  Description

Returns micro-tuning values at k-rate.

  Syntax

kcps cpstun ktrig, kindex, kfn


===========================================================================
cpstuni                                                             *cpstuni*

  Description

Returns micro-tuning values at init-rate.

  Syntax

icps cpstuni index, ifn


===========================================================================
cpsxpch                                                             *cpsxpch*

  Description

Converts a pitch-class value into cycles-per-second (Hz) for equal
divisions of any interval. There is a restriction of no more than 100
equal divisions.

  Syntax

icps cpsxpch ipch, iequal, irepeat, ibase


===========================================================================
cpumeter                                                           *cpumeter*

  Description

Reports the usage of cpu either total or per core to monitor how close
to max-out the processing is.

  Syntax

ktot[,kcpu1, kcpu2,...]cpumeter ifreq


===========================================================================
cpuprc                                                               *cpuprc*

  Description

Control allocation of cpu resources on a per-instrument basis, to
optimize realtime output.

  Syntax

cpuprc insnum, ipercent

cpuprc Sinsname, ipercent


===========================================================================
cross2                                                               *cross2*

  Description

This is an implementation of cross synthesis using FFT's.

  Syntax

ares cross2 ain1, ain2, isize, ioverlap, iwin, kbias


===========================================================================
crossfm                                                             *crossfm*

  Description

Two oscillators, mutually frequency and/or phase modulated by each other.

  Syntax

a1, a2 crossfm xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]

a1, a2 crossfmi xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]

a1, a2 crosspm xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]

a1, a2 crosspmi xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]

a1, a2 crossfmpm xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]

a1, a2 crossfmpmi xfrq1, xfrq2, xndx1, xndx2, kcps, ifn1, ifn2 [, iphs1] [, iphs2]


===========================================================================
crunch                                                               *crunch*

  Description

crunch is a semi-physical model of a crunch sound. It is one of the
PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event
Modeling) is an algorithmic approach for simulating collisions of
multiple independent sound producing objects.

  Syntax

ares crunch iamp, idettack [, inum] [, idamp] [, imaxshake]


===========================================================================
ctrl14                                                               *ctrl14*

  Description

Allows a floating-point 14-bit MIDI signal scaled with a minimum and a
maximum range.

  Syntax

idest ctrl14 ichan, ictlno1, ictlno2, imin, imax [, ifn]

kdest ctrl14 ichan, ictlno1, ictlno2, kmin, kmax [, ifn]


===========================================================================
ctrl21                                                               *ctrl21*

  Description

Allows a floating-point 21-bit MIDI signal scaled with a minimum and a
maximum range.

  Syntax

idest ctrl21 ichan, ictlno1, ictlno2, ictlno3, imin, imax [, ifn]

kdest ctrl21 ichan, ictlno1, ictlno2, ictlno3, kmin, kmax [, ifn]


===========================================================================
ctrl7                                                                 *ctrl7*

  Description

Allows a floating-point 7-bit MIDI signal scaled with a minimum and a
maximum range.

  Syntax

idest ctrl7 ichan, ictlno, imin, imax [, ifn]

kdest ctrl7 ichan, ictlno, kmin, kmax [, ifn]

adest ctrl7 ichan, ictlno, kmin, kmax [, ifn] [, icutoff]


===========================================================================
ctrlinit                                                           *ctrlinit*

  Description

Sets the initial values for a set of MIDI controllers.

  Syntax

ctrlinit ichnl, ictlno1, ival1 [, ictlno2] [, ival2] [, ictlno3] \
      [, ival3] [,...ival32]


===========================================================================
cuserrnd                                                           *cuserrnd*

  Description

Continuous USER-defined-distribution RaNDom generator.

  Syntax

aout cuserrnd kmin, kmax, ktableNum

iout cuserrnd imin, imax, itableNum

kout cuserrnd kmin, kmax, ktableNum


===========================================================================
dam                                                                     *dam*

  Description

This opcode dynamically modifies a gain value applied to the input sound
ain by comparing its power level to a given threshold level. The signal
will be compressed/expanded with different factors regarding that it is
over or under the threshold.

  Syntax

ares dam asig, kthreshold, icomp1, icomp2, irtime, iftime


===========================================================================
date                                                                   *date*

  Description

Returns the number seconds since a base date, using the operating
system's clock. The base is 1 January 1970 for Csound using doubles, and
1 January 2010 for versions using floats. On operating systemms with
sufficient resolution the date includes fractional seconds.

  Syntax

ir[, inano] date

kr[, knano] date


===========================================================================
dates                                                                 *dates*

  Description

Returns as a string the date and time specified.

  Syntax

Sir dates [ itime]


===========================================================================
db                                                                       *db*

  Description

Returns the amplitude equivalent for a given decibel amount. This opcode
is the same as ampdb.

  Syntax

db(x)

This function works at a-rate, i-rate, and k-rate.


===========================================================================
dbamp                                                                 *dbamp*

  Description

Returns the decibel equivalent of the raw amplitude x.

  Syntax

dbamp(x)  (init-rate or control-rate args only)


===========================================================================
dbfsamp                                                             *dbfsamp*

  Description

Returns the decibel equivalent of the raw amplitude x, relative to full
scale amplitude. Full scale is assumed to be 16 bit. New is Csound
version 4.10.

  Syntax

dbfsamp(x)  (init-rate or control-rate args only)


===========================================================================
dcblock                                                             *dcblock*

  Description

Implements the DC blocking filter

Y[i] = X[i] - X[i-1] + (igain * Y[i-1])

Based on work by Perry Cook.

  Syntax

ares dcblock ain [, igain]


===========================================================================
dcblock2                                                           *dcblock2*

  Description

Implements a DC blocking filter with improved DC attenuation.

  Syntax

ares dcblock2 ain [, iorder] [, iskip]


===========================================================================
dconv                                                                 *dconv*

  Description

A direct convolution opcode.

  Syntax

ares dconv asig, isize, ifn


===========================================================================
delay                                                                 *delay*

  Description

A signal can be read from or written into a delay path, or it can be
automatically delayed by some time interval.

  Syntax

ares delay asig, idlt [, iskip]


===========================================================================
delay1                                                               *delay1*

  Description

Delays an input signal by one sample.

  Syntax

ares delay1 asig [, iskip]


===========================================================================
delayk                                                               *delayk*

  Description

k-rate delay opcodes

  Syntax

kr delayk   ksig, idel[, imode]

kr vdel_k   ksig, kdel, imdel[, imode]


===========================================================================
delayr                                                               *delayr*

  Description

Reads from an automatically established digital delay line.

  Syntax

ares delayr idlt [, iskip]


===========================================================================
delayw                                                               *delayw*

  Description

Writes the audio signal to a digital delay line.

  Syntax

delayw asig


===========================================================================
deltap                                                               *deltap*

  Description

Tap a delay line at variable offset times.

  Syntax

ares deltap kdlt


===========================================================================
deltap3                                                             *deltap3*

  Description

Taps a delay line at variable offset times, uses cubic interpolation.

  Syntax

ares deltap3 xdlt


===========================================================================
deltapi                                                             *deltapi*

  Description

Taps a delay line at variable offset times, uses interpolation.

  Syntax

ares deltapi xdlt


===========================================================================
deltapn                                                             *deltapn*

  Description

Tap a delay line at variable offset times.

  Syntax

ares deltapn xnumsamps


===========================================================================
deltapx                                                             *deltapx*

  Description

deltapx is similar to deltapi or deltap3. However, it allows higher
quality interpolation. This opcode can read from and write to a
delayr/delayw delay line with interpolation.

  Syntax

aout deltapx adel, iwsize


===========================================================================
deltapxw                                                           *deltapxw*

  Description

deltapxw mixes the input signal to a delay line. This opcode can be
mixed with reading units (deltap, deltapn, deltapi, deltap3, and
deltapx) in any order; the actual delay time is the difference of the
read and write time. This opcode can read from and write to a
delayr/delayw delay line with interpolation.

  Syntax

deltapxw ain, adel, iwsize


===========================================================================
denorm                                                               *denorm*

  Description

Mixes low level (~1e-20 for floats, and ~1e-56 for doubles) noise to a
list of a-rate signals. Can be used before IIR filters and reverbs to
avoid denormalized numbers which may otherwise result in significantly
increased CPU usage.

  Syntax

denorm a1[, a2[, a3[, ... ]]]


===========================================================================
diff                                                                   *diff*

  Description

Modify a signal by differentiation.

  Syntax

ares diff asig [, iskip]

kres diff ksig [, iskip]


===========================================================================
directory                                                         *directory*

  Description

Reads a directory for files and passes them to a string array. Users can
set the file type by passing a file extension as a string.

  Syntax

SFiles[] directory SDirectory[, SExtention]


===========================================================================
diskgrain                                                         *diskgrain*

  Description

diskgrain implements synchronous granular synthesis. The source sound
for the grains is obtained by reading a soundfile containing the samples
of the source waveform.

  Syntax

asig diskgrain Sfname, kamp, kfreq, kpitch, kgrsize, kprate, \
      ifun, iolaps [,imaxgrsize , ioffset]


===========================================================================
diskin                                                               *diskin*

  Description

Reads audio data from an external device or stream and can alter its pitch.

  Syntax

ar1 [, ar2 [, ar3 [, ... arN]]] diskin ifilcod[, kpitch[, iskiptim \
      [, iwraparound[, iformat[, iskipinit]]]]]

Note the N was 24 in versions before 5.14, and 40 after.

ar1[] diskin ifilcod[, kpitch[, iskiptim \
      [, iwraparound[, iformat[, iskipinit]]]]]

(in this version, the number of output channels is not limited.)


===========================================================================
diskin2                                                             *diskin2*

  Description

Reads audio data from a file, and can alter its pitch using one of
several available interpolation types, as well as convert the sample
rate to match the orchestra sr setting. diskin2 can also read
multichannel files with any number of channels in the range 1 to 24 in
versions before 5.14, and 40 after.

  Syntax

a1[, a2[, ... aN]] diskin2 ifilcod[, kpitch[, iskiptim \
      [, iwrap[, iformat[, iwsize[, ibufsize[, iskipinit]]]]]]]

ar1[] diskin2 ifilcod[, kpitch[, iskiptim \
      [, iwrap[, iformat[, iwsize[, ibufsize[, iskipinit]]]]]]]

(in the array output version, the number of output channels does not
have an upper limit.)


===========================================================================
dispfft                                                             *dispfft*

  Description

These units will print orchestra init-values, or produce graphic display
of orchestra control signals and audio signals. Uses X11 windows if
enabled, else (or if -g flag is set) displays are approximated in ASCII
characters.

  Syntax

dispfft xsig, iprd, iwsiz [, iwtyp] [, idbout] [, iwtflg] [,imin] [,imax]


===========================================================================
display                                                             *display*

  Description

These units will print orchestra init-values, or produce graphic display
of orchestra control signals and audio signals. Uses X11 windows if
enabled, else (or if -g flag is set) displays are approximated in ASCII
characters.

  Syntax

display xsig, iprd [, inprds] [, iwtflg]


===========================================================================
distort                                                             *distort*

  Description

Distort an audio signal via waveshaping and optional clipping.

  Syntax

ar distort asig, kdist, ifn[, ihp, istor]


===========================================================================
distort1                                                           *distort1*

  Description

Implementation of modified hyperbolic tangent distortion. distort1 can
be used to generate wave shaping distortion based on a modification of
the tanh function.

         exp(asig * (shape1 + pregain)) - exp(asig * (shape2 - pregain))
  aout = ---------------------------------------------------------------
         exp(asig * pregain)            + exp(-asig * pregain)

  Syntax

ares distort1 asig, kpregain, kpostgain, kshape1, kshape2[, imode]


===========================================================================
divz                                                                   *divz*

  Syntax

ares divz xa, xb, ksubst

ires divz ia, ib, isubst

kres divz ka, kb, ksubst

...divz(ka, kb, ksubst)... (no rate restriction)

  Description

Safely divides two numbers.


===========================================================================
doppler                                                             *doppler*

  Description

A fast and robust method for approximating sound propagation, achieving
convincing Doppler shifts without having to solve equations. The method
computes frequency shifts based on reading an input delay line at a
delay time computed from the distance between source and mic and the
speed of sound. One instance of the opcode is required for each
dimension of space through which the sound source moves. If the source
sound moves at a constant speed from in front of the microphone, through
the microphone, to behind the microphone, then the output will be
frequency shifted above the source frequency at a constant frequency
while the source approaches, then discontinuously will be shifted below
the source frequency at a constant frequency as the source recedes from
the microphone. If the source sound moves at a constant speed through a
point to one side of the microphone, then the rate of change of position
will not be constant, and the familiar Doppler frequency shift typical
of a siren or engine approaching and receding along a road beside a
listener will be heard.

  Syntax

ashifted doppler asource, ksourceposition, kmicposition [, isoundspeed, ifiltercutoff]


===========================================================================
downsamp                                                           *downsamp*

  Description

Modify a signal by down-sampling.

  Syntax

kres downsamp asig [, iwlen]


===========================================================================
dripwater                                                         *dripwater*

  Description

dripwater is a semi-physical model of a water drop. It is one of the
PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event
Modeling) is an algorithmic approach for simulating collisions of
multiple independent sound producing objects.

  Syntax

ares dripwater kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \
      [, ifreq1] [, ifreq2]


===========================================================================
dssiactivate                                                   *dssiactivate*

  Syntax

dssiactivate ihandle, ktoggle 

  Description

dssiactivate is used to activate or deactivate a DSSI or LADSPA plugin.
It calles the plugin's activate() and deactivate() functions if they are
provided.


===========================================================================
dssiaudio                                                         *dssiaudio*

  Syntax

[aout1, aout2, ..., aout9] dssiaudio ihandle, [ain1, ain2, ..., ain9]

  Description

dssiaudio generates audio by processing an input signal through a LADSPA
plugin.


===========================================================================
dssictls                                                           *dssictls*

  Syntax

dssictls ihandle, iport, kvalue, ktrigger 

  Description

dssictls sends control values to a plugin's control port


===========================================================================
dssiinit                                                           *dssiinit*

  Syntax

ihandle dssiinit ilibraryname, iplugindex [, iverbose] 

  Description

dssiinit is used to load a DSSI or LADSPA plugin into memory for use
with the other dssi4cs opcodes. Both LADSPA effects and DSSI instruments
can be used.


===========================================================================
dssilist                                                           *dssilist*

  Syntax

dssilist

  Description

dssilist checks the variables DSSI_PATH and LADSPA_PATH and lists all
plugins available in all plugin libraries there.

LADSPA and DSSI libraries may contain more than one plugin which must be
referenced by the index provided by dssilist.

This opcode produces a long printout which may interrupt realtime audio
output, so it should be run at the start of a performance.


===========================================================================
dumpk                                                                 *dumpk*

  Description

Periodically writes an orchestra control-signal value to a named
external file in a specific format.

  Syntax

dumpk  ksig, ifilname, iformat, iprd


===========================================================================
dumpk2                                                               *dumpk2*

  Description

Periodically writes two orchestra control-signal values to a named
external file in a specific format.

  Syntax

dumpk2 ksig1, ksig2, ifilname, iformat, iprd


===========================================================================
dumpk3                                                               *dumpk3*

  Description

Periodically writes three orchestra control-signal values to a named
external file in a specific format.

  Syntax

dumpk3 ksig1, ksig2, ksig3, ifilname, iformat, iprd


===========================================================================
dumpk4                                                               *dumpk4*

  Description

Periodically writes four orchestra control-signal values to a named
external file in a specific format.

  Syntax

dumpk4 ksig1, ksig2, ksig3, ksig4, ifilname, iformat, iprd


===========================================================================
duserrnd                                                           *duserrnd*

  Description

Discrete USER-defined-distribution RaNDom generator.

  Syntax

aout duserrnd ktableNum

iout duserrnd itableNum

kout duserrnd ktableNum


===========================================================================
dust                                                                   *dust*

  Description

Generates random impulses from 0 to 1.

  Syntax

ares dust kamp, kdensity

kres dust kamp, kdensity


===========================================================================
dust2                                                                 *dust2*

  Description

Generates random impulses from -1 to 1.

  Syntax

ares dust2 kamp, kdensity

kres dust2 kamp, kdensity


===========================================================================
else                                                                   *else*

  Description

Executes a block of code when an "if...then" condition is false.

  Syntax

else


===========================================================================
elseif                                                               *elseif*

  Description

Defines another "if...then" condition when a "if...then" condition is
false.

  Syntax

elseif xa R xb then

where label is in the same instrument block and is not an expression,
and where R is one of the Relational operators (<, =, <=, ==, !=) (and =
for convenience, see also under Conditional Values).


===========================================================================
endif                                                                 *endif*

  Description

Closes a block of code that begins with an "if...then" statement.

  Syntax

endif


===========================================================================
endin                                                                 *endin*

  Description

Ends the current instrument block.

  Syntax

endin


===========================================================================
endop                                                                 *endop*

  Description

Marks the end of an user-defined opcode block.

  Syntax

endop


===========================================================================
envlpx                                                               *envlpx*

  Description

envlpx -- apply an envelope consisting of 3 segments:

 1. stored function rise shape

 2. modified exponential pseudo steady state

 3. exponential decay

  Syntax

ares envlpx xamp, irise, idur, idec, ifn, iatss, iatdec [, ixmod]

kres envlpx kamp, irise, idur, idec, ifn, iatss, iatdec [, ixmod]


===========================================================================
envlpxr                                                             *envlpxr*

  Description

envlpxr is the same as envlpx except that the final segment is entered
only on sensing a MIDI note release. The note is then extended by the
decay time.

  Syntax

ares envlpxr xamp, irise, idec, ifn, iatss, iatdec [, ixmod] [,irind]

kres envlpxr kamp, irise, idec, ifn, iatss, iatdec [, ixmod] [,irind]


===========================================================================
ephasor                                                             *ephasor*

  Description

This opcode produces two outputs: a periodic phase signal (like the
phasor opcode), and a periodic exponential decaying signal. The latter
is synchronised to the former, starting at 1 and then decreasing at the
same time as the phase signal increases from 0 to 1. The rate of
exponential decay can be controlled by the second parameter.

  Syntax

aexp,aph ephasor kfreq, kR


===========================================================================
eqfil                                                                 *eqfil*

  Description

The opcode eqfil is a 2nd order tunable equalisation filter based on
Regalia and Mitra design ("Tunable Digital Frequency Response
Equalization Filters", IEEE Trans. on Ac., Sp. and Sig Proc., 35 (1),
1987). It provides a peak/notch filter for building parametric/graphic
equalisers.

The amplitude response for this filter will be flat (=1) for kgain=1.
With kgain bigger than 1, there will be a peak at the centre frequency,
whose width is given by the kbw parameter, but outside this band, the
response will tend towards 1. Conversely, if kgain is smaller than 1, a
notch will be created around the CF.

  Syntax

asig eqfil ain, kcf, kbw, kgain[, istor]


===========================================================================
evalstr                                                             *evalstr*

  Description

Evalstr compiles and runs Csound code and returns a value from the
global space (instr 0). This opcode can be also used to compile new
instruments (as compilestr).

  Syntax

ires evalstr Scode 

kres evalstr Scode, ktrig 


===========================================================================
event                                                                 *event*

  Description

Generates a score event from an instrument.

  Syntax

event "scorechar", kinsnum, kdelay, kdur, [, kp4] [, kp5] [, ...]

event "scorechar", "insname", kdelay, kdur, [, kp4] [, kp5] [, ...]


===========================================================================
event_i                                                             *event_i*

  Description

Generates a score event from an instrument.

  Syntax

event_i "scorechar", iinsnum, idelay, idur, [, ip4] [, ip5] [, ...]

event_i "scorechar", "insname", idelay, idur, [, ip4] [, ip5] [, ...]


===========================================================================
exciter                                                             *exciter*

  Description

"Filtered distortion to add brilliance to a signal"

  Syntax

ares exciter asig, kfreq, kceil, kharmonics, kblend


===========================================================================
exitnow                                                             *exitnow*

  Description

In Csound4 calls an exit function to leave Csound as fast as possible.
On Csound5 exits back to the driving code.

  Syntax

exitnow [ivalue]


===========================================================================
exp                                                                     *exp*

  Description

Returns e raised to the xth power.

  Syntax

exp(x) (no rate restriction)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
expcurve                                                           *expcurve*

  Description

Generates an exponential curve in range 0 to 1 of arbitrary steepness.
Steepness index equal to or lower than 1.0 will result in Not-a-Number
errors and cause unstable behavior.

The formula used to calculate the curve is:

(exp(x * log(y))-1) / (y-1)

where x is equal to kindex and y is equal to ksteepness.

  Syntax

kout expcurve kindex, ksteepness


===========================================================================
expon                                                                 *expon*

  Description

Trace an exponential curve between specified points.

  Syntax

ares expon ia, idur, ib

kres expon ia, idur, ib


===========================================================================
exprand                                                             *exprand*

  Description

Exponential distribution random number generator (positive values only).
This is an x-class noise generator.

  Syntax

ares exprand klambda

ires exprand klambda

kres exprand klambda


===========================================================================
exprandi                                                           *exprandi*

  Description

Exponential distribution random number generator with controlled
interpolation between values (positive values only). This is an x-class
noise generator.

  Syntax

ares exprandi klambda, xamp, xcps

ires exprandi klambda, xamp, xcps

kres exprandi klambda, xamp, xcps


===========================================================================
expseg                                                               *expseg*

  Description

Trace a series of exponential segments between specified points.

  Syntax

ares expseg ia, idur1, ib [, idur2] [, ic] [...]

kres expseg ia, idur1, ib [, idur2] [, ic] [...]


===========================================================================
expsega                                                             *expsega*

  Description

An exponential segment generator operating at a-rate. This unit is
almost identical to expseg, but more precise when defining segments with
very short durations (i.e., in a percussive attack phase) at audio rate.

  Syntax

ares expsega ia, idur1, ib [, idur2] [, ic] [...]


===========================================================================
expsegb                                                             *expsegb*

  Description

Trace a series of exponential segments between specified absolute points.

  Syntax

ares expsegb ia, itim1, ib [, itim2] [, ic] [...]

kres expsegb ia, itim1, ib [, itim2] [, ic] [...]


===========================================================================
expsegba                                                           *expsegba*

  Description

An exponential segment generator operating at a-rate. This unit is
almost identical to expsegb, but more precise when defining segments
with very short durations (i.e., in a percussive attack phase) at audio
rate.

  Syntax

ares expsegba ia, itim1, ib [, itim2] [, ic] [...]


===========================================================================
expsegr                                                             *expsegr*

  Description

Trace a series of exponential segments between specified points
including a release segment.

  Syntax

ares expsegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz

kres expsegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz


===========================================================================
faustaudio                                                       *faustaudio*

  Description

Faustaudio will instantiate and run a Faust program compiled with
faustcompile.

  Syntax

ihandle,a1[,a2,...] faustaudio ifac[,ain1,...] 


===========================================================================
faustcompile                                                   *faustcompile*

  Description

Faustcompile will compile a Faust program from a string, controlled by
various arguments. Multi-line strings are accepted, using {{ }} to
enclose the string.

  Syntax

ihandle faustcompile Scode, Sargs 


===========================================================================
faustctl                                                           *faustctl*

  Description

Faustctl will set a given control in a running faust program

  Syntax

faustctl idsp,Scontrol,kval 


===========================================================================
faustgen                                                           *faustgen*

  Description

Faustgen will invoke the just-in-time compiler, instantiate and run a
Faust program.

  Syntax

ihandle,a1[,a2,...] faustgen SCode[,ain1,...] 


===========================================================================
fareylen                                                           *fareylen*

  Description

This opcode can be used in conjunction with GENfarey. It calculates the
length of Farey Sequence F_n . Its length is given by: |F_n | = 1 + SUM
over n phi(m) where phi(m) is Euler's totient function, which gives the
number of integers ≤ m that are coprime to m.

Some values for the length of F_n given n:

n       F_n
1       2
2       3
3       5
4       7
5       11
6       13
7       19
8       23
9       29
10      33
11      43
12      47
13      59
14      65
15      73
16      81
17      97
18      103
19      121
20      129

  Syntax

kfl fareylen kfn


===========================================================================
fareyleni                                                         *fareyleni*

  Description

This opcode can be used in conjunction with GENfarey. It calculates the
length of Farey Sequence F_n . Its length is given by: |F_n | = 1 + SUM
over n phi(m) where phi(m) is Euler's totient function, which gives the
number of integers ≤ m that are coprime to m.

Some values for the length of F_n given n:

n       F_n
1       2
2       3
3       5
4       7
5       11
6       13
7       19
8       23
9       29
10      33
11      43
12      47
13      59
14      65
15      73
16      81
17      97
18      103
19      121
20      129

  Syntax

ifl fareyleni ifn


===========================================================================
ficlose                                                             *ficlose*

  Description

ficlose can be used to close a file which was opened with fiopen.

  Syntax

ficlose ihandle

ficlose Sfilename


===========================================================================
filebit                                                             *filebit*

  Description

Returns the number of bits in each sample in a sound file.

  Syntax

ir filebit ifilcod [, iallowraw]


===========================================================================
filelen                                                             *filelen*

  Description

Returns the length of a sound file.

  Syntax

ir filelen ifilcod, [iallowraw]


===========================================================================
filenchnls                                                       *filenchnls*

  Description

Returns the number of channels in a sound file.

  Syntax

ir filenchnls ifilcod [, iallowraw]


===========================================================================
filepeak                                                           *filepeak*

  Description

Returns the peak absolute value of a sound file.

  Syntax

ir filepeak ifilcod [, ichnl]


===========================================================================
filescal                                                           *filescal*

  Description

filescal implements phase-locked vocoder processing from disk files,
resampling if necessary.

This opcode allows for time and frequency-independent scaling. Time is
advanced internally, but controlled by a tempo scaling parameter; when
an onset is detected, timescaling is momentarily stopped to avoid
smearing of attacks. The quality of the effect is generally improved
with phase locking switched on.

filescal will also scale pitch, independently of frequency, using a
transposition factor (k-rate).

  Syntax

asig[,asig2] filescal ktimescal, kamp, kpitch, Sfile, klock [,ifftsize, idecim, ithresh]


===========================================================================
filesr                                                               *filesr*

  Description

Returns the sample rate of a sound file.

  Syntax

ir filesr ifilcod [, iallowraw]


===========================================================================
filevalid                                                         *filevalid*

  Description

Returns 1 if the sound file is valid, or 0 if not.

  Syntax

ir filevalid ifilcod


===========================================================================
fillarray                                                         *fillarray*

  Description

Generate a vector (one-dimensional k-rate array) with a sequence of
numeric or string values.

  Syntax

karray[] fillarray ival1, ival2,.....ivaln

karray fillarray ival1, ival2,.....ivaln


===========================================================================
fft                                                                     *fft*

  Description

Applies a forward Fast Fourier Transform to a complex-valued input
1-dimensional array producing a complex-valued output. The output is
another array containing the complex-valued signal, and both arrays are
arranged in interleaved real-imaginary format. The output array will
have the same size as the input, and the transform size will be
equivalent to half of the length of the array. Non-power-of-two
transforms are limited to even sizes with not too many factors.

  Syntax

kout[] fft kin[]


===========================================================================
filter2                                                             *filter2*

  Description

General purpose custom filter with no time-varying pole control. The
filter coefficients implement the following difference equation:

(1)*y(n) = b0*x[n] + b1*x[n-1] +...+ bM*x[n-M] - a1*y[n-1] -...- aN*y[n-N]

the system function for which is represented by:

           B(Z)      b0 + b1*Z^-1   + ... + bM*Z^-M
  H(Z)  =  ----  =  --------------------------
           A(Z)       1 + a1*Z^-1   + ... + aN*Z^-N

  Syntax

ares filter2 asig, iM, iN, ib0, ib1, ..., ibM, ia1, ia2, ..., iaN

kres filter2 ksig, iM, iN, ib0, ib1, ..., ibM, ia1, ia2, ..., iaN


===========================================================================
fin                                                                     *fin*

  Description

Read signals from a file at a-rate.

  Syntax

fin ifilename, iskipframes, iformat, ain1 [, ain2] [, ain3] [,...]

fin ifilename, iskipframes, iformat, arr[]


===========================================================================
fini                                                                   *fini*

  Description

Read signals from a file at i-rate.

  Syntax

fini ifilename, iskipframes, iformat, in1 [, in2] [, in3] [, ...]


===========================================================================
fink                                                                   *fink*

  Description

Read signals from a file at k-rate.

  Syntax

fink ifilename, iskipframes, iformat, kin1 [, kin2] [, kin3] [,...]


===========================================================================
fiopen                                                               *fiopen*

  Description

fiopen can be used to open a file in one of the specified modes.

  Syntax

ihandle fiopen ifilename, imode


===========================================================================
flanger                                                             *flanger*

  Description

A user controlled flanger.

  Syntax

ares flanger asig, adel, kfeedback [, imaxd]


===========================================================================
flashtxt                                                           *flashtxt*

  Description

Allows text to be displayed from instruments like sliders etc. (only on
Unix and Windows at present)

  Syntax

flashtxt  iwhich, String


===========================================================================
FLbox                                                                 *FLbox*

  Description

A FLTK widget that displays text inside of a box.

  Syntax

ihandle FLbox "label", itype, ifont, isize, iwidth, iheight, ix, iy [, image]


===========================================================================
FLbutBank                                                         *FLbutBank*

  Description

A FLTK widget opcode that creates a bank of buttons.

  Syntax

kout, ihandle FLbutBank itype, inumx, inumy, iwidth, iheight, ix, iy, \
      iopcode [, kp1] [, kp2] [, kp3] [, kp4] [, kp5] [....] [, kpN]


===========================================================================
FLbutton                                                           *FLbutton*

  Description

A FLTK widget opcode that creates a button.

  Syntax

kout, ihandle FLbutton "label", ion, ioff, itype, iwidth, iheight, ix, \
      iy, iopcode [, kp1] [, kp2] [, kp3] [, kp4] [, kp5] [....] [, kpN]


===========================================================================
FLcloseButton                                                 *FLcloseButton*

  Description

A FLTK widget opcode that creates a button that will close the panel
window it is a part of.

  Syntax

ihandle FLcloseButton "label", iwidth, iheight, ix, iy


===========================================================================
FLcolor                                                             *FLcolor*

  Description

Sets the primary colors to RGB values given by the user.

  Syntax

FLcolor ired, igreen, iblue [, ired2, igreen2, iblue2]


===========================================================================
FLcolor2                                                           *FLcolor2*

  Description

FLcolor2 is the same of FLcolor except it affects the secondary
(selection) color.

  Syntax

FLcolor2 ired, igreen, iblue


===========================================================================
FLcount                                                             *FLcount*

  Description

Allows the user to increase/decrease a value with mouse clicks on a
corresponding arrow button.

  Syntax

kout, ihandle FLcount "label", imin, imax, istep1, istep2, itype, \
      iwidth, iheight, ix, iy, iopcode [, kp1] [, kp2] [, kp3] [...] [, kpN]


===========================================================================
FLexecButton                                                   *FLexecButton*

  Description

A FLTK widget opcode that creates a button that executes a command.
Useful for opening up HTML documentation as About text or to start a
separate program from an FLTK widget interface.

  Warning

Because any command can be executed, the user is advised to be very
careful when using this opcode and when running orchestras by others
using this opcode.

  Syntax

ihandle FLexecButton "command", iwidth, iheight, ix, iy


===========================================================================
FLgetsnap                                                         *FLgetsnap*

  Description

Retrieves a previously stored snapshot (in memory), i.e. sets all
valuator to the corresponding values stored in that snaphot.

  Syntax

inumsnap FLgetsnap index [, igroup]


===========================================================================
FLgroup                                                             *FLgroup*

  Description

A FLTK container opcode that groups child widgets.

  Syntax

FLgroup "label", iwidth, iheight, ix, iy [, iborder] [, image]


===========================================================================
FLgroupEnd                                                       *FLgroupEnd*

  Description

Marks the end of a group of FLTK child widgets.

  Syntax

FLgroupEnd


===========================================================================
FLgroup_end                                                     *FLgroup_end*

  Description

Marks the end of a group of FLTK child widgets. This is another name for
FLgroupEnd provides for compatibility. See FLgroupEnd


===========================================================================
FLhide                                                               *FLhide*

  Description

Hides the target FLTK widget, making it invisible.

  Syntax

FLhide ihandle


===========================================================================
FLhvsBox                                                           *FLhvsBox*

  Description

FLhvsBox displays a box with a grid useful for visualizing
two-dimensional Hyper Vectorial Synthesis.

  Syntax

ihandle FLhvsBox inumlinesX, inumlinesY, iwidth, iheight, ix, iy


===========================================================================
FLhvsBoxSetValue                                           *FLhvsBoxSetValue*

  Description

FLhvsBoxSetValue sets the cursor position of a previously-declared
FLhvsBox widget.

  Syntax

FLhvsBox kx, ky, ihandle


===========================================================================
FLjoy                                                                 *FLjoy*

  Description

FLjoy is a squared area that allows the user to modify two output values
at the same time. It acts like a joystick.

  Syntax

koutx, kouty, ihandlex, ihandley FLjoy "label", iminx, imaxx, iminy, \
      imaxy, iexpx, iexpy, idispx, idispy, iwidth, iheight, ix, iy


===========================================================================
FLkeyIn                                                             *FLkeyIn*

  Description

FLkeyIn informs about the status of a key pressed by the user on the
alphanumeric keyboard when an FLTK panel has got the focus.

  Syntax

kascii FLkeyIn [ifn]


===========================================================================
FLknob                                                               *FLknob*

  Description

A FLTK widget opcode that creates a knob.

  Syntax

kout, ihandle FLknob "label", imin, imax, iexp, itype, idisp, iwidth, \
      ix, iy [, icursorsize]


===========================================================================
FLlabel                                                             *FLlabel*

  Description

Modifies a set of parameters related to the text label appearence of a
widget (i.e. size, font, alignment and color of corresponding text).

  Syntax

FLlabel isize, ifont, ialign, ired, igreen, iblue


===========================================================================
FLloadsnap                                                       *FLloadsnap*

  Description

FLloadsnap loads all the snapshots contained in a file into the memory
bank of the current orchestra.

  Syntax

FLloadsnap "filename" [, igroup]


===========================================================================
FLmouse                                                             *FLmouse*

  Description

FLmouse returns the coordinates of the mouse position within an FLTK
panel and the state of the three mouse buttons.

  Syntax

kx, ky, kb1, kb2, kb3 FLmouse [imode]


===========================================================================
flooper                                                             *flooper*

  Description

This opcode reads audio from a function table and plays it back in a
loop with user-defined start time, duration and crossfade time. It also
allows the pitch of the loop to be controlled, including reversed
playback. It accepts non-power-of-two tables, such as
deferred-allocation GEN01 tables, with one or two channels.

  Syntax

asig1[, asig2] flooper kamp, kpitch, istart, idur, ifad, ifn


===========================================================================
flooper2                                                           *flooper2*

  Description

This opcode implements a crossfading looper with variable loop
parameters and three looping modes, optionally using a table for its
crossfade shape. It accepts non-power-of-two tables for its source
sounds, such as deferred-allocation GEN01 tables, with one or two channels.

  Syntax

asig1[,asig2] flooper2 kamp, kpitch, kloopstart, kloopend, kcrossfade, ifn \
      [, istart, imode, ifenv, iskip]


===========================================================================
floor                                                                 *floor*

  Description

Returns the largest integer not greater than x

  Syntax

floor(x) (init-, control-, or audio-rate arg allowed)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
FLpack                                                               *FLpack*

  Description

FLpack provides the functionality of compressing and aligning widgets.

  Syntax

FLpack iwidth, iheight, ix, iy, itype, ispace, iborder


===========================================================================
FLpackEnd                                                         *FLpackEnd*

  Description

Marks the end of a group of compressed or aligned FLTK widgets.

  Syntax

FLpackEnd


===========================================================================
FLpack_end                                                       *FLpack_end*

  Description

Marks the end of a group of compressed or aligned FLTK widgets. This is
another name for FLpackEnd provided for compatibility. See FLpackEnd


===========================================================================
FLpanel                                                             *FLpanel*

  Description

Creates a window that contains FLTK widgets.

  Syntax

FLpanel "label", iwidth, iheight [, ix] [, iy] [, iborder] [, ikbdcapture] [, iclose]


===========================================================================
FLpanelEnd                                                       *FLpanelEnd*

  Description

Marks the end of a group of FLTK widgets contained inside of a window
(panel).

  Syntax

FLpanelEnd


===========================================================================
FLpanel_end                                                     *FLpanel_end*

  Description

Marks the end of a group of FLTK widgets contained inside of a window
(panel). This is another name for FLpanelEnd provided for compatibility.
See FLpanelEnd


===========================================================================
FLprintk                                                           *FLprintk*

  Description

FLprintk is similar to printk but shows values of a k-rate signal in a
text field instead of on the console.

  Syntax

FLprintk itime, kval, idisp


===========================================================================
FLprintk2                                                         *FLprintk2*

  Description

FLprintk2 is similar to FLprintk but shows a k-rate variable's value
only when it changes.

  Syntax

FLprintk2 kval, idisp


===========================================================================
FLroller                                                           *FLroller*

  Description

FLroller is a sort of knob, but put transversally.

  Syntax

kout, ihandle FLroller "label", imin, imax, istep, iexp, itype, idisp, \
      iwidth, iheight, ix, iy


===========================================================================
FLrun                                                                 *FLrun*

  Description

Starts the FLTK widget thread.

  Syntax

FLrun


===========================================================================
FLsavesnap                                                       *FLsavesnap*

  Description

FLsavesnap saves all snapshots currently created (i.e. the entire memory
bank) into a file.

  Syntax

FLsavesnap "filename" [, igroup]


===========================================================================
FLscroll                                                           *FLscroll*

  Description

FLscroll adds scroll bars to an area.

  Syntax

FLscroll iwidth, iheight [, ix] [, iy]


===========================================================================
FLscrollEnd                                                     *FLscrollEnd*

  Description

A FLTK opcode that marks the end of an area with scrollbars.

  Syntax

FLscrollEnd


===========================================================================
FLscroll_end                                                   *FLscroll_end*

  Description

A FLTK opcode that marks the end of an area with scrollbars. This is
another name for FLscrollEnd provided for compatibility. See FLscrollEnd


===========================================================================
FLsetAlign                                                       *FLsetAlign*

  Description

FLsetAlign sets the text alignment of the label of the target widget.

  Syntax

FLsetAlign ialign, ihandle


===========================================================================
FLsetBox                                                           *FLsetBox*

  Description

FLsetBox sets the appearance of a box surrounding the target widget.

  Syntax

FLsetBox itype, ihandle


===========================================================================
FLsetColor                                                       *FLsetColor*

  Description

FLsetColor sets the primary color of the target widget.

  Syntax

FLsetColor ired, igreen, iblue, ihandle


===========================================================================
FLsetColor2                                                     *FLsetColor2*

  Description

FLsetColor2 sets the secondary (or selection) color of the target widget.

  Syntax

FLsetColor2 ired, igreen, iblue, ihandle


===========================================================================
FLsetFont                                                         *FLsetFont*

  Description

FLsetFont sets the font type of the target widget.

  Syntax

FLsetFont ifont, ihandle


===========================================================================
FLsetPosition                                                 *FLsetPosition*

  Description

FLsetPosition sets the position of the target widget according to the ix
and iy arguments.

  Syntax

FLsetPosition ix, iy, ihandle


===========================================================================
FLsetSize                                                         *FLsetSize*

  Description

FLsetSize resizes the target widget (not the size of its text) according
to the iwidth and iheight arguments.

  Syntax

FLsetSize iwidth, iheight, ihandle


===========================================================================
FLsetsnap                                                         *FLsetsnap*

  Description

FLsetsnap stores the current status of all valuators present in the
orchestra into a snapshot location (in memory).

  Syntax

inumsnap, inumval FLsetsnap index [, ifn, igroup]


===========================================================================
FLsetSnapGroup                                               *FLsetSnapGroup*

  Description

FLsetSnapGroup determines the snapshot group of valuators declared after
it.

  Syntax

FLsetSnapGroup igroup


===========================================================================
FLsetText                                                         *FLsetText*

  Description

FLsetText sets the label of the target widget to the double-quoted text
string provided with the itext argument.

  Syntax

FLsetText "itext", ihandle


===========================================================================
FLsetTextColor                                               *FLsetTextColor*

  Description

FLsetTextColor sets the color of the text label of the target widget.

  Syntax

FLsetTextColor ired, iblue, igreen, ihandle


===========================================================================
FLsetTextSize                                                 *FLsetTextSize*

  Description

FLsetTextSize sets the size of the text label of the target widget.

  Syntax

FLsetTextSize isize, ihandle


===========================================================================
FLsetTextType                                                 *FLsetTextType*

  Description

FLsetTextType sets some attributes related to the fonts of the text
label of the target widget.

  Syntax

FLsetTextType itype, ihandle


===========================================================================
FLsetVal_i                                                       *FLsetVal_i*

  Description

FLsetVal_i forces the value of a valuator to a number provided by the user.

  Syntax

FLsetVal_i ivalue, ihandle


===========================================================================
FLsetVal                                                           *FLsetVal*

  Description

FLsetVal is almost identical to FLsetVal_i. Except it operates at k-rate
and it affects the target valuator only when ktrig is set to a non-zero
value.

  Syntax

FLsetVal ktrig, kvalue, ihandle


===========================================================================
FLshow                                                               *FLshow*

  Description

FLshow restores the visibility of a previously hidden widget.

  Syntax

FLshow ihandle


===========================================================================
FLslidBnk                                                         *FLslidBnk*

  Description

FLslidBnk is a widget containing a bank of horizontal sliders.

  Syntax

FLslidBnk "names", inumsliders [, ioutable] [, iwidth] [, iheight] [, ix] \
      [, iy] [, itypetable] [, iexptable] [, istart_index] [, iminmaxtable]


===========================================================================
FLslidBnk2                                                       *FLslidBnk2*

  Description

FLslidBnk2 is a widget containing a bank of horizontal sliders.

  Syntax

FLslidBnk2 "names", inumsliders, ioutable, iconfigtable [,iwidth, iheight, ix, iy, istart_index] 


===========================================================================
FLslidBnkGetHandle                                       *FLslidBnkGetHandle*

  Description

FLslidBnkGetHandle gets the handle of last slider bank created.

  Syntax

ihandle FLslidBnkGetHandle


===========================================================================
FLslidBnkSet                                                   *FLslidBnkSet*

  Description

FLslidBnkSet modifies the values of a slider bank according to an array
of values stored in a table.

  Syntax

FLslidBnkSet ihandle, ifn [, istartIndex, istartSlid, inumSlid]


===========================================================================
FLslidBnkSetk                                                 *FLslidBnkSetk*

  Description

FLslidBnkSetk modifies the values of a slider bank according to an array
of values stored in a table.

  Syntax

FLslidBnkSetk  ktrig, ihandle, ifn [, istartIndex, istartSlid, inumSlid]


===========================================================================
FLslidBnk2Set                                                 *FLslidBnk2Set*

  Description

FLslidBnk2Set modifies the values of a slider bank according to an array
of values stored in a table.

  Syntax

FLslidBnk2Set ihandle, ifn [, istartIndex, istartSlid, inumSlid]


===========================================================================
FLslidBnk2Setk                                               *FLslidBnk2Setk*

  Description

FLslidBnk2Setk modifies the values of a slider bank according to an
array of values stored in a table.

  Syntax

FLslidBnk2Setk  ktrig, ihandle, ifn [, istartIndex, istartSlid, inumSlid]


===========================================================================
FLslider                                                           *FLslider*

  Description

FLslider puts a slider into the corresponding container.

  Syntax

kout, ihandle FLslider "label", imin, imax, iexp, itype, idisp, iwidth, \
      iheight, ix, iy


===========================================================================
FLtabs                                                               *FLtabs*

  Description

FLtabs is a “file card tabs” interface that is useful to display several
areas containing widgets in the same windows, alternatively. It must be
used together with FLgroup, another container that groups child widgets.

  Syntax

FLtabs iwidth, iheight, ix, iy


===========================================================================
FLtabsEnd                                                         *FLtabsEnd*

  Description

Marks the end of a tabbed FLTK interface.

  Syntax

FLtabsEnd


===========================================================================
FLtabs_end                                                       *FLtabs_end*

  Description

Marks the end of a tabbed FLTK interface. This is another name for
FLtabsEnd provided for compatibility. See FLtabsEnd


===========================================================================
FLtext                                                               *FLtext*

  Description

FLtext allows the user to modify a parameter value by directly typing it
into a text field.

  Syntax

kout, ihandle FLtext "label", imin, imax, istep, itype, iwidth, \
      iheight, ix, iy


===========================================================================
FLupdate                                                           *FLupdate*

  Description

Same as the FLrun opcode.

  Syntax

FLupdate

===========================================================================
fluidAllOut                                                     *fluidAllOut*

  Syntax

aleft, aright fluidAllOut

  Description

Collects all audio from all Fluidsynth engines in a performance


===========================================================================
fluidCCi                                                           *fluidCCi*

  Syntax

fluidCCi iEngineNumber, iChannelNumber, iControllerNumber, iValue

  Description

Sends a MIDI controller data (MIDI controller number and value to use)
message to a fluid engine by number on the user specified MIDI channel
number.


===========================================================================
fluidCCk                                                           *fluidCCk*

  Syntax

fluidCCk iEngineNumber, iChannelNumber, iControllerNumber, kValue

  Description

Sends a MIDI controller data (MIDI controller number and value to use)
message to a fluid engine by number on the user specified MIDI channel
number.


===========================================================================
fluidControl                                                   *fluidControl*

  Syntax

fluidControl ienginenum, kstatus, kchannel, kdata1, kdata2

  Description

The fluid opcodes provide a simple Csound opcode wrapper around Peter
Hanappe's Fluidsynth SoundFont2 synthesizer. This implementation accepts
any MIDI note on, note off, controller, pitch bend, or program change
message at k-rate. Maximum polyphony is 4096 simultaneously sounding
voices. Any number of SoundFonts may be loaded and played simultaneously.


===========================================================================
fluidEngine                                                     *fluidEngine*

  Syntax

ienginenum fluidEngine [iReverbEnabled] [, iChorusEnabled] [,iNumChannels] [, iPolyphony] 

  Description

Instantiates a fluidsynth engine, and returns ienginenum to identify the
engine. ienginenum is passed to other other opcodes for loading and
playing SoundFonts and gathering the generated sound.


===========================================================================
fluidLoad                                                         *fluidLoad*

  Syntax

isfnum fluidLoad soundfont, ienginenum[, ilistpresets]

  Description

Loads a SoundFont into an instance of a fluidEngine, optionally listing
banks and presets for SoundFont.


===========================================================================
fluidNote                                                         *fluidNote*

  Syntax

fluidNote ienginenum, ichannelnum, imidikey, imidivel

  Description

Plays a note at imidikey pitch and imidivel velocity on ichannelnum
channel of number ienginenum fluidEngine.


===========================================================================
fluidOut                                                           *fluidOut*

  Syntax

aleft, aright fluidOut ienginenum

  Description

Outputs the sound from a fluidEngine.


===========================================================================
fluidProgramSelect                                       *fluidProgramSelect*

  Syntax

fluidProgramSelect ienginenum, ichannelnum, isfnum, ibanknum, ipresetnum

  Description

Assigns a preset from a SoundFont to a channel on a fluidEngine.


===========================================================================
fluidSetInterpMethod                                   *fluidSetInterpMethod*

  Syntax

fluidSetInterpMethod ienginenum, ichannelnum, iInterpMethod

  Description

Set interpolation method for channel in Fluid Engine. Lower order
interpolation methods will render faster at lower fidelity while higher
order interpolation methods will render slower at higher fidelity.
Default interpolation for a channel is 4th order interpolation.


===========================================================================
FLvalue                                                             *FLvalue*

  Description

FLvalue shows current the value of a valuator in a text field.

  Syntax

ihandle FLvalue "label", iwidth, iheight, ix, iy


===========================================================================
FLvkeybd                                                           *FLvkeybd*

  Description

An FLTK widget opcode that creates a virtual keyboard widget. This must
be used in conjunction with the virtual midi keyboard driver for this to
operate correctly. The purpose of this opcode is for making demo
versions of MIDI orchestras with the virtual keyboard embedded within
the main window.

  Note

The widget version of the virtual keyboard does not include the MIDI
sliders found in the full window version of the virtual keyboard.

  Syntax

FLvkeybd "keyboard.map", iwidth, iheight, ix, iy


===========================================================================
FLvslidBnk                                                       *FLvslidBnk*

  Description

FLvslidBnk is a widget containing a bank of vertical sliders.

  Syntax

FLvslidBnk "names", inumsliders [, ioutable] [, iwidth] [, iheight] [, ix] \
      [, iy] [, itypetable] [, iexptable] [, istart_index] [, iminmaxtable]


===========================================================================
FLvslidBnk2                                                     *FLvslidBnk2*

  Description

FLvslidBnk2 is a widget containing a bank of vertical sliders.

  Syntax

FLvslidBnk2 "names", inumsliders, ioutable, iconfigtable [,iwidth, iheight, ix, iy, istart_index]


===========================================================================
FLxyin                                                               *FLxyin*

  Description

Similar to xyin, sense the mouse cursor position in a user-defined area
inside an FLpanel.

  Syntax

koutx, kouty, kinside  FLxyin ioutx_min, ioutx_max, iouty_min, iouty_max, \
      iwindx_min, iwindx_max, iwindy_min, iwindy_max [, iexpx, iexpy, ioutx, iouty]


===========================================================================
fmb3                                                                   *fmb3*

  Description

Uses FM synthesis to create a Hammond B3 organ sound. It comes from a
family of FM sounds, all using 4 basic oscillators and various
architectures, as used in the TX81Z synthesizer.

  Syntax

ares fmb3 kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, ifn3, \
      ifn4, ivfn]


===========================================================================
fmbell                                                               *fmbell*

  Description

Uses FM synthesis to create a tublar bell sound. It comes from a family
of FM sounds, all using 4 basic oscillators and various architectures,
as used in the TX81Z synthesizer.

  Syntax

ares fmbell kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, ifn3, \
      ifn4, ivfn, isus]


===========================================================================
fmmetal                                                             *fmmetal*

  Description

Uses FM synthesis to create a “Heavy Metal” sound. It comes from a
family of FM sounds, all using 4 basic oscillators and various
architectures, as used in the TX81Z synthesizer.

  Syntax

ares fmmetal kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, \
      ifn4, ivfn


===========================================================================
fmpercfl                                                           *fmpercfl*

  Description

Uses FM synthesis to create a percussive flute sound. It comes from a
family of FM sounds, all using 4 basic oscillators and various
architectures, as used in the TX81Z synthesizer.

  Syntax

ares fmpercfl kamp, kfreq, kc1, kc2, kvdepth, kvrate[, ifn1, ifn2, \
      ifn3, ifn4, ivfn]


===========================================================================
fmrhode                                                             *fmrhode*

  Description

Uses FM synthesis to create a Fender Rhodes electric piano sound. It
comes from a family of FM sounds, all using 4 basic oscillators and
various architectures, as used in the TX81Z synthesizer.

  Syntax

ares fmrhode kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, \
      ifn3, ifn4, ivfn


===========================================================================
fmvoice                                                             *fmvoice*

  Description

FM Singing Voice Synthesis

  Syntax

ares fmvoice kamp, kfreq, kvowel, ktilt, kvibamt, kvibrate[, ifn1, \
      ifn2, ifn3, ifn4, ivibfn]


===========================================================================
fmwurlie                                                           *fmwurlie*

  Description

Uses FM synthesis to create a Wurlitzer electric piano sound. It comes
from a family of FM sounds, all using 4 basic oscillators and various
architectures, as used in the TX81Z synthesizer.

  Syntax

ares fmwurlie kamp, kfreq, kc1, kc2, kvdepth, kvrate, ifn1, ifn2, ifn3, \
      ifn4, ivfn


===========================================================================
fof                                                                     *fof*

  Description

Audio output is a succession of sinusoid bursts initiated at frequency
xfund with a spectral peak at xform. For xfund above 25 Hz these bursts
produce a speech-like formant with spectral characteristics determined
by the k-input parameters. For lower fundamentals this generator
provides a special form of granular synthesis.

  Syntax

ares fof xamp, xfund, xform, koct, kband, kris, kdur, kdec, iolaps, \
      ifna, ifnb, itotdur [, iphs] [, ifmode] [, iskip]


===========================================================================
fof2                                                                   *fof2*

  Description

Audio output is a succession of sinusoid bursts initiated at frequency
xfund with a spectral peak at xform. For xfund above 25 Hz these bursts
produce a speech-like formant with spectral characteristics determined
by the k-input parameters. For lower fundamentals this generator
provides a special form of granular synthesis.

fof2 implements k-rate incremental indexing into ifna function with each
successive burst.

  Syntax

ares fof2 xamp, xfund, xform, koct, kband, kris, kdur, kdec, iolaps, \
      ifna, ifnb, itotdur, kphs, kgliss [, iskip]


===========================================================================
fofilter                                                           *fofilter*

  Description

Fofilter generates a stream of overlapping sinewave grains, when fed
with a pulse train. Each grain is the impulse response of a combination
of two BP filters. The grains are defined by their attack time
(determining the skirtwidth of the formant region at -60dB) and decay
time (-6dB bandwidth). Overlapping will occur when 1/freq < decay, but,
unlike FOF, there is no upper limit on the number of overlaps. The
original idea for this opcode came from J McCartney's formlet class in
SuperCollider, but this is possibly implemented differently(?).

  Syntax

asig fofilter ain, xcf, xris, xdec[, istor]


===========================================================================
fog                                                                     *fog*

  Description

Audio output is a succession of grains derived from data in a stored
function table ifna. The local envelope of these grains and their timing
is based on the model of fof synthesis and permits detailed control of
the granular synthesis.

  Syntax

ares fog xamp, xdens, xtrans, aspd, koct, kband, kris, kdur, kdec, \
      iolaps, ifna, ifnb, itotdur [, iphs] [, itmode] [, iskip]


===========================================================================
fold                                                                   *fold*

  Description

Adds artificial foldover to an audio signal.

  Syntax

ares fold asig, kincr


===========================================================================
follow                                                               *follow*

  Description

Envelope follower unit generator.

  Syntax

ares follow asig, idt


===========================================================================
follow2                                                             *follow2*

  Description

A controllable envelope extractor using the algorithm attributed to
Jean-Marc Jot.

  Syntax

ares follow2 asig, katt, krel


===========================================================================
foscil                                                               *foscil*

  Description

A basic frequency modulated oscillator.

  Syntax

ares foscil xamp, kcps, xcar, xmod, kndx, ifn [, iphs]


===========================================================================
foscili                                                             *foscili*

  Description

Basic frequency modulated oscillator with linear interpolation.

  Syntax

ares foscili xamp, kcps, xcar, xmod, kndx, ifn [, iphs]


===========================================================================
fout                                                                   *fout*

  Description

fout outputs N a-rate signals to a specified file of N channels.

  Syntax

fout ifilename, iformat, aout1 [, aout2, aout3,...,aoutN]

fout ifilename, iformat, array[]


===========================================================================
fouti                                                                 *fouti*

  Description

fouti output N i-rate signals to a specified file of N channels.

  Syntax

fouti ihandle, iformat, iflag, iout1 [, iout2, iout3,....,ioutN]


===========================================================================
foutir                                                               *foutir*

  Description

foutir output N i-rate signals to a specified file of N channels.

  Syntax

foutir ihandle, iformat, iflag, iout1 [, iout2, iout3,....,ioutN]


===========================================================================
foutk                                                                 *foutk*

  Description

foutk outputs N k-rate signals to a specified file of N channels.

  Syntax

foutk ifilename, iformat, kout1 [, kout2, kout3,....,koutN]


===========================================================================
fprintks                                                           *fprintks*

  Description

Similar to printks but prints to a file.

  Syntax

fprintks "filename", "string", [, kval1] [, kval2] [...]


===========================================================================
fprints                                                             *fprints*

  Description

Similar to prints but prints to a file.

  Syntax

fprints "filename", "string" [, ival1] [, ival2] [...]


===========================================================================
frac                                                                   *frac*

  Description

Returns the fractional part of x.

  Syntax

frac(x) (init-rate or control-rate args; also works at audio rate in Csound5)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
fractalnoise                                                   *fractalnoise*

  Description

A fractal noise generator implemented as a white noise filtered by a
cascade of 15 first-order filters.

  Syntax

ares fractalnoise kamp, kbeta


===========================================================================
framebuffer                                                     *framebuffer*

  Description

framebuffer converts audio signals into a 1 dimensional k-rate array of
a specified size. The size of the k-rate array must be larger than
ksmps. It also converts 1 dimensional k-rate arrays back into audio
signals, the k-rate arrays must be uninitialised and also be larger than
ksmps in size. The buffer works as a circular buffer and may be used for
doing frame based audio processing such as spectral analysis/synthesis
or as a simple delay line.

  Syntax

kout[] framebuffer ain, isize

aout framebuffer kin, isize


===========================================================================
freeverb                                                           *freeverb*

  Description

freeverb is a stereo reverb unit based on Jezar's public domain C++
sources, composed of eight parallel comb filters on both channels,
followed by four allpass units in series. The filters on the right
channel are slightly detuned compared to the left channel in order to
create a stereo effect.

  Syntax

aoutL, aoutR freeverb ainL, ainR, kRoomSize, kHFDamp[, iSRate[, iSkip]] 


===========================================================================
ftchnls                                                             *ftchnls*

  Description

Returns the number of channels in a stored function table.

  Syntax

ftchnls(x) (init-rate args only)


===========================================================================
ftconv                                                               *ftconv*

  Description

Low latency multichannel convolution, using a function table as impulse
response source. The algorithm is to split the impulse response to
partitions of length determined by the iplen parameter, and delay and
mix partitions so that the original, full length impulse response is
reconstructed without gaps. The output delay (latency) is iplen samples,
and does not depend on the control rate, unlike in the case of other
convolve opcodes.

  Syntax

a1[, a2[, a3[, ... a8]]] ftconv ain, ift, iplen[, iskipsamples \
      [, iirlen[, iskipinit]]]


===========================================================================
ftcps                                                                 *ftcps*

  Description

Returns the base frequency of a stored function table in Hz..

  Syntax

ftcps(x) (init-rate args only)


===========================================================================
ftfree                                                               *ftfree*

  Description

Deletes function table.

  Syntax

ftfree ifno, iwhen


===========================================================================
ftgen                                                                 *ftgen*

  Description

Generate a score function table from within the orchestra.

  Syntax

gir ftgen ifn, itime, isize, igen, iarga [, iargb ] [...]


===========================================================================
ftgenonce                                                         *ftgenonce*

  Description

Enables the creation of function tables entirely inside instrument
definitions, without any duplication of data.

The ftgenonce opcode is designed to simplify writing instrument
definitions that can be re-used in different orchestras simply by
#including them and plugging them into some output instrument. There is
no need to define function tables either in the score, or in the
orchestra header.

The ftgenonce opcode is similar to ftgentmp, and has identical
arguments. However, function tables are neither duplicated nor deleted.
Instead, all of the arguments to the opcode are concatenated to form the
key to a lookup table that points to the function table number. Thus,
every request to ftgenonce with the same arguments receives the same
instance of the function table data. Every change in the value of any
ftgenonce argument causes the creation of a new function table.

  Syntax

ifno ftgenonce ip1, ip2dummy, isize, igen, iarga, iargb, ...


===========================================================================
ftgentmp                                                           *ftgentmp*

  Description

Generate a score function table from within the orchestra, which is
optionally deleted at the end of the note.

  Syntax

ifno ftgentmp ip1, ip2dummy, isize, igen, iarga, iargb, ...


===========================================================================
ftlen                                                                 *ftlen*

  Description

Returns the size of a stored function table.

  Syntax

ftlen(x) (init-rate args only)


===========================================================================
ftload                                                               *ftload*

  Description

Load a set of previously-allocated tables from a file.

  Syntax

ftload "filename", iflag, ifn1 [, ifn2] [...]


===========================================================================
ftloadk                                                             *ftloadk*

  Description

Load a set of previously-allocated tables from a file.

  Syntax

ftloadk "filename", ktrig, iflag, ifn1 [, ifn2] [...]


===========================================================================
ftlptim                                                             *ftlptim*

  Description

Returns the loop segment start-time of a stored function table number.

  Syntax

ftlptim(x) (init-rate args only)


===========================================================================
ftmorf                                                               *ftmorf*

  Description

Uses an index into a table of ftable numbers to morph between adjacent
tables in the list.This morphed function is written into the table
referenced by iresfn on every k-cycle.

  Syntax

ftmorf kftndx, iftfn, iresfn


===========================================================================
ftsamplebank                                                   *ftsamplebank*

  Description

Reads a directory for sound files and loads them to a series of GEN01
function tables.

  Syntax

iNumberOfFile ftsamplebank SDirectory, iFirstTableNumber, iTrigger, iSkipTime, iFormat, iChannel,

kNumberOfFile ftsamplebank SDirectory, kFirstTableNumber, kTrigger, kSkipTime, kFormat, kChannel,


===========================================================================
ftsave                                                               *ftsave*

  Description

Save a set of previously-allocated tables to a file.

  Syntax

ftsave "filename", iflag, ifn1 [, ifn2] [...]


===========================================================================
ftsavek                                                             *ftsavek*

  Description

Save a set of previously-allocated tables to a file.

  Syntax

ftsavek "filename", ktrig, iflag, ifn1 [, ifn2] [...]


===========================================================================
ftsr                                                                   *ftsr*

  Description

Returns the sampling-rate of a stored function table.

  Syntax

ftsr(x) (init-rate args only)


===========================================================================
gain                                                                   *gain*

  Description

Adjusts the amplitude audio signal according to a root-mean-square value.

  Syntax

ares gain asig, krms [, ihp] [, iskip]


===========================================================================
gainslider                                                       *gainslider*

  Description

This opcode is intended for use to multiply by an audio signal to give a
console mixer like feel. There is no bounds in the source code so you
can for example give higher than 127 values for extra amplitude but
possibly clipped audio.

  Syntax

kout gainslider kindex


===========================================================================
gauss                                                                 *gauss*

  Description

Gaussian distribution random number generator. This is an x-class noise
generator.

  Syntax

ares gauss krange

ires gauss krange

kres gauss krange


===========================================================================
gaussi                                                               *gaussi*

  Description

Gaussian distribution random number generator with controlled
interpolation between values. This is an x-class noise generator.

  Syntax

ares gaussi krange, xamp, xcps

ires gaussi krange, xamp, xcps

kres gaussi krange, xamp, xcps


===========================================================================
gausstrig                                                         *gausstrig*

  Description

Generates random impulses around a certain frequency.

  Syntax

ares gausstrig kamp, kcps, kdev [, imode] [, ifrst1]

kres gausstrig kamp, kcps, kdev [, imode] [, ifrst1]


===========================================================================
gbuzz                                                                 *gbuzz*

  Description

Output is a set of harmonically related cosine partials.

  Syntax

ares gbuzz xamp, xcps, knh, klh, kmul, ifn [, iphs]


===========================================================================
genarray                                                           *genarray*

  Description

Generate a vector (one-dimensional k-rate or i-rate array) with an
arithmetic sequence.

  Syntax

karray genarray kstart, kens[, inc]

iarray genarray istart, iens[, inc]


===========================================================================
genarray_i                                                       *genarray_i*

  Description

Generate a vector (one-dimensional k-rate) with an arithmetic sequence
at initialisation time.

  Syntax

karray genarray_i istart, iend [,inc]


===========================================================================
gendy                                                                 *gendy*

  Description

Implementation of the Génération Dynamique Stochastique (GENDYN), a
dynamic stochastic approach to waveform synthesis conceived by Iannis
Xenakis.

  Syntax

ares gendy kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \
           kampscl, kdurscl [, initcps] [, knum]

kres gendy kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \
           kampscl, kdurscl [, initcps] [, knum]


===========================================================================
gendyc                                                               *gendyc*

  Description

Implementation with cubic interpolation of the Génération Dynamique
Stochastique (GENDYN), a dynamic stochastic approach to waveform
synthesis conceived by Iannis Xenakis.

  Syntax

ares gendyc kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \
            kampscl, kdurscl [, initcps] [, knum]

kres gendyc kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \
            kampscl, kdurscl [, initcps] [, knum]


===========================================================================
gendyx                                                               *gendyx*

  Description

gendyx (gendy eXtended) is an implementation of the Génération Dynamique
Stochastique (GENDYN), a dynamic stochastic approach to waveform
synthesis conceived by Iannis Xenakis, using curves instead of segments.

  Syntax

ares gendyx kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \
            kampscl, kdurscl, kcurveup, kcurvedown [, initcps] [, knum]

kres gendyx kamp, kampdist, kdurdist, kadpar, kddpar, kminfreq, kmaxfreq, \
            kampscl, kdurscl, kcurveup, kcurvedown [, initcps] [, knum]


===========================================================================
getcfg                                                               *getcfg*

  Description

Return various configuration settings in Svalue as a string at init time.

  Syntax

Svalue getcfg iopt


===========================================================================
getrow                                                               *getrow*

  Description

Gets a given row from a 2-dimensional array. The output is an 1-d array
with the contents of the requested row

  Syntax

kout[] getrowkin[],krow


===========================================================================
getseed                                                             *getseed*

  Description

Returns the global seed value used for all x-class noise generators.

  Syntax

ians getseed

kans getseed


===========================================================================
gogobel                                                             *gogobel*

  Description

Audio output is a tone related to the striking of a cow bell or similar.
The method is a physical model developed from Perry Cook, but re-coded
for Csound.

  Syntax

ares gogobel kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivfn


===========================================================================
goto                                                                   *goto*

  Description

Transfer control to label on every pass. (Combination of igoto and kgoto)

  Syntax

goto label

where label is in the same instrument block and is not an expression.

  Note
Using goto not as part of an if statement (as in: goto end), will cause
initialization to be skipped on all the code the goto jumps over. In
performance, leaving some opcodes uninitialized will cause deletion of
the note/event. In these cases, using kgoto (as in: kgoto end) might be
preferred."


===========================================================================
grain                                                                 *grain*

  Description

Generates granular synthesis textures.

  Syntax

ares grain xamp, xpitch, xdens, kampoff, kpitchoff, kgdur, igfn, \
      iwfn, imgdur [, igrnd]


===========================================================================
grain2                                                               *grain2*

  Description

Generate granular synthesis textures. grain2 is simpler to use, but
grain3 offers more control.

  Syntax

ares grain2 kcps, kfmd, kgdur, iovrlp, kfn, iwfn [, irpow] \
      [, iseed] [, imode]


===========================================================================
grain3                                                               *grain3*

  Description

Generate granular synthesis textures. grain2 is simpler to use but
grain3 offers more control.

  Syntax

ares grain3 kcps, kphs, kfmd, kpmd, kgdur, kdens, imaxovr, kfn, iwfn, \
      kfrpow, kprpow [, iseed] [, imode]


===========================================================================
granule                                                             *granule*

  Description

The granule unit generator is more complex than grain, but does add new
possibilities.

granule is a Csound unit generator which employs a wavetable as input to
produce granularly synthesized audio output. Wavetable data may be
generated by any of the GEN subroutines such as GEN01 which reads an
audio data file into a wavetable. This enable a sampled sound to be used
as the source for the grains. Up to 128 voices are implemented
internally. The maximum number of voices can be increased by redefining
the variable MAXVOICE in the grain4.h file. granule has a build-in
random number generator to handle all the random offset parameters.
Thresholding is also implemented to scan the source function table at
initialization stage. This facilitates features such as skipping silence
passage between sentences.

The characteristics of the synthesis are controlled by 22 parameters.
xamp is the amplitude of the output and it can be either audio rate or
control rate variable.

  Syntax

ares granule xamp, ivoice, iratio, imode, ithd, ifn, ipshift, igskip, \
      igskip_os, ilength, kgap, igap_os, kgsize, igsize_os, iatt, idec \
      [, iseed] [, ipitch1] [, ipitch2] [, ipitch3] [, ipitch4] [, ifnenv]


===========================================================================
guiro                                                                 *guiro*

  Description

guiro is a semi-physical model of a guiro sound. It is one of the PhISEM
percussion opcodes. PhISEM (Physically Informed Stochastic Event
Modeling) is an algorithmic approach for simulating collisions of
multiple independent sound producing objects.

  Syntax

ares guiro kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] [, ifreq1]


===========================================================================
harmon                                                               *harmon*

  Description

Analyze an audio input and generate harmonizing voices in synchrony.

  Syntax

ares harmon asig, kestfrq, kmaxvar, kgenfreq1, kgenfreq2, imode, \
      iminfrq, iprd


===========================================================================
harmon2                                                             *harmon2*

  Description

Generate harmonizing voices with formants preserved.

  Syntax

ares harmon2 asig, koct, kfrq1, kfrq2, icpsmode, ilowest[, ipolarity]

ares harmon3 asig, koct, kfrq1, \
    kfrq2, kfrq3, icpsmode, ilowest[, ipolarity]

ares harmon4 asig, koct, kfrq1, \
    kfrq2, kfrq3, kfrq4, icpsmode, ilowest[, ipolarity]


===========================================================================
hdf5read                                                           *hdf5read*

  Description

hdf5read reads N signals and arrays from a specified hdf5 file.

  Syntax

xout1[, xout2, xout3, ..., xoutN] hdf5read ifilename, ivariablename1[, ivariablename2, ivariablename3, ..., ivariablenameN]


===========================================================================
hdf5write                                                         *hdf5write*

  Description

hdf5write writes N signals and arrays to a specified hdf5 file.

  Syntax

hdf5write ifilename, xout1[, xout2, xout3, ..., xoutN]


===========================================================================
hilbert                                                             *hilbert*

  Description

An IIR implementation of a Hilbert transformer.

  Syntax

ar1, ar2 hilbert asig


===========================================================================
hrtfearly                                                         *hrtfearly*

  Description

This opcode essentially nests the hrtfmove opcode in an image model for
a user-definable shoebox-shaped room. A default room can be selected, or
advanced room parameters can be used. Room surfaces can be controlled
with high and low-frequency absorption coefficients and gain factors of
a three-band equaliser.

Although valid as a stand alone opcode, hrtfearly is designed to work
with hrtfreverb to provide spatially accurate, dynamic binaural
reverberation. A number of sources can be processed dynamically using a
number of hrtfearly instances. All can then be processed with one
instance of hrtfreverb.

  Syntax

aleft, aright, irt60low, irt60high, imfp hrtfearly asrc, ksrcx, ksrcy, ksrcz, klstnrx, klstnry, klstnrz, \
      ifilel, ifiler, idefroom [,ifade, isr, iorder, ithreed, kheadrot, iroomx, iroomy, iroomz, iwallhigh, \
      iwalllow, iwallgain1, iwallgain2, iwallgain3, ifloorhigh, ifloorlow, ifloorgain1, ifloorgain2, \
      ifloorgain3, iceilinghigh, iceilinglow, iceilinggain1, iceilinggain2, iceilinggain3]


===========================================================================
hrtfmove                                                           *hrtfmove*

  Description

This opcode takes a source signal and spatialises it in the 3
dimensional space around a listener by convolving the source with stored
head related transfer function (HRTF) based filters.

  Syntax

aleft, aright hrtfmove asrc, kAz, kElev, ifilel, ifiler [, imode, ifade, isr]


===========================================================================
hrtfmove2                                                         *hrtfmove2*

  Description

This opcode takes a source signal and spatialises it in the 3
dimensional space around a listener using head related transfer function
(HRTF) based filters.

  Syntax

aleft, aright hrtfmove2 asrc, kAz, kElev, ifilel, ifiler [,ioverlap, iradius, isr]


===========================================================================
hrtfreverb                                                       *hrtfreverb*

  Description

A frequency-dependent, efficient reverberant field is created based on
low and high frequency desired reverb times. The opcode is designed to
work with hrtfearly, ideally using its outputs as inputs. However,
hrtfreverb can be used as a standalone tool. Stability is enforced.

It is, however, designed for use with hrtfearly to provide spatially
accurate reverberation with user definable source trajectories. Accurate
interaural coherence is also provided.

  Syntax

aleft, aright, idel hrtfreverb asrc, ilowrt60, ihighrt60, ifilel, ifiler [,isr, imfp, iorder]


===========================================================================
hrtfstat                                                           *hrtfstat*

  Description

This opcode takes a source signal and spatialises it in the 3
dimensional space around a listener using head related transfer function
(HRTF) based filters. It produces a static output (azimuth and elevation
parameters are i-rate), because a static source allows much more
efficient processing than hrtfmove and hrtfmove2,.

  Syntax

      aleft, aright hrtfstat asrc, iAz, iElev, ifilel, ifiler [,iradius, isr]


===========================================================================
hsboscil                                                           *hsboscil*

  Description

An oscillator which takes tonality and brightness as arguments, relative
to a base frequency.

  Syntax

ares hsboscil kamp, ktone, kbrite, ibasfreq, iwfn, ioctfn \
               [, ioctcnt] [, iphs]


===========================================================================
hvs1                                                                   *hvs1*

  Description

hvs1 allows one-dimensional Hyper Vectorial Synthesis (HVS) controlled
by externally-updated k-variables.

  Syntax

hvs1 kx, inumParms, inumPointsX, iOutTab, iPositionsTab, iSnapTab [, iConfigTab]


===========================================================================
hvs2                                                                   *hvs2*

  Description

hvs2 allows two-dimensional Hyper Vectorial Synthesis (HVS) controlled
by externally-updated k-variables.

  Syntax

hvs2 kx, ky, inumParms, inumPointsX, inumPointsY, iOutTab, iPositionsTab, iSnapTab [, iConfigTab]


===========================================================================
hvs3                                                                   *hvs3*

  Description

hvs3 allows three-dimensional Hyper Vectorial Synthesis (HVS) controlled
by externally-updated k-variables.

  Syntax

hvs3 kx, ky, kz, inumParms, inumPointsX, inumPointsY, inumPointsZ, iOutTab, iPositionsTab, iSnapTab [, iConfigTab]


===========================================================================
i                                                                         *i*

  Description

Returns an init-type equivalent of a k-rate argument, or directly
returns an i-rate argument.

  Syntax

i(x) (control-rate or init-rate arg)

Value converters perform arithmetic translation from units of one kind
to units of another. The result can then be a term in a further expression.

  Note

Using i() with a k-rate expression argument is not recommended, and can
produce unexpected results.


===========================================================================
if                                                                       *if*

  Description

if...igoto -- conditional branch at initialization time, depending on
the truth value of the logical expression ia R ib. The branch is taken
only if the result is true.

if...kgoto -- conditional branch during performance time, depending on
the truth value of the logical expression ka R kb. The branch is taken
only if the result is true.

if...goto -- combination of the above. Condition tested on every pass.

if...then -- allows the ability to specify conditional if/else/endif
blocks. All if...then blocks must end with an endif statement. elseif
and else statements are optional. Any number of elseif statements are
allowed. Only one else statement may occur and it must be the last
conditional statement before the endif statement. Nested if...then
blocks are allowed.

  Note

Note that if the condition uses a k-rate variable (for instance, “if
kval > 0”), the if...goto or if...then statement will be ignored during
the i-time pass. This allows for opcode initialization, even if the
k-rate variable has already been assigned an appropriate value by an
earlier init statement.

  Syntax

if ia R ib igoto label

if ka R kb kgoto label

if xa R xb goto label

if xa R xb then

where label is in the same instrument block and is not an expression,
and where R is one of the Relational operators (<, =, <=, ==, !=) (and =
for convenience, see also under Conditional Values).

If goto or then is used instead of kgoto or igoto, the behavior is
determined by the type being compared. If the comparison used k-type
variables, kgoto is used and viceversa.

  Note

If/then/goto statements cannot do audio-type comparisons. You can't put
a-type variables in the comparison expressions for these opcodes. The
reason for this is that audio variables are actually vectors, which
can't be compared in the same way as scalars. If you need to compare
individua audio samples, use kr = 1 or Comparators


===========================================================================
fftinv                                                               *fftinv*

  Description

Applies an Inverse Fast Fourier Transform to a complex-value input
1-dimensional array producing a complex-valued output. The output is
another array containing the complex-valued signal, and both arrays are
arranged in interleaved real-imaginary format. The output array will
have the same size as the input, and the transform size will be
equivalent to half of the length of the array. Non-power-of-two
transforms are limited to even sizes with not too many factors.

  Syntax

kout[] fftinv kin[]


===========================================================================
igoto                                                                 *igoto*

  Description

During the i-time pass only, unconditionally transfer control to the
statement labeled by label.

  Syntax

igoto label

where label is in the same instrument block and is not an expression.


===========================================================================
ihold                                                                 *ihold*

  Description

Causes a finite-duration note to become a “held” note

  Syntax

ihold


===========================================================================
imagecreate                                                     *imagecreate*

  Description

Create an empty image of a given size. Individual pixel values can then
be set with. imagegetpixel.

  Syntax

iimagenum imagecreate iwidth, iheight


===========================================================================
imagefree                                                         *imagefree*

  Description

Frees memory allocated for a previously loaded or created image.

  Syntax

imagefree iimagenum


===========================================================================
imagegetpixel                                                 *imagegetpixel*

  Description

Return the RGB pixel values of a previously opened or created image. An
image can be loaded with imageload. An empty image can be created with
imagecreate.

  Syntax

ared, agreen, ablue imagegetpixel iimagenum, ax, ay

kred, kgreen, kblue imagegetpixel iimagenum, kx, ky


===========================================================================
imageload                                                         *imageload*

  Description

Load an image and return a reference to it. Individual pixel values can
then be accessed with imagegetpixel.

  Note

The image processing opcodes can only load png images

  Syntax

iimagenum imageload filename


===========================================================================
imagesave                                                         *imagesave*

  Description

Save a previously created image. An empty image can be created with
imagecreate and its pixel RGB values can be set with imagesetpixel. The
image will be saved in PNG format.

  Syntax

imagesave iimagenum, filename


===========================================================================
imagesetpixel                                                 *imagesetpixel*

  Description

Set the RGB value of a pixel inside a previously opened or created
image. An image can be loaded with imageload. An empty image can be
created with imagecreate and saved with imagesave.

  Syntax

imagesetpixel iimagenum, ax, ay, ared, agreen, ablue

imagesetpixel iimagenum, kx, ky, kred, kgreen, kblue


===========================================================================
imagesize                                                         *imagesize*

  Description

Return the width and height of a previously opened or created image. An
image can be loaded with imageload. An empty image can be created with
imagecreate.

  Syntax

iwidth, iheight imagesize iimagenum


===========================================================================
in                                                                       *in*

  Description

Reads audio data from an external device or stream.

  Warning

There are two versions of this opcode. The first is designed to be used
only with orchestras that have inchnls=1. Doing so with orchestras with
inchnls > 1 will cause incorrect audio input.

The second form will read multiple channels into an array.

  Syntax

ar1 in

aarray in


===========================================================================
in32                                                                   *in32*

  Description

Reads a 32-channel audio signal from an external device or stream.

  Warning

This opcode is designed to be used only with orchestras that have
nchnls_i=32. Doing so with orchestras with nchnls_i > 32 will cause
incorrect audio input.

  Syntax

ar1, ar2, ar3, ar4, ar5, ar6, ar7, ar8, ar9, ar10, ar11, ar12, ar13, ar14, \
      ar15, ar16, ar17, ar18, ar19, ar20, ar21, ar22, ar23, ar24, ar25, ar26, \
      ar27, ar28, ar29, ar30, ar31, ar32 in32


===========================================================================
inch                                                                   *inch*

  Description

Reads from numbered channels in an external audio signal or stream.

  Syntax

ain1[, ...] inch kchan1[,...]


===========================================================================
inh                                                                     *inh*

  Description

Reads six-channel audio data from an external device or stream.

  Warning

This opcode is designed to be used only with orchestras that have
nchnls_i=6. Doing so with orchestras with nchnls_i > 6 will cause
incorrect audio input.

  Syntax

ar1, ar2, ar3, ar4, ar5, ar6 inh


===========================================================================
init                                                                   *init*

  Syntax

ares init iarg

ires init iarg

kres init iarg

ares, ...  init iarg, ...

ires, ... init iarg, ...

kres, ... init iarg, ...

tab init isize[, ival]

  Description

Put the value of the i-time expression into a k- or a-rate variable.


===========================================================================
initc14                                                             *initc14*

  Description

Initializes the controllers used to create a 14-bit MIDI value.

  Syntax

initc14 ichan, ictlno1, ictlno2, ivalue


===========================================================================
initc21                                                             *initc21*

  Description

Initializes the controllers used to create a 21-bit MIDI value.

  Syntax

initc21 ichan, ictlno1, ictlno2, ictlno3, ivalue


===========================================================================
initc7                                                               *initc7*

  Description

Initializes MIDI controller ictlno with ivalue

  Syntax

initc7 ichan, ictlno, ivalue


===========================================================================
inleta                                                               *inleta*

  Description

Receives an arate signal into an instrument through a named port.

  Syntax

asignal inleta Sname


===========================================================================
inletk                                                               *inletk*

  Description

Receives a krate signal into an instrument from a named port.

  Syntax

ksignal inletk Sname


===========================================================================
inletkid                                                           *inletkid*

  Description

Receives a krate signal into an instrument from a named port.

  Syntax

ksignal inletkid Sname, SinstanceID


===========================================================================
inletf                                                               *inletf*

  Description

Receives an frate signal (fsig) into an instrument from a named port.

  Syntax

fsignal inletf Sname


===========================================================================
inletv                                                               *inletv*

  Description

Receives an arate array signal into an instrument through a named port.

  Syntax

array inletv Sname


===========================================================================
ino                                                                     *ino*

  Description

Reads eight-channel audio data from an external device or stream.

  Warning

This opcode is designed to be used only with orchestras that have
nchnls_i=8. Doing so with orchestras with nchnls_i > 8 will cause
incorrect audio input.

  Syntax

ar1, ar2, ar3, ar4, ar5, ar6, ar7, ar8 ino


===========================================================================
inq                                                                     *inq*

  Description

Reads quad audio data from an external device or stream.

  Warning

This opcode is designed to be used only with orchestras that have
nchnls_i=4. Doing so with orchestras with nchnls_i > 4 will cause
incorrect audio input.

  Syntax

ar1, ar2,  ar3, a4 inq


===========================================================================
inrg                                                                   *inrg*

  Description

inrg reads audio from a range of adjacent audio channels from the audio
input device.

  Syntax

inrg kstart, ain1 [,ain2, ain3, ..., ainN]


===========================================================================
ins                                                                     *ins*

  Description

Reads stereo audio data from an external device or stream.

  Warning

This opcode is designed to be used only with orchestras that have
nchnls_i=2. Doing so with orchestras with nchnls_i > 2 will cause
incorrect audio input.

  Syntax

ar1, ar2 ins


===========================================================================
insremot                                                           *insremot*

  Description

With the insremot and insglobal opcodes you are able to perform
instruments on remote machines and control them from a master machine.
The remote opcodes are implemented using the master/client model. All
the machines involved contain the same orchestra but only the master
machine contains the information of the score. During the performance
the master machine sends the note events to the clients. The insremot
opcode will send events from a source machine to one destination if you
want to send events to many destinations (broadcast) use the insglobal
opcode instead. These two opcodes can be used in combination.

  Syntax

insremot idestination, isource, instrnum [,instrnum...] 


===========================================================================
insglobal                                                         *insglobal*

  Description

With the insremot and insglobal opcodes you are able to perform
instruments on remote machines and control them from a master machine.
The remote opcodes are implemented using the master/client model. All
the machines involved contain the same orchestra but only the master
machine contains the information of the score. During the performance
the master machine sends the note events to the clients. The insglobal
opcode sends the events to all the machines involved in the remote
concert. These machines are determined by the insremot definitions made
above the insglobal command. To send events to only one machine use
insremot.

  Syntax

insglobal isource, instrnum [,instrnum...] 


===========================================================================
instr                                                                 *instr*

  Description

Starts an instrument block.

  Syntax

instr i, j, ...


===========================================================================
int                                                                     *int*

  Description

Returns the integer part of x.

  Syntax

int(x)  (init-rate or control-rate; also works at audio rate in Csound5)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
integ                                                                 *integ*

  Description

Modify a signal by integration.

  Syntax

ares integ asig [, iskip]

kres integ ksig [, iskip]


===========================================================================
interp                                                               *interp*

  Description

Converts a control signal to an audio signal using linear interpolation.

  Syntax

ares interp ksig [, iskip] [, imode]
    [, ivalue]


===========================================================================
invalue                                                             *invalue*

  Description

Reads a k-rate or i-rate signal or string from a user-defined channel.

  Syntax

ivalue invalue "channel name"

kvalue invalue "channel name"

Sname invalue "channel name"


===========================================================================
inx                                                                     *inx*

  Description

Reads a 16-channel audio signal from an external device or stream.

  Warning

This opcode is designed to be used only with orchestras that have
nchnls=16. Doing so with orchestras with nchnls > 16 will cause
incorrect audio input.

  Syntax

ar1, ar2, ar3, ar4, ar5, ar6, ar7, ar8, ar9, ar10, ar11, ar12, \
      ar13, ar14, ar15, ar16 inx


===========================================================================
inz                                                                     *inz*

  Description

Reads multi-channel audio samples into a ZAK array from an external
device or stream.

  Syntax

inz ksig1


===========================================================================
JackoAudioIn                                                   *JackoAudioIn*

  Description

Receives an audio signal from a Jack audio input port inside this
instance of Csound, which in turn has received the signal from its
connected external Jack audio output port.

  Syntax

asignal JackoAudioIn ScsoundPortName


===========================================================================
JackoAudioInConnect                                     *JackoAudioInConnect*

  Description

In the orchestra header, creates an audio connection from an external
Jack audio output port to a Jack audio input port inside this instance
of Csound.

  Syntax

JackoAudioInConnect SexternalPortName, ScsoundPortName


===========================================================================
JackoAudioOut                                                 *JackoAudioOut*

  Description

Sends an audio signal to an internal Jack audio output port, and in turn
to its connected external Jack audio input port.

Note that it is possible to send audio out via Jack to the system audio
interface, while at the same time rendering to a regular Csound output
soundfile.

  Syntax

JackoAudioOut  ScsoundPortName, asignal


===========================================================================
JackoAudioOutConnect                                   *JackoAudioOutConnect*

  Description

In the orchestra header, creates an audio connection from a Jack audio
output port inside this instance of Csound to an external Jack audio
input port.

  Syntax

JackoAudioOutConnect ScsoundPortName, SexternalPortName


===========================================================================
JackoFreewheel                                               *JackoFreewheel*

  Description

Turns Jack's freewheeling mode on or off.

When freewheeling is on, if supported by the rest of the Jack system,
Csound will run as fast as possible, which may be either faster or
slower than real time.

This is essential for rendering scores that are too dense for real-time
performance to a soundfile, without xruns or dropouts.

  Syntax

JackoFreewheel [ienabled]


===========================================================================
JackoInfo                                                         *JackoInfo*

  Description

Prints the Jack daemon and client names, the sampling rate and frames
per period, and all active Jack port names, types, states, and connections.

  Syntax

JackoInfo 


===========================================================================
JackoInit                                                         *JackoInit*

  Description

Initializes this instance of Csound as a Jack client.

Csound's sr must be equal to the Jack daemon's frames per second.

Csound's ksmps must be equal to the Jack daemon's frames per period.

Frames per period must not only (a) be a power of 2, but also (b) go
evenly into the frames per second, e.g. 128 frames per period goes into
48000 frames per second 375 times, for a latency or MIDI time
granularity of about 2.7 milliseconds (as good as or better than the
absolute best human performers).

The order of processing of all signals that pass from Jack input ports,
through Csound processing, and to Jack output ports, must be properly
determined by sequence of instrument and opcode definition within Csound.

  Syntax

JackoInit ServerName, SclientName


===========================================================================
JackoMidiInConnect                                       *JackoMidiInConnect*

  Description

In the orchestra header, creates a MIDI connection from an external Jack
MIDI output port to this instance of Csound.

  Syntax

JackoMidiInConnect SexternalPortName, ScsoundPortName


===========================================================================
JackoMidiOutConnect                                     *JackoMidiOutConnect*

  Description

In the orchestra header, creates a connection from a Jack MIDI output
port inside this instance of Csound to an external Jack MIDI input port.

  Syntax

JackoMidiOutConnect ScsoundPortName, SexternalPortName


===========================================================================
JackoMidiOut                                                   *JackoMidiOut*

  Description

Sends a MIDI channel message to a Jack MIDI output port inside this
instance of Csound, and in turn to its connected external Jack MIDI
input port.

  Syntax

JackoMidiOut  ScsoundPortName, kstatus, kchannel, kdata1[, kdata2]


===========================================================================
JackoNoteOut                                                   *JackoNoteOut*

  Description

Sends a MIDI channel message to a Jack MIDI output port inside this
instance of Csound, and in turn to its connected external Jack MIDI
input port.

  Syntax

JackoNoteOut  ScsoundPortName, kstatus, kchannel, kdata1[, kdata2]


===========================================================================
JackoOn                                                             *JackoOn*

  Description

In the orchestra header, after all Jack connections have been created,
enables or disables all Jack input and output opcodes inside this
instance of Csound to read or write data.

  Syntax

JackoOn [iactive] 


===========================================================================
JackoTransport                                               *JackoTransport*

  Description

Starts, stops, or repositions the Jack transport. This is useful, e.g.,
for starting an external sequencer playing to send MIDI messages to Csound.

  Syntax

JackoTransport  kcommand, [kposition]


===========================================================================
jacktransport                                                 *jacktransport*

  Description

Start/stop jack_transport and can optionally relocate the playback head.

  Syntax

jacktransport icommand [, ilocation]


===========================================================================
jitter                                                               *jitter*

  Description

Generates a segmented line whose segments are randomly generated.

  Syntax

kout jitter kamp, kcpsMin, kcpsMax


===========================================================================
jitter2                                                             *jitter2*

  Description

Generates a segmented line with user-controllable random segments.

  Syntax

kout jitter2 ktotamp, kamp1, kcps1, kamp2, kcps2, kamp3, kcps3


===========================================================================
joystick                                                           *joystick*

  Description

Reads data from a Linux joystick controller

  Syntax

kres joystick kdevice ktab


===========================================================================
jspline                                                             *jspline*

  Description

A jitter-spline generator.

  Syntax

ares jspline xamp, kcpsMin, kcpsMax

kres jspline kamp, kcpsMin, kcpsMax


===========================================================================
k                                                                         *k*

  Description

Converts an i-rate value to control rate, for example to be used with
rnd() and birnd() to generate random numbers at k-rate.

  Syntax

k(x) (i-rate args only)

k(x) (a-rate args only)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
kgoto                                                                 *kgoto*

  Description

During the p-time passes only, unconditionally transfer control to the
statement labeled by label.

  Syntax

kgoto label

where label is in the same instrument block and is not an expression.


===========================================================================
kr                                                                       *kr*

  Description

These statements are global value assignments, made at the beginning of
an orchestra, before any instrument block is defined. Their function is
to set certain reserved symbol variables that are required for
performance. Once set, these reserved symbols can be used in expressions
anywhere in the orchestra.

  Syntax

kr = iarg


===========================================================================
ksmps                                                                 *ksmps*

  Description

These statements are global value assignments, made at the beginning of
an orchestra, before any instrument block is defined. Their function is
to set certain reserved symbol variables that are required for
performance. Once set, these reserved symbols can be used in expressions
anywhere in the orchestra.

  Syntax

ksmps = iarg


===========================================================================
lenarray                                                           *lenarray*

  Description

Evaluates the size or number of dimensions of an array.

  Syntax

ir lenarray karray[, iwhich]

kr lenarray karray[, iwhich]


===========================================================================
lfo                                                                     *lfo*

  Description

A low frequency oscillator of various shapes.

  Syntax

kres lfo kamp, kcps [, itype]

ares lfo kamp, kcps [, itype]


===========================================================================
limit                                                                 *limit*

  Description

Sets the lower and upper limits of the value it processes.

  Syntax

ares limit asig, klow, khigh

ires limit isig, ilow, ihigh

kres limit ksig, klow, khigh


===========================================================================
line                                                                   *line*

  Description

Trace a straight line between specified points.

  Syntax

ares line ia, idur, ib

kres line ia, idur, ib


===========================================================================
linen                                                                 *linen*

  Description

linen -- apply a straight line rise and decay pattern to an input amp
signal.

  Syntax

ares linen xamp, irise, idur, idec

kres linen kamp, irise, idur, idec


===========================================================================
linenr                                                               *linenr*

  Description

linenr -- same as linen except that the final segment is entered only on
sensing a MIDI note release. The note is then extended by the decay time.

  Syntax

ares linenr xamp, irise, idec, iatdec

kres linenr kamp, irise, idec, iatdec


===========================================================================
lineto                                                               *lineto*

  Description

Generate glissandos starting from a control signal.

  Syntax

kres lineto ksig, ktime


===========================================================================
linrand                                                             *linrand*

  Description

Linear distribution random number generator (positive values only). This
is an x-class noise generator.

  Syntax

ares linrand krange

ires linrand krange

kres linrand krange


===========================================================================
linseg                                                               *linseg*

  Description

Trace a series of line segments between specified points.

  Syntax

ares linseg ia, idur1, ib [, idur2] [, ic] [...]

kres linseg ia, idur1, ib [, idur2] [, ic] [...]


===========================================================================
linsegb                                                             *linsegb*

  Description

Trace a series of line segments between specified absolute points.

  Syntax

ares linsegb ia, itim1, ib [, itim2] [, ic] [...]

kres linsegb ia, itim1, ib [, itim2] [, ic] [...]


===========================================================================
linsegr                                                             *linsegr*

  Description

Trace a series of line segments between specified points including a
release segment.

  Syntax

ares linsegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz

kres linsegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz


===========================================================================
locsend                                                             *locsend*

  Description

locsend depends upon the existence of a previously defined locsig. The
number of output signals must match the number in the previous locsig.
The output signals from locsend are derived from the values given for
distance and reverb in the locsig and are ready to be sent to local or
global reverb units (see example below). The reverb amount and the
balance between the 2 or 4 channels are calculated in the same way as
described in the Dodge book (an essential text!).

  Syntax

a1, a2 locsend

a1, a2,  a3, a4 locsend


===========================================================================
locsig                                                               *locsig*

  Description

locsig takes an input signal and distributes it among 2 or 4 channels
using values in degrees to calculate the balance between adjacent
channels. It also takes arguments for distance (used to attenuate
signals that are to sound as if they are some distance further than the
loudspeaker itself), and for the amount the signal that will be sent to
reverberators. This unit is based upon the example in the Charles
Dodge/Thomas Jerse book, Computer Music, page 320.

  Syntax

a1, a2 locsig asig, kdegree, kdistance, kreverbsend

a1, a2,  a3, a4 locsig asig, kdegree, kdistance, kreverbsend


===========================================================================
log                                                                     *log*

  Description

Returns the natural log of x (x positive only). In the case of an array
input, the operation can have an optional arbitrary base.

The argument value is restricted for log, log10, and sqrt.

  Syntax

log(x) (no rate restriction)

kout[]log kin[][,ibas]

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.
In the case of an array input, ibas is the optional arbitrary base,
which defaults to e (natural log base).


===========================================================================
log10                                                                 *log10*

  Description

Returns the base 10 log of x (x positive only).

The argument value is restricted for log, log10, and sqrt.

  Syntax

log10(x) (no rate restriction)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
log2                                                                   *log2*

  Description

Returns the base 2 log of x (x positive only).

The argument value is restricted for log, log2, and sqrt.

  Syntax

log2(x) (no rate restriction)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
logbtwo                                                             *logbtwo*

  Description

Performs a logarithmic base two calculation.

  Syntax

logbtwo(x)  (init-rate or control-rate args only)


===========================================================================
logcurve                                                           *logcurve*

  Description

Generates a logarithmic curve in range 0 to 1 of arbitrary steepness.
Steepness index equal to or lower than 1.0 will result in Not-a-Number
errors and cause unstable behavior.

The formula used to calculate the curve is:

log(x * (y-1)+1) / (log(y)

where x is equal to kindex and y is equal to ksteepness.

  Syntax

kout logcurve kindex, ksteepness


===========================================================================
loop_ge                                                             *loop_ge*

  Description

Construction of looping operations.

  Syntax

loop_ge  indx, idecr, imin, label

loop_ge  kndx, kdecr, kmin, label


===========================================================================
loop_gt                                                             *loop_gt*

  Description

Construction of looping operations.

  Syntax

loop_gt  indx, idecr, imin, label

loop_gt  kndx, kdecr, kmin, label


===========================================================================
loop_le                                                             *loop_le*

  Description

Construction of looping operations.

  Syntax

loop_le  indx, incr, imax, label

loop_le  kndx, kncr, kmax, label


===========================================================================
loop_lt                                                             *loop_lt*

  Description

Construction of looping operations.

  Syntax

loop_lt  indx, incr, imax, label

loop_lt  kndx, kncr, kmax, label


===========================================================================
loopseg                                                             *loopseg*

  Description

Generate control signal consisting of linear segments delimited by two
or more specified points. The entire envelope is looped at kfreq rate.
Each parameter can be varied at k-rate.

  Syntax

ksig loopseg kfreq, ktrig, iphase, kvalue0, ktime0 [, kvalue1] [, ktime1] \
[, kvalue2] [, ktime2][...]


===========================================================================
loopsegp                                                           *loopsegp*

  Description

Generate control signal consisiting of linear segments delimited by two
or more specified points. The entire envelope can be looped at
time-variant rate. Each segment coordinate can also be varied at k-rate.

  Syntax

ksig loopsegp  kphase, kvalue0, kdur0, kvalue1 \
      [, kdur1, ... , kdurN-1, kvalueN]


===========================================================================
looptseg                                                           *looptseg*

  Description

Generate control signal consisting of controllable exponential segments
or linear segments delimited by two or more specified points. The entire
envelope is looped at kfreq rate. Each parameter can be varied at k-rate.

  Syntax

ksig looptseg kfreq, ktrig, iphase, kvalue0, ktype0, ktime0, [, kvalue1] [,ktype1] [, ktime1] \
      [, kvalue2] [,ktype2] [, ktime2] [...] [, kvalueN] [,ktypeN] [, ktimeN]


===========================================================================
loopxseg                                                           *loopxseg*

  Description

Generate control signal consisting of exponential segments delimited by
two or more specified points. The entire envelope is looped at kfreq
rate. Each parameter can be varied at k-rate.

  Syntax

ksig loopxseg kfreq, ktrig, iphase, ktime0, kvalue0 [, ktime1] [, kvalue1] \
      [, ktime2] [, kvalue2] [...]


===========================================================================
lorenz                                                               *lorenz*

  Description

Implements the Lorenz system of equations. The Lorenz system is a
chaotic-dynamic system which was originally used to simulate the motion
of a particle in convection currents and simplified weather systems.
Small differences in initial conditions rapidly lead to diverging
values. This is sometimes expressed as the butterfly effect. If a
butterfly flaps its wings in Australia, it will have an effect on the
weather in Alaska. This system is one of the milestones in the
development of chaos theory. It is useful as a chaotic audio source or
as a low frequency modulation source.

  Syntax

ax, ay, az lorenz ksv, krv, kbv, kh, ix, iy, iz, iskip [, iskipinit]


===========================================================================
lorisread                                                         *lorisread*

  Syntax

lorisread ktimpnt, ifilcod, istoreidx, kfreqenv, kampenv, kbwenv[, ifadetime]

  Description

lorisread imports a set of bandwidth-enhanced partials from a
SDIF-format data file, applying control-rate frequency, amplitude, and
bandwidth scaling envelopes, and stores the modified partials in memory.


===========================================================================
lorismorph                                                       *lorismorph*

  Syntax

lorismorph isrcidx, itgtidx, istoreidx, kfreqmorphenv, kampmorphenv, kbwmorphenv

  Description

lorismorph morphs two stored sets of bandwidth-enhanced partials and
stores a new set of partials representing the morphed sound. The morph
is performed by linearly interpolating the parameter envelopes
(frequency, amplitude, and bandwidth, or noisiness) of the
bandwidth-enhanced partials according to control-rate frequency,
amplitude, and bandwidth morphing functions.


===========================================================================
lorisplay                                                         *lorisplay*

  Syntax

ar lorisplay ireadidx, kfreqenv, kampenv, kbwenv

  Description

lorisplay renders a stored set of bandwidth-enhanced partials using the
method of Bandwidth-Enhanced Additive Synthesis implemented in the Loris
software, applying control-rate frequency, amplitude, and bandwidth
scaling envelopes.


===========================================================================
loscil                                                               *loscil*

  Description

Read sampled sound (mono or stereo) from a table, with optional sustain
and release looping.

  Syntax

ar1 [,ar2] loscil xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] [, iend1] \
      [, imod2] [, ibeg2] [, iend2]


===========================================================================
loscil3                                                             *loscil3*

  Description

Read sampled sound (mono or stereo) from a table, with optional sustain
and release looping, using cubic interpolation.

  Syntax

ar1 [,ar2] loscil3 xamp, kcps, ifn [, ibas] [, imod1] [, ibeg1] [, iend1] \
      [, imod2] [, ibeg2] [, iend2]


===========================================================================
loscilx                                                             *loscilx*

  Description

Read sampled sound (up to 16 channels) from a table, with optional
sustain and release looping.

  Syntax

ar1 [, ar2, ar3, ar4, ar5, ar6, ar7, ar8, ar9, ar10, ar11, ar12, ar13, ar14, \
      ar15, ar16] loscilx xamp, kcps, ifn \
      [, iwsize, ibas, istrt, imod, ibeg, iend]


===========================================================================
lowpass2                                                           *lowpass2*

  Description

Implementation of a resonant second-order lowpass filter.

  Syntax

ares lowpass2 asig, kcf, kq [, iskip]


===========================================================================
lowres                                                               *lowres*

  Description

lowres is a resonant lowpass filter.

  Syntax

ares lowres asig, kcutoff, kresonance [, iskip]


===========================================================================
lowresx                                                             *lowresx*

  Description

lowresx is equivalent to more layers of lowres with the same arguments
serially connected.

  Syntax

ares lowresx asig, xcutoff, xresonance [, inumlayer] [, iskip]


===========================================================================
lpf18                                                                 *lpf18*

  Description

Implementation of a 3 pole sweepable resonant lowpass filter.

  Syntax

ares lpf18 asig, xfco, xres, xdist [, iskip]


===========================================================================
lpfreson                                                           *lpfreson*

  Description

Resynthesises a signal from the data passed internally by a previous
lpread, applying formant shifting.

  Syntax

ares lpfreson asig, kfrqratio


===========================================================================
lphasor                                                             *lphasor*

  Description

This opcode can be used to generate table index for sample playback
(e.g. tablexkt).

  Syntax

ares lphasor xtrns [, ilps] [, ilpe] [, imode] [, istrt] [, istor]


===========================================================================
lpinterp                                                           *lpinterp*

  Description

Computes a new set of poles from the interpolation between two analysis.

  Syntax

lpinterp islot1, islot2, kmix


===========================================================================
lposcil                                                             *lposcil*

  Description

Read sampled sound (mono or stereo) from a table, with looping, and high
precision.

  Syntax

ares lposcil kamp, kfreqratio, kloop, kend, ifn [, iphs]


===========================================================================
lposcil3                                                           *lposcil3*

  Description

Read sampled sound (mono or stereo) from a table, with looping, and high
precision. lposcil3 uses cubic interpolation.

  Syntax

ares lposcil3 kamp, kfreqratio, kloop, kend, ifn [, iphs]


===========================================================================
lposcila                                                           *lposcila*

  Description

lposcila reads sampled sound from a table with looping and high precision.

  Syntax

ar lposcila aamp, kfreqratio, kloop, kend, ift [,iphs] 


===========================================================================
lposcilsa                                                         *lposcilsa*

  Description

lposcilsa reads stereo sampled sound from a table with looping and high
precision.

  Syntax

ar1, ar2 lposcilsa aamp, kfreqratio, kloop, kend, ift [,iphs] 


===========================================================================
lposcilsa2                                                       *lposcilsa2*

  Description

lposcilsa2 reads stereo sampled sound from a table with looping and high
precision.

  Syntax

ar1, ar2 lposcilsa2 aamp, kfreqratio, kloop, kend, ift [,iphs] 


===========================================================================
lpread                                                               *lpread*

  Description

Reads a control file of time-ordered information frames.

  Syntax

krmsr, krmso, kerr, kcps lpread ktimpnt, ifilcod [, inpoles] [, ifrmrate]


===========================================================================
lpreson                                                             *lpreson*

  Description

Resynthesises a signal from the data passed internally by a previous
lpread.

  Syntax

ares lpreson asig


===========================================================================
lpshold                                                             *lpshold*

  Description

Generate control signal consisting of held segments delimited by two or
more specified points. The entire envelope is looped at kfreq rate. Each
parameter can be varied at k-rate.

  Syntax

ksig lpshold kfreq, ktrig, iphase, ktime0, kvalue0  [, kvalue1] [, ktime1] [, kvalue2] [, ktime2] [...]


===========================================================================
lpsholdp                                                           *lpsholdp*

  Description

Generate control signal consisiting of held segments delimited by two or
more specified points. The entire envelope can be looped at time-variant
rate. Each segment coordinate can also be varied at k-rate.

  Syntax

ksig lpsholdp  kphase, kvalue0, ktime0  [, kvalue1] [, ktime1] \
      [, kvalue2] [, ktime2] [...]


===========================================================================
lpslot                                                               *lpslot*

  Description

Selects the slot to be use by further lp opcodes.

  Syntax

lpslot islot


===========================================================================
lua_exec                                                           *lua_exec*

  Description

Executes an arbitrary block of Lua code from the Csound orchestra. The
code is executed at initialization time, typically from the orchestra
header.

  Syntax

lua_exec Sluacode


===========================================================================
lua_opdef                                                         *lua_opdef*

  Description

Define an opcode in Lua at i-rate. The opcode can take any number of
output and/or input arguments of any type. The code is executed at
initialization time, typically from the orchestra header. Global and
local variables, functions, tables, and classes may be declared and
defined. Objects defined at global Lua scope remain in scope throughout
the performance, and are visible to any other Lua code in the same
Csound thread.

  Note

By default, all objects defined in Lua are defined at global scope. In
order to ensure that objects are confined to their own block of code,
that is to ensure that the object is visible only in lexical scope, the
object must be declared as local. This is the feature of Lua that
beginners tend to find the most troublesome.

Another thing to look out for is that Lua arrays use 1-based indexing,
not the 0-based indexing used in C and many other programming languages.

  Syntax

lua_opdef Sname, Sluacode


===========================================================================
lua_opcall                                                       *lua_opcall*

  Syntax

lua_iopcall Sname, ...

lua_ikopcall Sname, ...

lua_iaopcall Sname, ...

lua_iopcall_off Sname, ...

lua_ikopcall_off Sname, ...

lua_iaopcall_off Sname, ...


===========================================================================
mac                                                                     *mac*

  Description

Multiplies and accumulates a- and k-rate signals.

  Syntax

ares mac ksig1, asig1 [, ksig2] [, asig2] [, ksig3] [, asig3] [...]


===========================================================================
maca                                                                   *maca*

  Description

Multiply and accumulate a-rate signals only.

  Syntax

ares maca asig1 , asig2 [, asig3] [, asig4] [, asig5] [...]


===========================================================================
madsr                                                                 *madsr*

  Description

Calculates the classical ADSR envelope using the linsegr mechanism.

  Syntax

ares madsr iatt, idec, islev, irel [, idel] [, ireltim]

kres madsr iatt, idec, islev, irel [, idel] [, ireltim]


===========================================================================
mags                                                                   *mags*

  Description

This opcode returns the magnitudes of a complex-number array (in rfft
format), as a real-valued array with half the size of its input plus
one. The magnitude for the Nyquist frequency are kept in the last
position of the array.

  Syntax

kout[] mags kin[]


===========================================================================
mandel                                                               *mandel*

  Description

Returns the number of iterations corresponding to a given point of
complex plane by applying the Mandelbrot set formula.

  Syntax

kiter, koutrig mandel  ktrig, kx, ky, kmaxIter


===========================================================================
mandol                                                               *mandol*

  Description

An emulation of a mandolin.

  Syntax

ares mandol kamp, kfreq, kpluck, kdetune, kgain, ksize \
    [, ifn] [, iminfreq]


===========================================================================
maparray                                                           *maparray*

  Description

Apply a function of one argument to every element of a vector
(one-dimensional k-rate array).

  Syntax

karray maparray kinarray, String

karray maparray_i kinarray, String


===========================================================================
marimba                                                             *marimba*

  Description

Audio output is a tone related to the striking of a wooden block as
found in a marimba. The method is a physical model developed from Perry
Cook but re-coded for Csound.

  Syntax

ares marimba kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivibfn, idec \
      [, idoubles] [, itriples]


===========================================================================
massign                                                             *massign*

  Description

Assigns a MIDI channel number to a Csound instrument.

  Syntax

massign ichnl, insnum[, ireset]

massign ichnl, "insname"[, ireset]


===========================================================================
max                                                                     *max*

  Description

The max opcode takes any number of a-rate, k-rate or i-rate signals as
input (all of the same rate), and outputs a signal at the same rate that
is the maximum of all of the inputs. For a-rate signals, the inputs are
compared one sample at a time (i.e. max does not scan an entire ksmps
period of a signal for its local maximum as the max_k opcode does).

  Syntax

amax max ain1, ain2 [, ain3] [, ain4] [...]

kmax max kin1, kin2 [, kin3] [, kin4] [...]

imax max iin1, iin2 [, iin3] [, iin4] [...]


===========================================================================
maxabs                                                               *maxabs*

  Description

The maxabs opcode takes any number of a-rate or k-rate signals as input
(all of the same rate), and outputs a signal at the same rate that is
the maximum of all of the inputs. It is identical to the max opcode
except that it takes the absolute value of each input before comparing
them. Therefore, the output is always non-negative. For a-rate signals,
the inputs are compared one sample at a time (i.e. maxabs does not scan
an entire ksmps period of a signal for its local maximum as the max_k
opcode does).

  Syntax

amax maxabs ain1, ain2 [, ain3] [, ain4] [...]

kmax maxabs kin1, kin2 [, kin3] [, kin4] [...]


===========================================================================
maxabsaccum                                                     *maxabsaccum*

  Description

maxabsaccum compares two audio-rate variables and stores the maximum of
their absolute values into the first.

  Syntax

maxabsaccum aAccumulator, aInput


===========================================================================
maxaccum                                                           *maxaccum*

  Description

maxaccum compares two audio-rate variables and stores the maximum value
between them into the first.

  Syntax

maxaccum aAccumulator, aInput


===========================================================================
maxalloc                                                           *maxalloc*

  Description

Limits the number of allocations of an instrument.

  Syntax

maxalloc insnum, icount

maxalloc Sinsname, icount


===========================================================================
max_k                                                                 *max_k*

  Description

max_k outputs the local maximum (or minimum) value of the incoming asig
signal, checked in the time interval between ktrig has become true twice.

  Syntax

knumkout max_k asig, ktrig, itype


===========================================================================
maxarray                                                           *maxarray*

  Description

The maxarray opcode returns the maximum value in a k-rate array, and
optional its index.

  Syntax

kmax [,kindx] maxarray karray


===========================================================================
mclock                                                               *mclock*

  Description

Sends a MIDI CLOCK message.

  Syntax

mclock ifreq


===========================================================================
mdelay                                                               *mdelay*

  Description

A MIDI delay opcode.

  Syntax

mdelay kstatus, kchan, kd1, kd2, kdelay


===========================================================================
median                                                               *median*

  Description

Implementation of a median filter.

  Syntax

ares median asig, ksize, imaxsize [, iskip]


===========================================================================
mediank                                                             *mediank*

  Description

Implementation of a median filter.

  Syntax

kres mediank kin, ksize, imaxsize [, iskip]


===========================================================================
metro                                                                 *metro*

  Description

Generate a metronomic signal to be used in any circumstance an
isochronous trigger is needed.

  Syntax

ktrig  metro  kfreq [, initphase]


===========================================================================
midglobal                                                         *midglobal*

  Description

With the midremot and midglobal opcodes you are able to perform
instruments on remote machines and control them from a master machine.
The remote opcodes are implemented using the master/client model. All
the machines involved contain the same orchestra but only the master
machine contains the information of the midi score. During the
performance the master machine sends the midi events to the clients. The
midglobal opcode sends the events to all the machines involved in the
remote concert. These machines are determined by the midremot
definitions made above the midglobal command. To send events to only one
machine use midremot.

  Syntax

midglobal isource, instrnum [,instrnum...] 


===========================================================================
midic14                                                             *midic14*

  Description

Allows a floating-point 14-bit MIDI signal scaled with a minimum and a
maximum range.

  Syntax

idest midic14 ictlno1, ictlno2, imin, imax [, ifn]

kdest midic14 ictlno1, ictlno2, kmin, kmax [, ifn]


===========================================================================
midic21                                                             *midic21*

  Description

Allows a floating-point 21-bit MIDI signal scaled with a minimum and a
maximum range.

  Syntax

idest midic21 ictlno1, ictlno2, ictlno3, imin, imax [, ifn]

kdest midic21 ictlno1, ictlno2, ictlno3, kmin, kmax [, ifn]


===========================================================================
midic7                                                               *midic7*

  Description

Allows a floating-point 7-bit MIDI signal scaled with a minimum and a
maximum range.

  Syntax

idest midic7 ictlno, imin, imax [, ifn]

kdest midic7 ictlno, kmin, kmax [, ifn]


===========================================================================
midichannelaftertouch                                 *midichannelaftertouch*

  Description

midichannelaftertouch is designed to simplify writing instruments that
can be used interchangeably for either score or MIDI input, and to make
it easier to adapt instruments originally written for score input to
work with MIDI input.

In general, it should be possible to write instrument definitions that
work identically with both scores and MIDI, including both MIDI files
and real-time MIDI input, without using any conditional statements, and
that take full advantage of MIDI voice messages.

Note that correlating Csound instruments with MIDI channel numbers is
done using the massign opcode for real-time performance,. For
file-driven performance, instrument numbers default to MIDI channel
number + 1, but the defaults are overridden by any MIDI program change
messages in the file.

  Syntax

midichannelaftertouch xchannelaftertouch [, ilow] [, ihigh]


===========================================================================
midichn                                                             *midichn*

  Description

midichn returns the MIDI channel number (1 - 16) from which the note was
activated. In the case of score notes, it returns 0.

  Syntax

ichn midichn


===========================================================================
midicontrolchange                                         *midicontrolchange*

  Description

midicontrolchange is designed to simplify writing instruments that can
be used interchangeably for either score or MIDI input, and to make it
easier to adapt instruments originally written for score input to work
with MIDI input.

In general, it should be possible to write instrument definitions that
work identically with both scores and MIDI, including both MIDI files
and real-time MIDI input, without using any conditional statements, and
that take full advantage of MIDI voice messages.

Note that correlating Csound instruments with MIDI channel numbers is
done using the massign opcode for real-time performance,. For
file-driven performance, instrument numbers default to MIDI channel
number + 1, but the defaults are overridden by any MIDI program change
messages in the file.

  Syntax

midicontrolchange xcontroller, xcontrollervalue [, ilow] [, ihigh]


===========================================================================
midictrl                                                           *midictrl*

  Description

Get the current value (0-127) of a specified MIDI controller.

  Syntax

ival midictrl inum [, imin] [, imax]

kval midictrl inum [, imin] [, imax]


===========================================================================
mididefault                                                     *mididefault*

  Description

mididefault is designed to simplify writing instruments that can be used
interchangeably for either score or MIDI input, and to make it easier to
adapt instruments originally written for score input to work with MIDI
input.

In general, it should be possible to write instrument definitions that
work identically with both scores and MIDI, including both MIDI files
and real-time MIDI input, without using any conditional statements, and
that take full advantage of MIDI voice messages.

Note that correlating Csound instruments with MIDI channel numbers is
done using the massign opcode for real-time performance,. For
file-driven performance, instrument numbers default to MIDI channel
number + 1, but the defaults are overridden by any MIDI program change
messages in the file.

  Syntax

mididefault xdefault, xvalue


===========================================================================
midiin                                                               *midiin*

  Description

Returns a generic MIDI message received by the MIDI IN port

  Syntax

kstatus, kchan, kdata1, kdata2 midiin


===========================================================================
midifilestatus                                               *midifilestatus*

  Description

Returns the current playback status at k-rate, of the input MIDI file, 1
if file is playing, 0 if the end-of-the file has been reached.

  Syntax

ksig  midifilestatus


===========================================================================
midinoteoff                                                     *midinoteoff*

  Description

midinoteoff is designed to simplify writing instruments that can be used
interchangeably for either score or MIDI input, and to make it easier to
adapt instruments originally written for score input to work with MIDI
input.

In general, it should be possible to write instrument definitions that
work identically with both scores and MIDI, including both MIDI files
and real-time MIDI input, without using any conditional statements, and
that take full advantage of MIDI voice messages.

Note that correlating Csound instruments with MIDI channel numbers is
done using the massign opcode for real-time performance,. For
file-driven performance, instrument numbers default to MIDI channel
number + 1, but the defaults are overridden by any MIDI program change
messages in the file.

  Syntax

midinoteoff xkey, xvelocity


===========================================================================
midinoteoncps                                                 *midinoteoncps*

  Description

midinoteoncps is designed to simplify writing instruments that can be
used interchangeably for either score or MIDI input, and to make it
easier to adapt instruments originally written for score input to work
with MIDI input.

In general, it should be possible to write instrument definitions that
work identically with both scores and MIDI, including both MIDI files
and real-time MIDI input, without using any conditional statements, and
that take full advantage of MIDI voice messages.

Note that correlating Csound instruments with MIDI channel numbers is
done using the massign opcode for real-time performance,. For
file-driven performance, instrument numbers default to MIDI channel
number + 1, but the defaults are overridden by any MIDI program change
messages in the file.

  Syntax

midinoteoncps xcps, xvelocity


===========================================================================
midinoteonkey                                                 *midinoteonkey*

  Description

midinoteonkey is designed to simplify writing instruments that can be
used interchangeably for either score or MIDI input, and to make it
easier to adapt instruments originally written for score input to work
with MIDI input.

In general, it should be possible to write instrument definitions that
work identically with both scores and MIDI, including both MIDI files
and real-time MIDI input, without using any conditional statements, and
that take full advantage of MIDI voice messages.

Note that correlating Csound instruments with MIDI channel numbers is
done using the massign opcode for real-time performance,. For
file-driven performance, instrument numbers default to MIDI channel
number + 1, but the defaults are overridden by any MIDI program change
messages in the file.

  Syntax

midinoteonkey xkey, xvelocity


===========================================================================
midinoteonoct                                                 *midinoteonoct*

  Description

midinoteonoct is designed to simplify writing instruments that can be
used interchangeably for either score or MIDI input, and to make it
easier to adapt instruments originally written for score input to work
with MIDI input.

In general, it should be possible to write instrument definitions that
work identically with both scores and MIDI, including both MIDI files
and real-time MIDI input, without using any conditional statements, and
that take full advantage of MIDI voice messages.

Note that correlating Csound instruments with MIDI channel numbers is
done using the massign opcode for real-time performance,. For
file-driven performance, instrument numbers default to MIDI channel
number + 1, but the defaults are overridden by any MIDI program change
messages in the file.

  Syntax

midinoteonoct xoct, xvelocity


===========================================================================
midinoteonpch                                                 *midinoteonpch*

  Description

midinoteonpch is designed to simplify writing instruments that can be
used interchangeably for either score or MIDI input, and to make it
easier to adapt instruments originally written for score input to work
with MIDI input.

In general, it should be possible to write instrument definitions that
work identically with both scores and MIDI, including both MIDI files
and real-time MIDI input, without using any conditional statements, and
that take full advantage of MIDI voice messages.

Note that correlating Csound instruments with MIDI channel numbers is
done using the massign opcode for real-time performance,. For
file-driven performance, instrument numbers default to MIDI channel
number + 1, but the defaults are overridden by any MIDI program change
messages in the file.

  Syntax

midinoteonpch xpch, xvelocity


===========================================================================
midion2                                                             *midion2*

  Description

Sends noteon and noteoff messages to the MIDI OUT port when triggered by
a value different than zero.

  Syntax

midion2 kchn, knum, kvel, ktrig


===========================================================================
midion                                                               *midion*

  Description

Generates MIDI note messages at k-rate.

  Syntax

midion kchn, knum, kvel


===========================================================================
midiout                                                             *midiout*

  Description

Sends a generic MIDI message to the MIDI OUT port.

  Syntax

midiout kstatus, kchan, kdata1, kdata2


===========================================================================
midipitchbend                                                 *midipitchbend*

  Description

midipitchbend is designed to simplify writing instruments that can be
used interchangeably for either score or MIDI input, and to make it
easier to adapt instruments originally written for score input to work
with MIDI input.

In general, it should be possible to write instrument definitions that
work identically with both scores and MIDI, including both MIDI files
and real-time MIDI input, without using any conditional statements, and
that take full advantage of MIDI voice messages.

Note that correlating Csound instruments with MIDI channel numbers is
done using the massign opcode for real-time performance,. For
file-driven performance, instrument numbers default to MIDI channel
number + 1, but the defaults are overridden by any MIDI program change
messages in the file.

  Syntax

midipitchbend xpitchbend [, ilow] [, ihigh]


===========================================================================
midipolyaftertouch                                       *midipolyaftertouch*

  Description

midipolyaftertouch is designed to simplify writing instruments that can
be used interchangeably for either score or MIDI input, and to make it
easier to adapt instruments originally written for score input to work
with MIDI input.

In general, it should be possible to write instrument definitions that
work identically with both scores and MIDI, including both MIDI files
and real-time MIDI input, without using any conditional statements, and
that take full advantage of MIDI voice messages.

Note that correlating Csound instruments with MIDI channel numbers is
done using the massign opcode for real-time performance,. For
file-driven performance, instrument numbers default to MIDI channel
number + 1, but the defaults are overridden by any MIDI program change
messages in the file.

  Syntax

midipolyaftertouch xpolyaftertouch, xcontrollervalue [, ilow] [, ihigh]


===========================================================================
midiprogramchange                                         *midiprogramchange*

  Description

midiprogramchange is designed to simplify writing instruments that can
be used interchangeably for either score or MIDI input, and to make it
easier to adapt instruments originally written for score input to work
with MIDI input.

In general, it should be possible to write instrument definitions that
work identically with both scores and MIDI, including both MIDI files
and real-time MIDI input, without using any conditional statements, and
that take full advantage of MIDI voice messages.

Note that correlating Csound instruments with MIDI channel numbers is
done using the massign opcode for real-time performance,. For
file-driven performance, instrument numbers default to MIDI channel
number + 1, but the defaults are overridden by any MIDI program change
messages in the file.

  Syntax

midiprogramchange xprogram


===========================================================================
miditempo                                                         *miditempo*

  Description

Returns the current tempo at k-rate, of either the MIDI file (if
available) or the score

  Syntax

ksig  miditempo


===========================================================================
midremot                                                           *midremot*

  Description

With the midremot and midglobal opcodes you are able to perform
instruments on remote machines and control them from a master machine.
The remote opcodes are implemented using the master/client model. All
the machines involved contain the same orchestra but only the master
machine contains the information of the midi score. During the
performance the master machine sends the midi events to the clients. The
midremot opcode will send events from a source machine to one
destination if you want to send events to many destinations (broadcast)
use the midglobal opcode instead. These two opcodes can be used in
combination.

  Syntax

midremot idestination, isource, instrnum [,instrnum...] 


===========================================================================
min                                                                     *min*

  Description

The min opcode takes any number of a-rate, k-rate or i-rate signals as
input (all of the same rate), and outputs a signal at the same rate that
is the minimum of all of the inputs. For a-rate signals, the inputs are
compared one sample at a time (i.e. min does not scan an entire ksmps
period of a signal for its local minimum as the max_k opcode does).

  Syntax

amin min ain1, ain2 [, ain3] [, ain4] [...]

kmin min kin1, kin2 [, kin3] [, kin4] [...]

imin min iin1, iin2 [, iin3] [, iin4] [...]


===========================================================================
minabs                                                               *minabs*

  Description

The minabs opcode takes any number of a-rate or k-rate signals as input
(all of the same rate), and outputs a signal at the same rate that is
the minimum of all of the inputs. It is identical to the min opcode
except that it takes the absolute value of each input before comparing
them. Therefore, the output is always non-negative. For a-rate signals,
the inputs are compared one sample at a time (i.e. minabs does not scan
an entire ksmps period of a signal for its local minimum as the max_k
opcode does).

  Syntax

amin minabs ain1, ain2 [, ain3] [, ain4] [...]

kmin minabs kin1, kin2 [, kin3] [, kin4] [...]


===========================================================================
minabsaccum                                                     *minabsaccum*

  Description

minabsaccum compares two audio-rate variables and stores the minimum of
their absolute values into the first.

  Syntax

minabsaccum aAccumulator, aInput


===========================================================================
minaccum                                                           *minaccum*

  Description

minaccum compares two audio-rate variables and stores the minimum value
between them into the first.

  Syntax

minaccum aAccumulator, aInput


===========================================================================
mincer                                                               *mincer*

  Description

mincer implements phase-locked vocoder processing using function tables
containing sampled-sound sources, with GEN01, and mincer will accept
deferred allocation tables.

This opcode allows for time and frequency-independent scaling. Time is
controlled by a time index (in seconds) to the function table position
and can be moved forward and backward at any chosen speed, as well as
stopped at a given position ("frozen"). The quality of the effect is
generally improved with phase locking switched on.

mincer will also scale pitch, independently of frequency, using a
transposition factor (k-rate).

  Syntax

asig mincer atimpt, kamp, kpitch, ktab, klock[,ifftsize,idecim]


===========================================================================
minarray                                                           *minarray*

  Description

The minarray opcode returns the minimum value in a k-rate array, and
optional its index.

  Syntax

kmin [,kindx] minarray karray


===========================================================================
mirror                                                               *mirror*

  Description

Reflects the signal that exceeds the low and high thresholds.

  Syntax

ares mirror asig, klow, khigh

ires mirror isig, ilow, ihigh

kres mirror ksig, klow, khigh


===========================================================================
MixerSetLevel                                                 *MixerSetLevel*

  Syntax

MixerSetLevel isend, ibuss, kgain

  Description

Sets the level at which signals from the send are added to the buss. The
actual sending of the signal to the buss is performed by the MixerSend
opcode.


===========================================================================
MixerSetLevel_i                                             *MixerSetLevel_i*

  Syntax

MixerSetLevel_i isend, ibuss, igain

  Description

Sets the level at which signals from the send are added to the buss.
This opcode, because all parameters are irate, may be used in the
orchestra header. The actual sending of the signal to the buss is
performed by the MixerSend opcode.


===========================================================================
MixerGetLevel                                                 *MixerGetLevel*

  Syntax

kgain MixerGetLevel isend, ibuss

  Description

Gets the level at which signals from the send are being added to the
buss. The actual sending of the signal to the buss is performed by the
MixerSend opcode.


===========================================================================
MixerSend                                                         *MixerSend*

  Syntax

MixerSend asignal, isend, ibuss, ichannel

  Description

Mixes an arate signal into a channel of a buss.


===========================================================================
MixerReceive                                                   *MixerReceive*

  Syntax

asignal MixerReceive ibuss, ichannel

  Description

Receives an arate signal that has been mixed onto a channel of a buss.


===========================================================================
MixerClear                                                       *MixerClear*

  Syntax

MixerClear

  Description

Resets all channels of a buss to 0.


===========================================================================
mode                                                                   *mode*

  Description

Filters the incoming signal with the specified resonance frequency and
quality factor. It can also be seen as a signal generator for high
quality factor, with an impulse for the excitation. You can combine
several modes to built complex instruments such as bells or guitar tables.

  Syntax

aout mode ain, xfreq, xQ [, iskip]


===========================================================================
modmatrix                                                         *modmatrix*

  Description

The opcode can be used to let a large number of k-rate modulator
variables modulate a large number of k-rate parameter variables, with
arbitrary scaling of each modulator-to-parameter connection. Csound
ftables are used to hold both the input (parameter) variables, the
modulator variables, and the scaling coefficients. Output variables are
written to another Csound ftable.

  Syntax

modmatrix iresfn, isrcmodfn, isrcparmfn, imodscale, inum_mod, \\
inum_parm, kupdate


===========================================================================
monitor                                                             *monitor*

  Description

Returns the audio spout frame (if active), otherwise it returns zero.

  Syntax

aout1 [,aout2 ... aoutX] monitor


===========================================================================
moog                                                                   *moog*

  Description

An emulation of a mini-Moog synthesizer.

  Syntax

ares moog kamp, kfreq, kfiltq, kfiltrate, kvibf, kvamp, iafn, iwfn, ivfn


===========================================================================
moogladder                                                       *moogladder*

  Description

Moogladder is an new digital implementation of the Moog ladder filter
based on the work of Antti Huovilainen, described in the paper
"Non-Linear Digital Implementation of the Moog Ladder Filter"
(Proceedings of DaFX04, Univ of Napoli). This implementation is probably
a more accurate digital representation of the original analogue filter.

  Syntax

asig moogladder ain, kcf, kres[, istor]

asig moogladder ain, acf, kres[, istor]

asig moogladder ain, kcf, ares[, istor]

asig moogladder ain, acf, ares[, istor]


===========================================================================
moogladder2                                                     *moogladder2*

  Description

Moogladder2 is an new digital implementation of the Moog ladder filter
based on the work of Antti Huovilainen, described in the paper
"Non-Linear Digital Implementation of the Moog Ladder Filter"
(Proceedings of DaFX04, Univ of Napoli). This implementation uses
approximations to the tanh function and so is faster but less accurate
than moogladder.

  Syntax

asig moogladder2 ain, kcf, kres[, istor]

asig moogladder2 ain, acf, kres[, istor]

asig moogladder2 ain, kcf, ares[, istor]

asig moogladder2 ain, acf, ares[, istor]


===========================================================================
moogvcf                                                             *moogvcf*

  Description

A digital emulation of the Moog diode ladder filter configuration.

  Syntax

ares moogvcf asig, xfco, xres [,iscale, iskip]


===========================================================================
moogvcf2                                                           *moogvcf2*

  Description

A digital emulation of the Moog diode ladder filter configuration.

  Syntax

ares moogvcf2 asig, xfco, xres [,iscale, iskip]


===========================================================================
moscil                                                               *moscil*

  Description

Sends a stream of the MIDI notes.

  Syntax

moscil kchn, knum, kvel, kdur, kpause


===========================================================================
mp3in                                                                 *mp3in*

  Description

Reads mono or stereo audio data from an external MP3 file.

  Syntax

ar1, ar2 mp3in ifilcod[, iskptim, iformat, iskipinit, ibufsize]

ar1 mp3in ifilcod[, iskptim, iformat, iskipinit, ibufsize]


===========================================================================
mp3len                                                               *mp3len*

  Description

Returns the length of an MP3 sound file.

  Syntax

ir mp3len ifilcod


===========================================================================
mp3scal                                                             *mp3scal*

  Description

mp3scal implements phase-locked vocoder processing from mp3-format disk
files, resampling if necessary.

This opcode allows for time and frequency-independent scaling. Time is
advanced internally. The quality of the effect is generally improved
with phase locking switched on.

mp3scal will also scale pitch, independently of frequency, using a
transposition factor (k-rate).

  Syntax

asig, asig2 mp3scal Sfile,ktimescal,kpitch, kamp [,iskip,ifftsize, idecim, ilock]


===========================================================================
mpulse                                                               *mpulse*

  Description

Generates a set of impulses of amplitude kamp separated by kintvl
seconds (or samples if kintvl is negative). The first impulse is
generated after a delay of ioffset seconds.

  Syntax

ares mpulse kamp, kintvl [, ioffset]


===========================================================================
mrtmsg                                                               *mrtmsg*

  Description

Send system real-time messages to the MIDI OUT port.

  Syntax

mrtmsg imsgtype


===========================================================================
multitap                                                           *multitap*

  Description

Multitap delay line implementation.

  Syntax

ares multitap asig [, itime1, igain1] [, itime2, igain2] [...]


===========================================================================
mute                                                                   *mute*

  Description

Mutes/unmutes new instances of a given instrument.

  Syntax

mute insnum [, iswitch]

mute "insname" [, iswitch]


===========================================================================
mvchpf                                                               *mvchpf*

  Description

Mvchpf is an digital implementation of the 4th-order (24 dB/oct) Moog
high-pass filter, originally written by Fons Andriaensen. According to
the author, mvchpf "...is based on the voltage controlled highpass
filter by Robert Moog. again with some attention to the nonlinear effects."

  Syntax

asig mvchpf ain, xcf[, istor]


===========================================================================
mvclpf1                                                             *mvclpf1*

  Description

Mvclpf1 is an digital implementation of the 4th-order (24 dB/oct) Moog
ladder filter originally written by Fons Andriaensen. According to the
author, mvclpf1 "is a fairly simple design, and it does not even pretend
to come close the 'real thing'. It uses a very crude approximation of
the non-linear resistor in the first filter section only. [...] [I]t's
[a] cheap (in terms of CPU usage) general purpose 24 dB/oct lowpass
filter that could be useful".

  Syntax

asig mvclpf1 ain, xcf, xres[,istor]


===========================================================================
mvclpf2                                                             *mvclpf2*

  Description

Mvclpf2 is an digital implementation of the 4th-order (24 dB/oct) Moog
ladder filter originally written by Fons Andriaensen. According to the
author, mvclpf2 "uses five non-linear elements, in the input and in all
four filter sections. It works by using the derivative of the
nonlinearity (for which 1 / (1 + x * x) is reasonable approximation).
The main advantage of this is that only one evaluation of the non-linear
function is required for each section".

  Syntax

asig mvclpf2 ain, xcf, xres[, istor]


===========================================================================
mvclpf3                                                             *mvclpf3*

  Description

Mvclpf3 is an digital implementation of the 4th-order (24 dB/oct) Moog
ladder filter originally written by Fons Andriaensen. According to the
author, mvclpf3 "is based on mvclpf2 , with two differences. It uses the
the technique described by Stilson and Smith to extend the constant-Q
range, and the internal sample frequency is doubled, giving a better
approximation to the non-linear behaviour at high freqencies. This
version has high Q over the entire frequency range and will oscillate up
to above 10 kHz, while the two others show a decreasing Q at high
frequencies. Mvclpf3 is reasonably well tuned, and can be 'played' as a
VCO up to at least 5 kHz".

  Syntax

asig mvclpf3 ain, xcf, xres[, istor]


===========================================================================
mvclpf4                                                             *mvclpf4*

  Description

Mvclpf4 is an digital implementation of the 4th-order (24 dB/oct) Moog
ladder filter originally written by Fons Andriaensen. It is a version of
the mvclpf3 opcode with four outputs, for 6dB, 12dB, 18dB, and 24
dB/octave responses.

  Syntax

asig1,asig2,asig3,asig4 mvclpf4 ain, xcf, xres[, istor]


===========================================================================
mxadsr                                                               *mxadsr*

  Description

Calculates the classical ADSR envelope using the expsegr mechanism.

  Syntax

ares mxadsr iatt, idec, islev, irel [, idel] [, ireltim]

kres mxadsr iatt, idec, islev, irel [, idel] [, ireltim]


===========================================================================
nchnls                                                               *nchnls*

  Description

These statements are global value assignments, made at the beginning of
an orchestra, before any instrument block is defined. Their function is
to set certain reserved symbol variables that are required for
performance. Once set, these reserved symbols can be used in expressions
anywhere in the orchestra.

  Syntax

nchnls = iarg


===========================================================================
nchnls_hw                                                         *nchnls_hw*

  Description

Returns the maximum number of audio channels in the underlying hardware.
This does not necessarily correspond to the number of channels used by
Csound (set by nchnls and nchnls_i).

  Syntax

idacc,iadcc nchnls_hw


===========================================================================
nchnls_i                                                           *nchnls_i*

  Description

These statements are global value assignments, made at the beginning of
an orchestra, before any instrument block is defined. Their function is
to set certain reserved symbol variables that are required for
performance. Once set, these reserved symbols can be used in expressions
anywhere in the orchestra.

  Syntax

nchnls_i = iarg


===========================================================================
nestedap                                                           *nestedap*

  Description

Three different nested all-pass filters, useful for implementing reverbs.

  Syntax

ares nestedap asig, imode, imaxdel, idel1, igain1 [, idel2] [, igain2] \
      [, idel3] [, igain3] [, istor]


===========================================================================
nlfilt                                                               *nlfilt*

  Description

Implements the filter:

Y{n} =a Y{n-1} + b Y{n-2} + d Y^2{n-L} + X{n} - C 

described in Dobson and Fitch (ICMC'96)

  Syntax

ares nlfilt ain, ka, kb, kd, kC, kL


===========================================================================
nlfilt2                                                             *nlfilt2*

  Description

Implements the filter:

Y{n} =tanh(a Y{n-1} + b Y{n-2} + d Y^2{n-L} + X{n} - C)

described in Dobson and Fitch (ICMC'96) as modified by Risto Holopainen.

  Syntax

ares nlfilt2 ain, ka, kb, kd, kC, kL


===========================================================================
noise                                                                 *noise*

  Description

A white noise generator with an IIR lowpass filter.

  Syntax

ares noise xamp, kbeta


===========================================================================
noteoff                                                             *noteoff*

  Description

Send a noteoff message to the MIDI OUT port.

  Syntax

noteoff ichn, inum, ivel


===========================================================================
noteon                                                               *noteon*

  Description

Send a noteon message to the MIDI OUT port.

  Syntax

noteon ichn, inum, ivel


===========================================================================
noteondur2                                                       *noteondur2*

  Description

Sends a noteon and a noteoff MIDI message both with the same channel,
number and velocity.

  Syntax

noteondur2 ichn, inum, ivel, idur


===========================================================================
noteondur                                                         *noteondur*

  Description

Sends a noteon and a noteoff MIDI message both with the same channel,
number and velocity.

  Syntax

noteondur ichn, inum, ivel, idur


===========================================================================
notnum                                                               *notnum*

  Description

Get a note number from a MIDI event.

  Syntax

ival notnum


===========================================================================
nreverb                                                             *nreverb*

  Description

This is a reverberator consisting of 6 parallel comb-lowpass filters
being fed into a series of 5 allpass filters. nreverb replaces reverb2
(version 3.48) and so both opcodes are identical.

  Syntax

ares nreverb asig, ktime, khdif [, iskip] [,inumCombs] [, ifnCombs] \
      [, inumAlpas] [, ifnAlpas]


===========================================================================
nrpn                                                                   *nrpn*

  Description

Sends a NPRN (Non-Registered Parameter Number) message to the MIDI OUT
port each time one of the input arguments changes.

  Syntax

nrpn kchan, kparmnum, kparmvalue


===========================================================================
nsamp                                                                 *nsamp*

  Description

Returns the number of samples loaded into a stored function table number.

  Syntax

nsamp(x) (init-rate args only)


===========================================================================
nstance                                                             *nstance*

  Description

Schedules a new instrument nstance, returning a handle that can be used
later to refer directly to the running nstance. This opcode is similar
to schedule, but has the added facility of retrieving the nstance handle.

  Syntax

iHandle nstance insnum, iwhen, idur [, ip4] [, ip5] [...]

iHandle nstance "insname", iwhen, idur [, ip4] [, ip5] [...]


===========================================================================
nstrnum                                                             *nstrnum*

  Description

Returns the number of a named instrument.

  Syntax

insno nstrnum "name"


===========================================================================
ntrpol                                                               *ntrpol*

  Description

Calculates the weighted mean value (i.e. linear interpolation) of two
input signals

  Syntax

ares ntrpol asig1, asig2, kpoint [, imin] [, imax]

ires ntrpol isig1, isig2, ipoint [, imin] [, imax]

kres ntrpol ksig1, ksig2, kpoint [, imin] [, imax]


===========================================================================
octave                                                               *octave*

  Description

Calculates a factor to raise/lower a frequency by a given amount of
octaves.

  Syntax

octave(x)

This function works at a-rate, i-rate, and k-rate.


===========================================================================
octcps                                                               *octcps*

  Description

Converts a cycles-per-second value to octave-point-decimal.

  Syntax

octcps (cps)  (init- or control-rate args only)

where the argument within the parentheses may be a further expression.


===========================================================================
octmidi                                                             *octmidi*

  Description

Get the note number, in octave-point-decimal units, of the current MIDI
event.

  Syntax

ioct octmidi


===========================================================================
octmidib                                                           *octmidib*

  Description

Get the note number of the current MIDI event and modify it by the
current pitch-bend value, express it in octave-point-decimal.

  Syntax

ioct octmidib [irange]

koct octmidib [irange]


===========================================================================
octmidinn                                                         *octmidinn*

  Description

Converts a Midi note number value to octave-point-decimal.

  Syntax

octmidinn (MidiNoteNumber)  (init- or control-rate args only)

where the argument within the parentheses may be a further expression.


===========================================================================
octpch                                                               *octpch*

  Description

Converts a pitch-class value to octave-point-decimal.

  Syntax

octpch (pch)  (init- or control-rate args only)

where the argument within the parentheses may be a further expression.


===========================================================================
olabuffer                                                         *olabuffer*

  Description

olabuffer This opcode takes 1 dimensional k-rate arrays that contain
sequential frames of audio and sums them based on an overlap factor
resulting in an audio signal output. This is useful for frame based
audio processing such as spectral analysis/synthesis.

  Syntax

aout olabuffer kin, ioverlap


===========================================================================
opcode                                                               *opcode*

  Defining opcodes

The opcode and endop statements allow defining a new opcode that can be
used the same way as any of the built-in Csound opcodes. These opcode
blocks are very similar to instruments (and are, in fact, implemented as
special instruments), but cannot be called as a normal instrument e.g.
with the i statements.

A user-defined opcode block must precede the instrument (or other
opcode) from which it is used. But it is possible to call the opcode
from itself. This allows recursion of any depth that is limited only by
available memory. Additionally, there is an experimental feature that
allows running the opcode definition at a higher control rate than the
kr value specified in the orchestra header.

Similarly to instruments, the variables and labels of a user-defined
opcode block are local and cannot be accessed from the caller instrument
(and the opcode cannot access variables of the caller, either).

Some parameters are automatically copied at initialization, however:

  * all p-fields (including p1)

  * extra time (see also xtratim, linsegr, and related opcodes). This
    may affect the operation of linsegr/expsegr/linenr/envlpxr in the
    user-defined opcode block.

  * MIDI parameters, if there are any.

Also, the release flag (see the release opcode) is copied at performance
time.

Modifying the note duration in the opcode definition by assigning to p3,
or using ihold, turnoff, xtratim, linsegr, or similar opcodes will also
affect the caller instrument. Changes to MIDI controllers (for example
with ctrlinit) will also apply to the instrument from which the opcode
was called.

Use the setksmps opcode to set the local ksmps value.

The xin and xout opcodes copy variables to and from the opcode
definition, allowing communication with the calling instrument.

The types of input and output variables are defined by the parameters
intypes and outtypes.

  Tip

You can create UDOs which take no inputs or outputs by using 0 instead
of a string.

  Notes

  * xin and xout should be called only once, and xin should precede
    xout, otherwise an init error and deactivation of the current
    instrument may occur.

  * These opcodes actually run only at i-time. Performance time copying
    is done by the user opcode call. This means that skipping xin or
    xout with kgoto has no effect, while skipping with igoto affects
    both init and performance time operation.

  Syntax

opcode name, outtypes, intypes


===========================================================================
oscbnk                                                               *oscbnk*

  Description

This unit generator mixes the output of any number of oscillators. The
frequency, phase, and amplitude of each oscillator can be modulated by
two LFOs (all oscillators have a separate set of LFOs, with different
phase and frequency); additionally, the output of each oscillator can be
filtered through an optional parametric equalizer (also controlled by
the LFOs). This opcode is most useful for rendering ensemble (strings,
choir, etc.) instruments.

Although the LFOs run at k-rate, amplitude, phase and filter modulation
are interpolated internally, so it is possible (and recommended in most
cases) to use this unit at low (˜1000 Hz) control rates without audible
quality degradation.

The start phase and frequency of all oscillators and LFOs can be set by
a built-in seedable 31-bit random number generator, or specified
manually in a function table (GEN2).

  Syntax

ares oscbnk  kcps, kamd, kfmd, kpmd, iovrlap, iseed, kl1minf, kl1maxf, \
      kl2minf, kl2maxf, ilfomode, keqminf, keqmaxf, keqminl, keqmaxl, \
      keqminq, keqmaxq, ieqmode, kfn [, il1fn] [, il2fn] [, ieqffn]   \
      [, ieqlfn] [, ieqqfn] [, itabl] [, ioutfn]


===========================================================================
oscil1                                                               *oscil1*

  Description

Accesses table values by incremental sampling.

  Syntax

kres oscil1 idel, kamp, idur [, ifn]


===========================================================================
oscil1i                                                             *oscil1i*

  Description

Accesses table values by incremental sampling with linear interpolation.

  Syntax

kres oscil1i idel, kamp, idur [, ifn]


===========================================================================
oscil3                                                               *oscil3*

  Description

oscil3 reads table ifn sequentially and repeatedly at a frequency xcps.
The amplitude is scaled by xamp. Cubic interpolation is applied for
table look up from internal phase values.

  Syntax

ares oscil3 xamp, xcps [, ifn, iphs]

kres oscil3 kamp, kcps [, ifn, iphs]


===========================================================================
oscil                                                                 *oscil*

  Description

oscil reads table ifn sequentially and repeatedly at a frequency xcps.
The amplitude is scaled by xamp.

  Syntax

ares oscil xamp, xcps [, ifn, iphs]

kres oscil kamp, kcps [, ifn, iphs]


===========================================================================
oscili                                                               *oscili*

  Description

oscili reads table ifn sequentially and repeatedly at a frequency xcps.
The amplitude is scaled by xamp. Linear interpolation is applied for
table look up from internal phase values.

  Syntax

ares oscili xamp, xcps[, ifn, iphs]

kres oscili kamp, kcps[, ifn, iphs]


===========================================================================
oscilikt                                                           *oscilikt*

  Description

oscilikt is very similar to oscili, but allows changing the table number
at k-rate. It is slightly slower than oscili (especially with high
control rate), although also more accurate as it uses a 31-bit phase
accumulator, as opposed to the 24-bit one used by oscili.

  Syntax

ares oscilikt xamp, xcps, kfn [, iphs] [, istor]

kres oscilikt kamp, kcps, kfn [, iphs] [, istor]


===========================================================================
osciliktp                                                         *osciliktp*

  Description

osciliktp allows phase modulation (which is actually implemented as
k-rate frequency modulation, by differentiating phase input). The
disadvantage is that there is no amplitude control, and frequency can be
varied only at the control-rate. This opcode can be faster or slower
than oscilikt, depending on the control-rate.

  Syntax

ares osciliktp kcps, kfn, kphs [, istor]


===========================================================================
oscilikts                                                         *oscilikts*

  Description

oscilikts is the same as oscilikt. Except it has a sync input that can
be used to re-initialize the oscillator to a k-rate phase value. It is
slower than oscilikt and osciliktp.

  Syntax

ares oscilikts xamp, xcps, kfn, async, kphs [, istor]


===========================================================================
osciln                                                               *osciln*

  Description

Accesses table values at a user-defined frequency. This opcode can also
be written as oscilx.

  Syntax

ares osciln kamp, ifrq, ifn, itimes


===========================================================================
oscils                                                               *oscils*

  Description

Simple, fast sine oscillator, that uses only one multiply, and two add
operations to generate one sample of output, and does not require a
function table.

  Syntax

ares oscils iamp, icps, iphs [, iflg]


===========================================================================
oscilx                                                               *oscilx*

  Description

Same as the osciln opcode.

===========================================================================
OSCinit                                                             *OSCinit*

  Description

Starts a listening process, which can be used by OSClisten.

  Syntax

ihandle OSCinit iport


===========================================================================
OSClisten                                                         *OSClisten*

  Description

On each k-cycle looks to see if an OSC message has been send to a given
path of a given type.

  Syntax

kans OSClisten ihandle, idest, itype [, xdata1, xdata2, ...]


===========================================================================
OSCsend                                                             *OSCsend*

  Description

Uses the OSC protocol to send message to other OSC listening processes.

  Syntax

OSCsend kwhen, ihost, iport, idestination, itype [, xdata1, xdata2, ...]


===========================================================================
out32                                                                 *out32*

  Description

Writes 32-channel audio data to an external device or stream.

  Syntax

out32 asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8, asig10, \
      asig11, asig12, asig13, asig14, asig15, asig16, asig17, asig18, \
      asig19, asig20, asig21, asig22, asig23, asig24, asig25, asig26, \
      asig27, asig28, asig29, asig30, asig31, asig32


===========================================================================
out                                                                     *out*

  Description

Writes audio data to an external device or stream, either from audio
variables or from an audio array.

  Syntax

out asig1[, asig2,....]

out aarray


===========================================================================
outc                                                                   *outc*

  Description

Writes audio data with an arbitrary number of channels to an external
device or stream.

  Syntax

outc asig1 [, asig2] [...]


===========================================================================
outch                                                                 *outch*

  Description

Writes multi-channel audio data, with user-controllable channels, to an
external device or stream.

  Syntax

outch kchan1, asig1 [, kchan2] [, asig2] [...]


===========================================================================
outh                                                                   *outh*

  Description

Writes 6-channel audio data to an external device or stream.

  Syntax

outh asig1, asig2, asig3, asig4, asig5, asig6


===========================================================================
outiat                                                               *outiat*

  Description

Sends MIDI aftertouch messages at i-rate.

  Syntax

outiat ichn, ivalue, imin, imax


===========================================================================
outic14                                                             *outic14*

  Description

Sends 14-bit MIDI controller output at i-rate.

  Syntax

outic14 ichn, imsb, ilsb, ivalue, imin, imax


===========================================================================
outic                                                                 *outic*

  Description

Sends MIDI controller output at i-rate.

  Syntax

outic ichn, inum, ivalue, imin, imax


===========================================================================
outipat                                                             *outipat*

  Description

Sends polyphonic MIDI aftertouch messages at i-rate.

  Syntax

outipat ichn, inotenum, ivalue, imin, imax


===========================================================================
outipb                                                               *outipb*

  Description

Sends MIDI pitch-bend messages at i-rate.

  Syntax

outipb ichn, ivalue, imin, imax


===========================================================================
outipc                                                               *outipc*

  Description

Sends MIDI program change messages at i-rate

  Syntax

outipc ichn, iprog, imin, imax


===========================================================================
outkat                                                               *outkat*

  Description

Sends MIDI aftertouch messages at k-rate.

  Syntax

outkat kchn, kvalue, kmin, kmax


===========================================================================
outkc14                                                             *outkc14*

  Description

Sends 14-bit MIDI controller output at k-rate.

  Syntax

outkc14 kchn, kmsb, klsb, kvalue, kmin, kmax


===========================================================================
outkc                                                                 *outkc*

  Description

Sends MIDI controller messages at k-rate.

  Syntax

outkc kchn, knum, kvalue, kmin, kmax


===========================================================================
outkpat                                                             *outkpat*

  Description

Sends polyphonic MIDI aftertouch messages at k-rate.

  Syntax

outkpat kchn, knotenum, kvalue, kmin, kmax


===========================================================================
outkpb                                                               *outkpb*

  Description

Sends MIDI pitch-bend messages at k-rate.

  Syntax

outkpb kchn, kvalue, kmin, kmax


===========================================================================
outkpc                                                               *outkpc*

  Description

Sends MIDI program change messages at k-rate.

  Syntax

outkpc kchn, kprog, kmin, kmax


===========================================================================
outleta                                                             *outleta*

  Description

Sends an arate signal out from an instrument to a named port.

  Syntax

outleta Sname, asignal


===========================================================================
outletf                                                             *outletf*

  Description

Sends a frate signal (fsig) out from an instrument to a named port.

  Syntax

outletf Sname, fsignal


===========================================================================
outletk                                                             *outletk*

  Description

Sends a krate signal out from an instrument to a named port.

  Syntax

outletk Sname, ksignal


===========================================================================
outletkid                                                         *outletkid*

  Description

Sends a krate signal out from an instrument to a named port.

  Syntax

outletkid Sname, SinstanceID, ksignal


===========================================================================
outletv                                                             *outletv*

  Description

Sends an arate array signal out from an instrument to a named port.

  Syntax

outletv Sname, array


===========================================================================
outo                                                                   *outo*

  Description

Writes 8-channel audio data to an external device or stream.

  Syntax

outo asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8


===========================================================================
outq1                                                                 *outq1*

  Description

Writes samples to quad channel 1 of an external device or stream.

  Syntax

outq1 asig


===========================================================================
outq2                                                                 *outq2*

  Description

Writes samples to quad channel 2 of an external device or stream.

  Syntax

outq2 asig


===========================================================================
outq3                                                                 *outq3*

  Description

Writes samples to quad channel 3 of an external device or stream.

  Syntax

outq3 asig


===========================================================================
outq4                                                                 *outq4*

  Description

Writes samples to quad channel 4 of an external device or stream.

  Syntax

outq4 asig


===========================================================================
outq                                                                   *outq*

  Description

Writes 4-channel audio data to an external device or stream.

  Syntax

outq asig1, asig2, asig3, asig4


===========================================================================
outrg                                                                 *outrg*

  Description

outrg outputs audio to a range of adjacent audio channels on the audio
output device.

  Syntax

outrg kstart, aout1 [,aout2, aout3, ..., aoutN]


===========================================================================
outs1                                                                 *outs1*

  Description

Writes samples to stereo channel 1 of an external device or stream.

  Syntax

outs1 asig


===========================================================================
outs2                                                                 *outs2*

  Description

Writes samples to stereo channel 2 of an external device or stream.

  Syntax

outs2 asig


===========================================================================
outs                                                                   *outs*

  Description

Writes stereo audio data to an external device or stream.

  Syntax

outs asig1, asig2


===========================================================================
outvalue                                                           *outvalue*

  Description

Sends an irate or k-rate signal or string to a user-defined channel.

  Syntax

outvalue "channel name", ivalue

outvalue "channel name", kvalue

outvalue "channel name", "string"


===========================================================================
outx                                                                   *outx*

  Description

Writes 16-channel audio data to an external device or stream.

  Syntax

outx asig1, asig2, asig3, asig4, asig5, asig6, asig7, asig8, \
      asig9, asig10, asig11, asig12, asig13, asig14, asig15, asig16


===========================================================================
outz                                                                   *outz*

  Description

Writes multi-channel audio data from a ZAK array to an external device
or stream.

  Syntax

outz ksig1


===========================================================================
p5gconnect                                                       *p5gconnect*

  Description

Opens and at control-rate polls a P5 Glove controller.

  Syntax

p5gconnect


===========================================================================
p5gdata                                                             *p5gdata*

  Description

Reads data fields from a P5 Glove controller.

  Syntax

kres p5gdata kcontrol


===========================================================================
p                                                                         *p*

  Description

Show the value in a given p-field.

  Syntax

p(x) 

This function works at i-rate and k-rate.


===========================================================================
pan2                                                                   *pan2*

  Description

Distribute an audio signal across two channels with a choice of methods.

  Syntax

a1, a2 pan2 asig, xp [, imode]


===========================================================================
pan                                                                     *pan*

  Description

Distribute an audio signal amongst four channels with localization control.

  Syntax

a1, a2, a3, a4 pan asig, kx, ky, ifn [, imode] [, ioffset]


===========================================================================
pareq                                                                 *pareq*

  Description

Implementation of Zoelzer's parametric equalizer filters, with some
modifications by the author.

The formula for the low shelf filter is:

omega = 2*pi*f/sr
K     = tan(omega/2)

b0    = 1 + sqrt(2*V)*K + V*K^2
b1    = 2*(V*K^2 - 1)
b2    = 1 - sqrt(2*V)*K + V*K^2

a0    = 1 + K/Q + K^2
a1    = 2*(K^2 - 1)
a2    = 1 - K/Q + K^2

The formula for the high shelf filter is:

omega = 2*pi*f/sr
K     = tan((pi-omega)/2)

b0    = 1 + sqrt(2*V)*K + V*K^2
b1    = -2*(V*K^2 - 1)
b1    = 1 - sqrt(2*V)*K + V*K^2

a0    = 1 + K/Q + K^2
a1    = -2*(K^2 - 1)
a2    = 1 - K/Q + K^2

The formula for the peaking filter is:

omega = 2*pi*f/sr
K     = tan(omega/2)

b0 =  1 + V*K/2 + K^2
b1 =  2*(K^2 - 1)
b2 =  1 - V*K/2 + K^2

a0 =  1 + K/Q + K^2
a1 =  2*(K^2 - 1)
a2 =  1 - K/Q + K^2

  Syntax

ares pareq asig, kc, kv, kq [, imode] [, iskip]


===========================================================================
partials                                                           *partials*

  Description

The partials opcode takes two input PV streaming signals containg
AMP_FREQ and AMP_PHASE signals (as generated for instance by pvsifd or
in the first case, by pvsanal) and performs partial track analysis, as
described in Lazzarini et al, "Time-stretching using the Instantaneous
Frequency Distribution and Partial Tracking", Proc.of ICMC05, Barcelona.
It generates a TRACKS PV streaming signal, containing amplitude,
frequency, phase and track ID for each output track. This type of signal
will contain a variable number of output tracks, up to the total number
of analysis bins contained in the inputs (fftsize/2 + 1 bins). The
second input (AMP_PHASE) is optional, as it can take the same signal as
the first input. In this case, however, all phase information will be
NULL and resynthesis using phase information cannot be performed.

  Syntax

ftrks partials ffr, fphs, kthresh, kminpts, kmaxgap, imaxtracks


===========================================================================
partikkel                                                         *partikkel*

  Description

partikkel was conceived after reading Curtis Roads' book "Microsound",
and the goal was to create an opcode that was capable of all time-domain
varieties of granular synthesis described in this book. The idea being
that most of the techniques only differ in parameter values, and by
having a single opcode that can do all varieties of granular synthesis
makes it possible to interpolate between techniques. Granular synthesis
is sometimes dubbed particle synthesis, and it was thought apt to name
the opcode partikkel to distinguish it from other granular opcodes.

Some of the input parameters to partikkel is table numbers, pointing to
tables where values for the "per grain" parameter changes are stored.
partikkel can use single-cycle or complex (e.g. sampled sound) waveforms
as source waveforms for grains. Each grain consists of a mix of 4 source
waveforms. Individual tuning of the base frequency can be done for each
of the 4 source waveforms. Frequency modulation inside each grain is
enabled via an auxillary audio input (awavfm). Trainlet synthesis is
available, and trainlets can be mixed with wavetable based grains. Up to
8 separate audio outputs can be used.

  Syntax

a1 [, a2, a3, a4, a5, a6, a7, a8] partikkel agrainfreq, \
              kdistribution, idisttab, async, kenv2amt, ienv2tab, ienv_attack, \
              ienv_decay, ksustain_amount, ka_d_ratio, kduration, kamp, igainmasks, \
              kwavfreq, ksweepshape, iwavfreqstarttab, iwavfreqendtab, awavfm, \
              ifmamptab, kfmenv, icosine, ktraincps, knumpartials, kchroma, \
              ichannelmasks, krandommask, kwaveform1, kwaveform2, kwaveform3, \
              kwaveform4, iwaveamptab, asamplepos1, asamplepos2, asamplepos3, \
              asamplepos4, kwavekey1, kwavekey2, kwavekey3, kwavekey4, imax_grains \
              [, iopcode_id]


===========================================================================
partikkelsync                                                 *partikkelsync*

  Description

partikkelsync is an opcode for outputting partikkel's grain scheduler
clock pulse and phase. partikkelsync's output can be used to synchronize
other instances of the partikkel opcode to the same clock.

  Syntax

async [,aphase] partikkelsync iopcode_id


===========================================================================
passign                                                             *passign*

  Description

Assigns a range of p-fields to ivariables.

  Syntax

 ivar1, ... passign [istart]


===========================================================================
paulstretch                                                     *paulstretch*

  Description

The paulstretch opcode is a lightweight implementation of the
PaulStretch time-stretching algorithm by Nasca Octavian Paul. It is
ideal for timestretching a signal by very large amounts.

The Paulstretch algorithm works very similarly to other STFT-based
timestretching methods, using overlap-add with a hanning window. Unique
to paulstretch are the use of scrambled phase and very large window
sizes (specified in seconds).

  Syntax

asig paulstretch istretch, iwindowsize, ift


===========================================================================
pcauchy                                                             *pcauchy*

  Description

Cauchy distribution random number generator (positive values only). This
is an x-class noise generator.

  Syntax

ares pcauchy kalpha

ires pcauchy kalpha

kres pcauchy kalpha


===========================================================================
pchbend                                                             *pchbend*

  Description

Get the current pitch-bend value for this channel.

  Syntax

ibend pchbend [imin] [, imax]

kbend pchbend [imin] [, imax]


===========================================================================
pchmidi                                                             *pchmidi*

  Description

Get the note number of the current MIDI event, expressed in pitch-class
units.

  Syntax

ipch pchmidi


===========================================================================
pchmidib                                                           *pchmidib*

  Description

Get the note number of the current MIDI event and modify it by the
current pitch-bend value, express it in pitch-class units.

  Syntax

ipch pchmidib [irange]

kpch pchmidib [irange]


===========================================================================
pchmidinn                                                         *pchmidinn*

  Description

Converts a Midi note number value to octave point pitch-class units.

  Syntax

pchmidinn (MidiNoteNumber)  (init- or control-rate args only)

where the argument within the parentheses may be a further expression.


===========================================================================
pchoct                                                               *pchoct*

  Description

Converts an octave-point-decimal value to pitch-class.

  Syntax

pchoct (oct)  (init- or control-rate args only)

where the argument within the parentheses may be a further expression.


===========================================================================
pconvolve                                                         *pconvolve*

  Description

Convolution based on a uniformly partitioned overlap-save algorithm.
Compared to the convolve opcode, pconvolve has these benefits:

  * small delay

  * possible to run in real-time for shorter impulse files

  * no pre-process analysis pass

  * can often render faster than convolve

  Syntax

ar1 [, ar2] [, ar3] [, ar4] pconvolve ain, ifilcod [, ipartitionsize, ichannel]


===========================================================================
pcount                                                               *pcount*

  Description

pcount returns the number of pfields belonging to a note event.

  Syntax

icount pcount


===========================================================================
pdclip                                                               *pdclip*

  Description

The pdclip opcode allows a percentage of the input range of a signal to
be clipped to fullscale. It is similar to simply multiplying the signal
and limiting the range of the result, but pdclip allows you to think
about how much of the signal range is being distorted instead of the
scalar factor and has a offset parameter for assymetric clipping of the
signal range. pdclip is also useful for remapping phasors for phase
distortion synthesis.

  Syntax

aout pdclip ain, kWidth, kCenter [, ibipolar [, ifullscale]]


===========================================================================
pdhalf                                                               *pdhalf*

  Description

The pdhalf opcode is designed to emulate the "classic" phase distortion
synthesis method of the Casio CZ-series of synthesizers from the
mid-1980's. This technique reads the first and second halves of a
function table at different rates in order to warp the waveform. For
example, pdhalf can smoothly transform a sine wave into something
approximating the shape of a saw wave.

  Syntax

aout pdhalf ain, kShapeAmount [, ibipolar [, ifullscale]]


===========================================================================
pdhalfy                                                             *pdhalfy*

  Description

The pdhalfy opcode is a variation on the phase distortion synthesis
method of the pdhalf opcode. It is useful for distorting a phasor in
order to read two unequal portions of a table in the same number of
samples.

  Syntax

aout pdhalfy ain, kShapeAmount [, ibipolar [, ifullscale]]


===========================================================================
peak                                                                   *peak*

  Description

These opcodes maintain the output k-rate variable as the peak absolute
level so far received.

  Syntax

kres peak asig

kres peak ksig


===========================================================================
pgmassign                                                         *pgmassign*

  Description

Assigns an instrument number to a specified (or all) MIDI program(s).

By default, the instrument is the same as the program number. If the
selected instrument is zero or negative or does not exist, the program
change is ignored. This opcode is normally used in the orchestra header.
Although, like massign, it also works in instruments.

  Syntax

pgmassign ipgm, inst[, ichn]

pgmassign ipgm, "insname"[, ichn]


===========================================================================
phaser1                                                             *phaser1*

  Description

An implementation of iord number of first-order allpass filters in series.

  Syntax

ares phaser1 asig, kfreq, kord, kfeedback [, iskip]


===========================================================================
phaser2                                                             *phaser2*

  Description

An implementation of iord number of second-order allpass filters in series.

  Syntax

ares phaser2 asig, kfreq, kq, kord, kmode, ksep, kfeedback


===========================================================================
phasor                                                               *phasor*

  Description

Produce a normalized moving phase value.

  Syntax

ares phasor xcps [, iphs]

kres phasor kcps [, iphs]


===========================================================================
phasorbnk                                                         *phasorbnk*

  Description

Produce an arbitrary number of normalized moving phase values,
accessable by an index.

  Syntax

ares phasorbnk xcps, kndx, icnt [, iphs]

kres phasorbnk kcps, kndx, icnt [, iphs]


===========================================================================
phs                                                                     *phs*

  Description

This opcode returns the phases of a complex-number array, as a
real-valued array with half the size of its input plus one. The reason
for the extra point is to keep the array size equivalent to the output
of the mags opcode (which is often used alongside this one).

  Syntax

kout[] phs kin[]


===========================================================================
pindex                                                               *pindex*

  Description

pindex returns the value of a specified pfield.

  Syntax

ivalue pindex ipfieldIndex


===========================================================================
pinker                                                               *pinker*

  Description

Generates pink noise (-3dB/oct response) by the New Shade of Pink
algorithm of Stefan Stenzel.

  Syntax

ares pinker


===========================================================================
pinkish                                                             *pinkish*

  Description

Generates approximate pink noise (-3dB/oct response) by one of two
different methods:

  * a multirate noise generator after Moore, coded by Martin Gardner

  * a filter bank designed by Paul Kellet

  Syntax

ares pinkish xin [, imethod] [, inumbands] [, iseed] [, iskip]


===========================================================================
pitch                                                                 *pitch*

  Description

Using the same techniques as spectrum and specptrk, pitch tracks the
pitch of the signal in octave point decimal form, and amplitude in dB.

  Syntax

koct, kamp pitch asig, iupdte, ilo, ihi, idbthresh [, ifrqs] [, iconf] \
      [, istrt] [, iocts] [, iq] [, inptls] [, irolloff] [, iskip]


===========================================================================
pitchamdf                                                         *pitchamdf*

  Description

Follows the pitch of a signal based on the AMDF method (Average
Magnitude Difference Function). Outputs pitch and amplitude tracking
signals. The method is quite fast and should run in realtime. This
technique usually works best for monophonic signals.

  Syntax

kcps, krms pitchamdf asig, imincps, imaxcps [, icps] [, imedi] \
      [, idowns] [, iexcps] [, irmsmedi]


===========================================================================
planet                                                               *planet*

  Description

planet simulates a planet orbiting in a binary star system. The outputs
are the x, y and z coordinates of the orbiting planet. It is possible
for the planet to achieve escape velocity by a close encounter with a
star. This makes this system somewhat unstable.

  Syntax

ax, ay, az planet kmass1, kmass2, ksep, ix, iy, iz, ivx, ivy, ivz, idelta \
      [, ifriction] [, iskip]


===========================================================================
platerev                                                           *platerev*

  Description

Models the reverberation of a rectangular metal plate with settable
physical characteristics when excited by audio signal(s).

  Syntax

a1[, a2, ...] platerev itabexcite. itabouts, kbndry, iaspect, istiff, idecay, iloss, aexcite1[, aexcite2, ...]


===========================================================================
plltrack                                                           *plltrack*

  Description

plltrack, a pitch tracker based on a phase-locked loop algorithm,
described in Zolzer, U, Sankarababu, S.V. and Moller, S, "PLL-based
Pitch Detection and Tracking for Audio Signals. Proc. of IIH-MSP 2012".

  Syntax

acps, alock plltrack asig, kd [, kloopf, kloopq, klf, khf, kthresh]


===========================================================================
pluck                                                                 *pluck*

  Description

Audio output is a naturally decaying plucked string or drum sound based
on the Karplus-Strong algorithms.

  Syntax

ares pluck kamp, kcps, icps, ifn, imeth [, iparm1] [, iparm2]


===========================================================================
poisson                                                             *poisson*

  Description

Poisson distribution random number generator (positive values only).
This is an x-class noise generator.

  Syntax

ares poisson klambda

ires poisson klambda

kres poisson klambda


===========================================================================
pol2rect                                                           *pol2rect*

  Description

Converts an input array in magnitude-phase format to real-imaginary format.

  Syntax

kout[] pol2rect kin[]

kout[] pol2rect kmags[], kphs[]


===========================================================================
polyaft                                                             *polyaft*

  Description

polyaft returns the polyphonic pressure of the selected note number,
optionally mapped to an user-specified range.

  Syntax

ires polyaft inote [, ilow] [, ihigh]

kres polyaft inote [, ilow] [, ihigh]


===========================================================================
polynomial                                                       *polynomial*

  Description

The polynomial opcode calculates a polynomial with a single a-rate input
variable. The polynomial is a sum of any number of terms in the form
kn*x^n where kn is the nth coefficient of the expression. These
coefficients are k-rate values.

  Syntax

aout polynomial ain, k0 [, k1 [, k2 [...]]]


===========================================================================
port                                                                   *port*

  Description

Applies portamento to a step-valued control signal.

  Syntax

kres port ksig, ihtim [, isig]


===========================================================================
portk                                                                 *portk*

  Description

Applies portamento to a step-valued control signal.

  Syntax

kres portk ksig, khtim [, isig]


===========================================================================
poscil3                                                             *poscil3*

  Description

High precision oscillator with cubic interpolation.

  Syntax

ares poscil3 aamp, acps [, ifn, iphs]

ares poscil3 aamp, kcps [, ifn, iphs]

ares poscil3 kamp, acps [, ifn, iphs]

ares poscil3 kamp, kcps [, ifn, iphs]

ires poscil3 kamp, kcps [, ifn, iphs]

kres poscil3 kamp, kcps [, ifn, iphs]


===========================================================================
poscil                                                               *poscil*

  Description

High precision oscillator.

  Syntax

ares poscil aamp, acps [, ifn, iphs]

ares poscil aamp, kcps [, ifn, iphs]

ares poscil kamp, acps [, ifn, iphs]

ares poscil kamp, kcps [, ifn, iphs]

ires poscil kamp, kcps [, ifn, iphs]

kres poscil kamp, kcps [, ifn, iphs]


===========================================================================
pow                                                                     *pow*

  Description

Computes xarg to the power of kpow (or ipow) and scales the result by
inorm.

  Syntax

ares pow aarg, kpow [, inorm]

ires pow iarg, ipow [, inorm]

kres pow karg, kpow [, inorm]


===========================================================================
powershape                                                       *powershape*

  Description

The powershape opcode raises an input signal to a power with pre- and
post-scaling of the signal so that the output will be in a predictable
range. It also processes negative inputs in a symmetrical way to
positive inputs, calculating a dynamic transfer function that is useful
for waveshaping.

  Syntax

aout powershape ain, kShapeAmount [, ifullscale]


===========================================================================
powoftwo                                                           *powoftwo*

  Description

Performs a power-of-two calculation.

  Syntax

powoftwo(x)  (init-rate or control-rate args only)


===========================================================================
prealloc                                                           *prealloc*

  Description

Creates space for instruments but does not run them.

  Syntax

prealloc insnum, icount

prealloc "insname", icount


===========================================================================
prepiano                                                           *prepiano*

  Description

Audio output is a tone similar to a piano string, prepared with a number
of rubbers and rattles. The method uses a physical model developed from
solving the partial differential equation.

  Syntax

ares prepiano ifreq, iNS, iD, iK, \
    iT30,iB, kbcl, kbcr, imass, ihvfreq, iinit, ipos, ivel, isfreq, \
    isspread[, irattles, irubbers]

al,ar prepiano ifreq, iNS, iD, iK, \
    iT30,iB, kbcl, kbcr, imass, ihvfreq, iinit, ipos, ivel, isfreq, \
    isspread[, irattles, irubbers]


===========================================================================
print                                                                 *print*

  Description

These units will print orchestra init-values.

  Syntax

print iarg [, iarg1] [, iarg2] [...]


===========================================================================
printf                                                               *printf*

  Description

printf and printf_i write formatted output, similarly to the C function
printf(). printf_i runs at i-time only, while printf runs both at
initialization and performance time.

  Syntax

printf_i Sfmt, itrig, [iarg1[, iarg2[, ... ]]]

printf Sfmt, ktrig, [xarg1[, xarg2[, ... ]]]


===========================================================================
printk2                                                             *printk2*

  Description

Prints a new value every time a control variable changes.

  Syntax

printk2 kvar [, inumspaces]


===========================================================================
printk                                                               *printk*

  Description

Prints one k-rate value at specified intervals.

  Syntax

printk itime, kval [, ispace]


===========================================================================
printks                                                             *printks*

  Description

Prints at k-rate using a printf() style syntax.

  Syntax

printks "string", itime [, kval1] [, kval2] [...]


===========================================================================
printks2                                                           *printks2*

  Description

Prints a new value every time a control variable changes using a
printf() style syntax.

  Syntax

printks2 "string", kval


===========================================================================
prints                                                               *prints*

  Description

Prints at init-time using a printf() style syntax.

  Syntax

prints "string" [, kval1] [, kval2] [...]


===========================================================================
product                                                             *product*

  Description

Multiplies any number of a-rate signals.

  Syntax

ares product asig1, asig2 [, asig3] [...]


===========================================================================
pset                                                                   *pset*

  Description

Defines and initializes numeric arrays at orchestra load time.

  Syntax

pset icon1 [, icon2] [...]


===========================================================================
ptable                                                               *ptable*

  Description

Accesses table values by direct indexing.

  Syntax

ares ptable andx, ifn [, ixmode] [, ixoff] [, iwrap]

ires ptable indx, ifn [, ixmode] [, ixoff] [, iwrap]

kres ptable kndx, ifn [, ixmode] [, ixoff] [, iwrap]


===========================================================================
ptablei                                                             *ptablei*

  Description

Accesses table values by direct indexing with linear interpolation.

  Syntax

ares ptablei andx, ifn [, ixmode] [, ixoff] [, iwrap]

ires ptablei indx, ifn [, ixmode] [, ixoff] [, iwrap]

kres ptablei kndx, ifn [, ixmode] [, ixoff] [, iwrap]


===========================================================================
ptable3                                                             *ptable3*

  Description

Accesses table values by direct indexing with cubic interpolation.

  Syntax

ares ptable3 andx, ifn [, ixmode] [, ixoff] [, iwrap]

ires ptable3 indx, ifn [, ixmode] [, ixoff] [, iwrap]

kres ptable3 kndx, ifn [, ixmode] [, ixoff] [, iwrap]


===========================================================================
ptablew                                                             *ptablew*

  Description

This opcode operates on existing function tables, changing their
contents. ptablew is for writing at k- or at a-rates, with the table
number being specified at init time. Using ptablew with i-rate signal
and index values is allowed, but the specified data will always be
written to the function table at k-rate, not during the initialization
pass. The valid combinations of variable types are shown by the first
letter of the variable names.

  Syntax

ptablew asig, andx, ifn [, ixmode] [, ixoff] [, iwgmode]

ptablew isig, indx, ifn [, ixmode] [, ixoff] [, iwgmode]

ptablew ksig, kndx, ifn [, ixmode] [, ixoff] [, iwgmode]


===========================================================================
ptrack                                                               *ptrack*

  Description

ptrack takes an input signal, splits it into ihopsize blocks and using a
STFT method, extracts an estimated pitch for its fundamental frequency
as well as estimating the total amplitude of the signal in dB, relative
to full-scale (0dB). The method implies an analysis window size of
2*ihopsize samples (overlaping by 1/2 window), which has to be a
power-of-two, between 128 and 8192 (hopsizes between 64 and 4096).
Smaller windows will give better time precision, but worse frequency
accuracy (esp. in low fundamentals).This opcode is based on an original
algorithm by M. Puckette.

  Syntax

kcps, kamp ptrack asig, ihopsize[,ipeaks]


===========================================================================
puts                                                                   *puts*

  Description

puts prints a string with an optional newline at the end whenever the
trigger signal is positive and changes.

  Syntax

puts Sstr, ktrig[, inonl]


===========================================================================
pvadd                                                                 *pvadd*

  Description

pvadd reads from a pvoc file and uses the data to perform additive
synthesis using an internal array of interpolating oscillators. The user
supplies the wave table (usually one period of a sine wave), and can
choose which analysis bins will be used in the re-synthesis.

  Syntax

ares pvadd ktimpnt, kfmod, ifilcod, ifn, ibins [, ibinoffset] \
      [, ibinincr] [, iextractmode] [, ifreqlim] [, igatefn]


===========================================================================
pvbufread                                                         *pvbufread*

  Description

pvbufread reads from a pvoc file and makes the retrieved data available
to any following pvinterp and pvcross units that appear in an instrument
before a subsequent pvbufread (just as lpread and lpreson work
together). The data is passed internally and the unit has no output of
its own.

  Syntax

pvbufread ktimpnt, ifile


===========================================================================
pvcross                                                             *pvcross*

  Description

pvcross applies the amplitudes from one phase vocoder analysis file to
the data from a second file and then performs the resynthesis. The data
is passed, as described above, from a previously called pvbufread unit.
The two k-rate amplitude arguments are used to scale the amplitudes of
each files separately before they are added together and used in the
resynthesis (see below for further explanation). The frequencies of the
first file are not used at all in this process. This unit simply allows
for cross-synthesis through the application of the amplitudes of the
spectra of one signal to the frequencies of a second signal. Unlike
pvinterp, pvcross does allow for the use of the ispecwp as in pvoc and
vpvoc.

  Syntax

ares pvcross ktimpnt, kfmod, ifile, kampscale1, kampscale2 [, ispecwp]


===========================================================================
pvinterp                                                           *pvinterp*

  Description

pvinterp interpolates between the amplitudes and frequencies, on a bin
by bin basis, of two phase vocoder analysis files (one from a previously
called pvbufread unit and the other from within its own argument list),
allowing for user defined transitions between analyzed sounds. It also
allows for general scaling of the amplitudes and frequencies of each
file separately before the interpolated values are calculated and sent
to the resynthesis routines. The kfmod argument in pvinterp performs its
frequency scaling on the frequency values after their derivation from
the separate scaling and subsequent interpolation is performed so that
this acts as an overall scaling value of the new frequency components.

  Syntax

ares pvinterp ktimpnt, kfmod, ifile, kfreqscale1, kfreqscale2, \
      kampscale1, kampscale2, kfreqinterp, kampinterp


===========================================================================
pvoc                                                                   *pvoc*

  Description

Implements signal reconstruction using an fft-based phase vocoder.

  Syntax

ares pvoc ktimpnt, kfmod, ifilcod [, ispecwp] [, iextractmode] \
      [, ifreqlim] [, igatefn]


===========================================================================
pvread                                                               *pvread*

  Description

pvread reads from a pvoc file and returns the frequency and amplitude
from a single analysis channel or bin. The returned values can be used
anywhere else in the Csound instrument. For example, one can use them as
arguments to an oscillator to synthesize a single component from an
analyzed signal or a bank of pvreads can be used to resynthesize the
analyzed sound using additive synthesis by passing the frequency and
magnitude values to a bank of oscillators.

  Syntax

kfreq, kamp pvread ktimpnt, ifile, ibin


===========================================================================
pvsadsyn                                                           *pvsadsyn*

  Description

Resynthesize using a fast oscillator-bank.

  Syntax

ares pvsadsyn fsrc, inoscs, kfmod [, ibinoffset] [, ibinincr] [, iinit]


===========================================================================
pvsanal                                                             *pvsanal*

  Description

Generate an fsig from a mono audio source ain, using phase vocoder
overlap-add analysis.

  Syntax

fsig pvsanal ain, ifftsize, ioverlap, iwinsize, iwintype [, iformat] [, iinit]


===========================================================================
pvsarp                                                               *pvsarp*

  Description

This opcode arpeggiates spectral components, by amplifying one bin and
attenuating all the others around it. Used with an LFO it will provide a
spectral arpeggiator similar to Trevor Wishart's CDP program specarp.

  Syntax

fsig pvsarp fsigin, kbin, kdepth, kgain


===========================================================================
pvsbandp                                                           *pvsbandp*

  Description

Filter the pvoc frames, passing bins whose frequency is within a band,
and with linear interpolation for transitional bands.

  Syntax

fsig pvsbandp fsigin, xlowcut, xlowfull, \
      xhighfull, xhighcut[, ktype]


===========================================================================
pvsbandr                                                           *pvsbandr*

  Description

Filter the pvoc frames, rejecting bins whose frequency is within a band,
and with linear interpolation for transitional bands.

  Syntax

fsig pvsbandr fsigin, xlowcut, xlowfull, \
      xhighfull, xhighcut[, ktype]


===========================================================================
pvsbin                                                               *pvsbin*

  Description

Obtain the amp and freq values off a PVS signal bin as k-rate variables.

  Syntax

kamp, kfr pvsbin fsig, kbin


===========================================================================
pvsblur                                                             *pvsblur*

  Description

Average the amp/freq time functions of each analysis channel for a
specified time (truncated to number of frames). As a side-effect the
input pvoc stream will be delayed by that amount.

  Syntax

fsig pvsblur fsigin, kblurtime, imaxdel


===========================================================================
pvsbuffer                                                         *pvsbuffer*

  Description

This opcode sets up and writes to a circular buffer of length ilen
(secs), giving a handle for the buffer and a time pointer, which holds
the current write position (also in seconds). It can be used with one or
more pvsbufread opcodes. Writing is circular, wrapping around at the end
of the buffer.

  Syntax

ihandle, ktime  pvsbuffer fsig, ilen 


===========================================================================
pvsbufread                                                       *pvsbufread*

  Description

This opcode reads from a circular buffer of length ilen (secs), taking a
handle for the buffer and a time pointer, which holds the current read
position (also in seconds). It is used in conjunction with a pvsbuffer
opocde. Reading is circular, wrapping around at the end of the buffer.

  Syntax

fsig pvsbufread  ktime, khandle[, ilo, ihi, iclear] 


===========================================================================
pvsbufread2                                                     *pvsbufread2*

  Description

This opcode reads from a circular buffer of length ilen (secs), taking a
handle for the buffer and a time pointer, which holds the current read
position (also in seconds). It is used in conjunction with a pvsbuffer
opocde. Reading is circular, wrapping around at the end of the buffer.
Extra delay times are taken from a function table, with each point on it
defining a delay time in seconds affecting the corresponding bin.

  Syntax

fsig pvsbufread2  ktime, khandle, ift1, ift2 


===========================================================================
pvscale                                                             *pvscale*

  Description

Scale the frequency components of a pv stream, resulting in pitch shift.
Output amplitudes can be optionally modified in order to attempt formant
preservation.

  Syntax

fsig pvscale fsigin, kscal[, kkeepform, kgain, kcoefs]


===========================================================================
pvscent                                                             *pvscent*

  Description

Calculate the spectral centroid of a signal from its discrete Fourier
transform.

  Syntax

kcent pvscent fsig


===========================================================================
pvsceps                                                             *pvsceps*

  Description

  Syntax

keps[] pvsceps fsig[, icoefs]


===========================================================================
pvscross                                                           *pvscross*

  Description

Performs cross-synthesis between two source fsigs.

  Syntax

fsig pvscross fsrc, fdest, kamp1, kamp2


===========================================================================
pvsdemix                                                           *pvsdemix*

  Description

Spectral azimuth-based de-mixing of stereo sources, with a
reverse-panning result. This opcode implements the Azimuth
Discrimination and Resynthesis (ADRess) algorithm, developed by Dan
Barry (Barry et Al. "Sound Source Separation Azimuth Discrimination and
Resynthesis". DAFx'04, Univ. of Napoli). The source separation, or
de-mixing, is controlled by two parameters: an azimuth position (kpos)
and a subspace width (kwidth). The first one is used to locate the
spectral peaks of individual sources on a stereo mix, whereas the second
widens the 'search space', including/exclufing the peaks around kpos.
These two parameters can be used interactively to extract source sounds
from a stereo mix. The algorithm is particularly successful with studio
recordings where individual instruments occupy individual panning
positions; it is, in fact, a reverse-panning algorithm.

  Warning

It is unsafe to use the same f-variable for both input and output of pvs
opcodes. Using the same one might lead to undefined behavior on some
opcodes. Use a different one on the left and right sides of the opcode.

  Syntax

fsig pvsdemix fleft, fright, kpos, kwidth, ipoints


===========================================================================
pvsdiskin                                                         *pvsdiskin*

  Description

Create an fsig stream by reading a selected channel from a PVOC-EX
analysis file, with frame interpolation.

  Syntax

fsig pvsdiskin SFname,ktscal,kgain[,ioffset, ichan]


===========================================================================
pvsdisp                                                             *pvsdisp*

  Description

This opcode will display a PVS signal fsig. Uses X11 or FLTK windows if
enabled, else (or if -g flag is set) displays are approximated in ASCII
characters.

  Syntax

pvsdisp fsig[, ibins, iwtflg] 


===========================================================================
pvsfilter                                                         *pvsfilter*

  Description

Multiply amplitudes of a pvoc stream by those of a second pvoc stream,
with dynamic scaling.

  Syntax

fsig pvsfilter fsigin, fsigfil, kdepth[, igain]


===========================================================================
pvsfread                                                           *pvsfread*

  Description

Create an fsig stream by reading a selected channel from a PVOC-EX
analysis file loaded into memory, with frame interpolation. Only format
0 files (amplitude+frequency) are currently supported. The operation of
this opcode mirrors that of pvoc, but outputs an fsig instead of a
resynthesized signal.

  Syntax

fsig pvsfread ktimpt, ifn [, ichan]


===========================================================================
pvsfreeze                                                         *pvsfreeze*

  Description

This opcodes 'freezes' the evolution of pvs stream by locking into
steady amplitude and/or frequency values for each bin. The freezing is
controlled, independently for amplitudes and frequencies, by a
control-rate trigger, which switches the freezing 'on' if equal to or
above 1 and 'off' if below 1.

  Syntax

fsig pvsfreeze fsigin, kfreeza, kfreezf


===========================================================================
pvsftr                                                               *pvsftr*

  Description

Reads amplitude and/or frequency data from function tables.

  Syntax

pvsftr fsrc, ifna [, ifnf]


===========================================================================
pvsftw                                                               *pvsftw*

  Description

Writes amplitude and/or frequency data to function tables.

  Syntax

kflag pvsftw fsrc, ifna [, ifnf]


===========================================================================
pvsfwrite                                                         *pvsfwrite*

  Description

This opcode writes a fsig to a PVOCEX file (which in turn can be read by
pvsfread or other programs that support PVOCEX file input).

  Syntax

pvsfwrite fsig, ifile


===========================================================================
pvsgain                                                             *pvsgain*

  Description

Scale the amplitude of a pv stream.

  Syntax

fsig pvsgain fsigin, kgain 


===========================================================================
pvshift                                                             *pvshift*

  Description

Shift the frequency components of a pv stream, stretching/compressing
its spectrum.

  Syntax

fsig pvshift fsigin, kshift, klowest[, kkeepform, igain, kcoefs]


===========================================================================
pvsifd                                                               *pvsifd*

  Description

The pvsifd opcode takes an input a-rate signal and performs an
Instantaneous Frequency, magnitude and phase analysis, using the STFT
and pvsifd (Instantaneous Frequency Distribution), as described in
Lazzarini et al, "Time-stretching using the Instantaneous Frequency
Distribution and Partial Tracking", Proc.of ICMC05, Barcelona. It
generates two PV streaming signals, one containing the amplitudes and
frequencies (a similar output to pvsanal) and another containing
amplitudes and unwrapped phases.

  Syntax

ffr,fphs pvsifd ain, ifftsize, ihopsize, iwintype[,iscal]


===========================================================================
pvsinfo                                                             *pvsinfo*

  Description

Get format information about fsrc, whether created by an opcode such as
pvsanal, or obtained from a PVOCEX file by pvsfread. This information is
available at init time, and can be used to set parameters for other pvs
opcodes, and in particular for creating function tables (e.g. for
pvsftw), or setting the number of oscillators for pvsadsyn.

  Syntax

ioverlap, inumbins, iwinsize, iformat pvsinfo fsrc


===========================================================================
pvsinit                                                             *pvsinit*

  Description

Performs the equivalent to an init operation on an f-variable.

  Syntax

fsig pvsinit isize[, iolap, iwinsize, iwintype, iformat]


===========================================================================
pvsin                                                                 *pvsin*

  Description

This opcode retrieves an f-sig from the pvs in software bus, which can
be used to get data from an external source, using the Csound 5 API. A
channel is created if not already existing. The fsig channel is in that
case initialised with the given parameters. It is important to note that
the pvs input and output (pvsout opcode) busses are independent and data
is not shared between them.

  Syntax

fsig pvsin kchan[, isize, iolap, iwinsize, iwintype, iformat]


===========================================================================
pvslock                                                             *pvslock*

  Description

This opcode searches for spectral peaks and then locks the frequencies
around those peaks. This is similar to phase-locking in non-streaming PV
processing. It can be used to improve timestretching and pitch-shifting
quality in PV processing.

  Syntax

fsig pvslock fsigin, klock


===========================================================================
pvsmaska                                                           *pvsmaska*

  Description

Modify amplitudes of fsrc using function table, with dynamic scaling.

  Syntax

fsig pvsmaska fsrc, ifn, kdepth


===========================================================================
pvsmix                                                               *pvsmix*

  Description

Mix 'seamlessly' two pv signals. This opcode combines the most prominent
components of two pvoc streams into a single mixed stream.

  Syntax

fsig pvsmix fsigin1, fsigin2


===========================================================================
pvsmorph                                                           *pvsmorph*

  Description

Performs morphing (or interpolation) between two source fsigs.

  Syntax

fsig pvsmorph fsig1, fsig2, kampint, kfrqint


===========================================================================
pvsmooth                                                           *pvsmooth*

  Description

Smooth the amplitude and frequency time functions of a pv stream using a
1st order lowpass IIR with time-varying cutoff frequency. This opcode
uses the same filter as the tone opcode, but this time acting separately
on the amplitude and frequency time functions that make up a pv stream.
The cutoff frequency parameter runs at the control-rate, but unlike tone
and tonek, it is not specified in Hz, but as fractions of 1/2 frame-rate
(actually the pv stream sampling rate), which is easier to understand.
This means that the highest cutoff frequency is 1 and the lowest 0; the
lower the frequency the smoother the functions and more pronounced the
effect will be.

These are filters applied to control signals so the effect is basically
blurring the spectral evolution. The effects produced are more or less
similar to pvsblur, but with two important differences: 1.smoothing of
amplitudes and frequencies use separate sets of filters; and 2. there is
no increase in computational cost when higher amounts of 'blurring'
(smoothing) are desired.

  Syntax

fsig pvsmooth fsigin, kacf, kfcf


===========================================================================
pvsout                                                               *pvsout*

  Description

This opcode writes a fsig to a channel of the pvs output bus. Note that
the pvs out bus and the pvs in bus are separate and independent. A new
channel is created if non-existent.

  Syntax

pvsout fsig, kchan


===========================================================================
pvsosc                                                               *pvsosc*

  Description

Generates periodic signal spectra in AMP-FREQ format, with the option of
four wave types:

 1. sawtooth-like (harmonic weight 1/n, where n is partial number)
 2. square-like (similar to 1., but only odd partials)
 3. pulse (all harmonics with same weight)
 4. cosine

Complex waveforms (ie. all types except cosine) contain all harmonics up
to the Nyquist. This makes pvsosc an option for generation of
band-limited periodic waves. In addition, types can be changed using a
k-rate variable.

  Syntax

fsig pvsosc kamp, kfreq, ktype, isize [,ioverlap] [, iwinsize] [, iwintype] [, iformat]


===========================================================================
pvspitch                                                           *pvspitch*

  Description

Track the pitch and amplitude of a PVS signal as k-rate variables.

  Syntax

kfr, kamp pvspitch fsig, kthresh


===========================================================================
pvstanal                                                           *pvstanal*

  Description

pvstanal implements phase vocoder analysis by reading function tables
containing sampled-sound sources, with GEN01, and pvstanal will accept
deferred allocation tables.

This opcode allows for time and frequency-independent scaling. Time is
advanced internally, but controlled by a tempo scaling parameter; when
an onset is detected, timescaling is momentarily stopped to avoid
smearing of attacks. The quality of the effect is generally improved
with phase locking switched on.

pvstanal will also scale pitch, independently of frequency, using a
transposition factor (k-rate).

  Syntax

fsig pvstanal ktimescal, kamp, kpitch, ktab, [kdetect, kwrap, ioffset,ifftsize, ihop, idbthresh]


===========================================================================
pvstencil                                                         *pvstencil*

  Description

Transforms a pvoc stream according to a masking function table; if the
pvoc stream amplitude falls below the value of the function for a
specific pvoc channel, it applies a gain to that channel.

The pvoc stream amplitudes are compared to a masking table, if the fall
below the table values, they are scaled by kgain. Prior to the
operation, table values are scaled by klevel, which can be used as
masking depth control.

Tables have to be at least fftsize/2 in size; for most GENS it is
important to use an extended-guard point (size power-of-two plus one),
however this is not necessary with GEN43.

One of the typical uses of pvstencil would be in noise reduction. A
noise print can be analysed with pvanal into a PVOC-EX file and loaded
in a table with GEN43. This then can be used as the masking table for
pvstencil and the amount of reduction would be controlled by kgain.
Skipping post-normalisation will keep the original noise print average
amplitudes. This would provide a good starting point for a successful
noise reduction (so that klevel can be generally set to close to 1).

Other possible transformation effects are possible, such as filtering
and `inverse-masking'.

  Syntax

fsig pvstencil fsigin, kgain, klevel, iftable


===========================================================================
pvsvoc                                                               *pvsvoc*

  Description

This opcode provides support for cross-synthesis of amplitudes and
frequencies. It takes the amplitudes of one input fsig and combines with
frequencies from another. It is a spectral version of the well-known
channel vocoder.

  Syntax

fsig pvsvoc famp, fexc, kdepth, kgain [,kcoefs]


===========================================================================
pvsynth                                                             *pvsynth*

  Description

Resynthesise phase vocoder data (f-signal) using a FFT overlap-add.

  Syntax

ares pvsynth fsrc, [iinit]


===========================================================================
pvswarp                                                             *pvswarp*

  Description

Warp the spectral envelope of a PVS signal by means of shifting and
scaling.

  Syntax

fsig pvswarp fsigin, kscal, kshift[, klowest, kmeth, kgain, kcoefs]


===========================================================================
pvs2tab                                                             *pvs2tab*

  Description

Copies a pvs frame to a t-variable. Currently only AMP+FREQ and
AMP+PHASE formats allowed. Since t-vars are an earlier version of k-rate
arrays, the opcode also works with these. The opcode pvs2array is an
alias of this one.

  Syntax

kframe pvs2tab tvar|kvar[], fsig


===========================================================================
pyassign Opcodes                                                   *pyassign*

  Syntax

pyassign "variable", kvalue

pyassigni "variable", ivalue

pylassign "variable", kvalue

pylassigni "variable", ivalue

pyassignt ktrigger, "variable", kvalue

pylassignt ktrigger, "variable", kvalue

  Description

Assign the value of the given Csound variable to a Python variable
possibly destroying its previous content. The resulting Python object
will be a float.


===========================================================================
pycall Opcodes                                                       *pycall*

  Syntax

                                        pycall   "callable", karg1, ...

kresult                                 pycall1  "callable", karg1, ...

kresult1, kresult2                      pycall2  "callable", karg1, ...

kr1, kr2, kr3                           pycall3  "callable", karg1, ...

kr1, kr2, kr3, kr4                      pycall4  "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5                 pycall5  "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6            pycall6  "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6, kr7       pycall7  "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6, kr7, kr8  pycall8  "callable", karg1, ...

                                        pycallt   ktrigger, "callable", karg1, ...

kresult                                 pycall1t  ktrigger, "callable", karg1, ...

kresult1, kresult2                      pycall2t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3                           pycall3t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3, kr4                      pycall4t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5                 pycall5t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6            pycall6t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6, kr7       pycall7t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6, kr7, kr8  pycall8t  ktrigger, "callable", karg1, ...

                                        pycalli   "callable", karg1, ...

iresult                                 pycall1i  "callable", iarg1, ...

iresult1, iresult2                      pycall2i  "callable", iarg1, ...

ir1, ir2, ir3                           pycall3i  "callable", iarg1, ...

ir1, ir2, ir3, ir4                      pycall4i  "callable", iarg1, ...

ir1, ir2, ir3, ir4, ir5                 pycall5i  "callable", iarg1, ...

ir1, ir2, ir3, ir4, ir5, ir6            pycall6i  "callable", iarg1, ...

ir1, ir2, ir3, ir4, ir5, ir6, ir7       pycall7i  "callable", iarg1, ...

ir1, ir2, ir3, ir4, ir5, ir6, ir7, ir8  pycall8i  "callable", iarg1, ...

pycalln   "callable", nresults, kresult1, ..., kresultn, karg1, ...

pycallni  "callable", nresults, iresult1, ..., iresultn, iarg1,  ...

                                        pylcall   "callable", karg1, ...

kresult                                 pylcall1  "callable", karg1, ...

kresult1, kresult2                      pylcall2  "callable", karg1, ...

kr1, kr2, kr3                           pylcall3  "callable", karg1, ...

kr1, kr2, kr3, kr4                      pylcall4  "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5                 pylcall5  "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6            pylcall6  "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6, kr7       pylcall7  "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6, kr7, kr8  pylcall8   "callable", karg1, ...

                                        pylcallt   ktrigger, "callable", karg1, ...

kresult                                 pylcall1t  ktrigger, "callable", karg1, ...

kresult1, kresult2                      pylcall2t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3                           pylcall3t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3, kr4                      pylcall4t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5                 pylcall5t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6            pylcall6t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6, kr7       pylcall7t  ktrigger, "callable", karg1, ...

kr1, kr2, kr3, kr4, kr5, kr6, kr7, kr8  pylcall8t  ktrigger, "callable", karg1, ...

                                        pylcalli   "callable", karg1, ...

iresult                                 pylcall1i  "callable", iarg1, ...

iresult1, iresult2                      pylcall2i  "callable", iarg1, ...

ir1, ir2, ir3                           pylcall3i  "callable", iarg1, ...

ir1, ir2, ir3, ir4                      pylcall4i  "callable", iarg1, ...

ir1, ir2, ir3, ir4, ir5                 pylcall5i  "callable", iarg1, ...

ir1, ir2, ir3, ir4, ir5, ir6            pylcall6i  "callable", iarg1, ...

ir1, ir2, ir3, ir4, ir5, ir6, ir7       pylcall7i  "callable", iarg1, ...

ir1, ir2, ir3, ir4, ir5, ir6, ir7, ir8  pylcall8i  "callable", iarg1, ...

pylcalln   "callable", nresults, kresult1, ..., kresultn, karg1, ...

pylcallni  "callable", nresults, iresult1, ..., iresultn, iarg1, ...

  Description

This family of opcodes call the specified Python callable at k-time and
i-time (i suffix), passing the given arguments. The call is perfomed in
the global environment and the result (the returning value) is copied
into the Csound output variables specified.

They pass any number of parameters which are cast to float inside the
Python interpreter.

The pycall/pycalli, pycall1/pycall1i ... pycall8/pycall8i opcodes can
accomodate for a number of results ranging from 0 to 8 according to
their numerical prefix (0 is omitted).

The pycalln/pycallni opcodes can accomodate for any number of results:
the callable name is followed by the number of output arguments, then
come the list of Csound output variable and the list of parameters to be
passed.

The returning value of the callable must be |None| for pycall or
pycalli, a float for pycall1i or pycall1i and a tuple (with proper size)
of floats for the pycall2/pycall2i ... pycall8/pycall8i and
pycalln/pycallni opcodes.


===========================================================================
pyeval Opcodes                                                       *pyeval*

  Syntax

kresult pyeval "expression"

iresult pyevali "expression"

kresult pyleval "expression"

iresult pylevali "expression"

kresult pyevalt ktrigger, "expression"

kresult pylevalt ktrigger, "expression"

  Description

These opcodes evaluate a generic Python expression and store the result
in a Csound variable at k-time or i-time (i suffix).

The expression must evaluate in a float or an object that can be cast to
a float.

They can be used effectively to trasfer data from a Python object into a
Csound variable.


===========================================================================
pyexec Opcodes                                                       *pyexec*

  Syntax

pyexec "filename"

pyexeci "filename"

pylexec "filename"

pylexeci "filename"

pyexect ktrigger, "filename"

plyexect ktrigger, "filename"

  Description

Execute a script from a file at k-time or i-time (i suffix).

This is not the same as calling the script with the |system()| call,
since the code is executed by the embedded interpreter.

The code contained in the specified file is executed in the global
environment for opcodes pyexec and pyexeci and in the private
environment for the opcodes pylexec and pylexeci.

These opcodes perform no message passing. However, since the statement
has access to the main namespace and the private namespace, it can
interact with objects previously created in that environment.

The "local" version of the pyexec opcodes are useful when the code ran
by different instances of an instrument should not interact.


===========================================================================
pyinit Opcodes                                                       *pyinit*

  Syntax

pyinit

  Description

In Csound, you must first invoke the pyinit opcode in the orchestra
header to initialize the Python interpreter, before using any of the
other Python opcodes.

But if you use the Python opcodes within CsoundAC, or from a python
frontend using the csnd6 module, Csound, you need not invoke pyinit,
because the Python interpreter will have already been initialized. In
this case, CsoundAC (or the csnd6 python module) automatically creates a
Python interface to the Csound API. In CsoundAC, this exists in the form
a global instance of the |CsoundAC.CppSound| class named |csound|. From
a python frontend which imports the csnd6 module, the name of the
variable holding the Csound instance will depend on the frontend code.
Therefore, Python code written in the Csound orchestra has access to the
global |csound| object.

The running Csound instance in which pyinit has been called is stored in
a global python variable called _CSOUND_. This holds the actual memory
address of the instance and it can be used with the csnd6 module via the
csoundGetInstance(instance) call. This python function returns an object
that can be used with all the Csound API functions.


===========================================================================
pyrun Opcodes                                                         *pyrun*

  Syntax

pyrun "statement"

pyruni "statement"

pylrun "statement"

pylruni "statement"

pyrunt ktrigger, "statement"

pylrunt ktrigger, "statement"

  Description

Execute the specified Python statement at k-time (pyrun and pylrun) or
i-time (pyruni and pylruni).

The statement is executed in the global environment for pyrun and pyruni
or the local environment for pylrun and pylruni.

These opcodes perform no message passing. However, since the statement
have access to the main namespace and the private namespace, it can
interact with objects previously created in that environment.

The "local" version of the pyrun opcodes are useful when the code ran by
different instances of an instrument should not interact.


===========================================================================
pwd                                                                     *pwd*

  Description

pwd call the operating system to determine the current directory
(folder). pwd runs at i-time only.

  Syntax

Sres pwd


===========================================================================
qinf                                                                   *qinf*

  Description

Returns the number of times the argument is not a number, with the sign
of the first infinity.

  Syntax

qinf(x) (no rate restriction)


===========================================================================
qnan                                                                   *qnan*

  Description

Returns the number of times the argument is not a number.

  Syntax

qnan(x) (no rate restriction)


===========================================================================
r2c                                                                     *r2c*

  Description

Converts a real-valued input array in real-imaginary interleaved complex
format, setting its imaginary parts to 0. The output array will be
double the size of the input. This is a utility operation to facilitate
complex-value operations on real arrays.

  Syntax

kout[] r2c kin[]


===========================================================================
rand                                                                   *rand*

  Description

Output is a controlled random number series between -amp and +amp

  Syntax

ares rand xamp [, iseed] [, isel] [, ioffset]

kres rand xamp [, iseed] [, isel] [, ioffset]


===========================================================================
randh                                                                 *randh*

  Description

Generates random numbers and holds them for a period of time.

  Syntax

ares randh xamp, xcps [, iseed] [, isize] [, ioffset]

kres randh kamp, kcps [, iseed] [, isize] [, ioffset]


===========================================================================
randi                                                                 *randi*

  Description

Generates a controlled random number series with interpolation between
each new number.

  Syntax

ares randi xamp, xcps [, iseed] [, isize] [, ioffset]

kres randi kamp, kcps [, iseed] [, isize] [, ioffset]


===========================================================================
random                                                               *random*

  Description

Generates is a controlled pseudo-random number series between min and
max values.

  Syntax

ares random kmin, kmax

ires random imin, imax

kres random kmin, kmax


===========================================================================
randomh                                                             *randomh*

  Description

Generates random numbers with a user-defined limit and holds them for a
period of time.

  Syntax

ares randomh kmin, kmax, xcps [,imode] [,ifirstval]

kres randomh kmin, kmax, kcps [,imode] [,ifirstval]


===========================================================================
randomi                                                             *randomi*

  Description

Generates a user-controlled random number series with interpolation
between each new number.

  Syntax

ares randomi kmin, kmax, xcps [,imode] [,ifirstval]

kres randomi kmin, kmax, kcps [,imode] [,ifirstval]


===========================================================================
rbjeq                                                                 *rbjeq*

  Description

Parametric equalizer and filter opcode with 7 filter types, based on
algorithm by Robert Bristow-Johnson.

  Syntax

ar rbjeq asig, kfco, klvl, kQ, kS[, imode]


===========================================================================
readclock                                                         *readclock*

  Description

Reads the value of an internal clock.

  Syntax

ir readclock inum


===========================================================================
readf                                                                 *readf*

  Description

Read a line of text from an external file once each k-cycle.

  Syntax

Sres, kline readf ifilname


===========================================================================
readfi                                                               *readfi*

  Description

Read a line of text from an external file once on initialisation.

  Syntax

Sres, iline readfi ifilname


===========================================================================
readk                                                                 *readk*

  Description

Periodically reads an orchestra control-signal value from a named
external file in a specific format.

  Syntax

kres readk ifilname, iformat, iprd


===========================================================================
readk2                                                               *readk2*

  Description

Periodically reads two orchestra control-signal values from an external
file.

  Syntax

kr1, kr2 readk2 ifilname, iformat, iprd


===========================================================================
readk3                                                               *readk3*

  Description

Periodically reads three orchestra control-signal values from an
external file.

  Syntax

kr1, kr2, kr3 readk3 ifilname, iformat, iprd


===========================================================================
readk4                                                               *readk4*

  Description

Periodically reads four orchestra control-signal values from an external
file.

  Syntax

kr1, kr2, kr3, kr4 readk4 ifilname, iformat, iprd


===========================================================================
readscore                                                         *readscore*

  Description

Readscore will issue one or more score events. It can handle strings in
the same conditions as the standard score, including preprocessing
(carry, sort, ramp, etc). Multi-line strings are accepted, using {{ }}
to enclose the string.

  Syntax

readscore Sin 


===========================================================================
readscratch                                                     *readscratch*

  Description

The readscratch opcode returns one of four scalar values stored in the
instance of an instrument.

  Syntax

ival readscratch[index]


===========================================================================
rect2pol                                                           *rect2pol*

  Description

Converts an input array in real-imaginary format to magnitude-phase format.

  Syntax

kout[] rect2pol kin[]


===========================================================================
reinit                                                               *reinit*

  Description

Suspends a performance while a special initialization pass is executed.

Whenever this statement is encountered during a p-time pass, performance
is temporarily suspended while a special Initialization pass, beginning
at label and continuing to rireturn or endin, is executed. Performance
will then be resumed from where it left off.

  Syntax

reinit label


===========================================================================
release                                                             *release*

  Description

Provides a way of knowing when a note off message for the current note
is received. Only a noteoff message with the same MIDI note number as
the one which triggered the note will be reported by release.

  Syntax

kflag release


===========================================================================
remoteport                                                       *remoteport*

  Description

Defines the port for use with the insremot, midremot, insglobal and
midglobal opcodes.

  Syntax

remoteport iportnum


===========================================================================
remove                                                               *remove*

  Description

Removes the definition of an instrument as long as it is not in use.

  Syntax

remove insnum


===========================================================================
repluck                                                             *repluck*

  Description

repluck is an implementation of the physical model of the plucked
string. A user can control the pluck point, the pickup point, the
filter, and an additional audio signal, axcite. axcite is used to excite
the 'string'. Based on the Karplus-Strong algorithm.

  Syntax

ares repluck iplk, kamp, icps, kpick, krefl, axcite


===========================================================================
reson                                                                 *reson*

  Description

A second-order resonant filter.

  Syntax

ares reson asig, xcf, xbw [, iscl] [, iskip]


===========================================================================
resonk                                                               *resonk*

  Description

A second-order resonant filter.

  Syntax

kres resonk ksig, kcf, kbw [, iscl] [, iskip]


===========================================================================
resonr                                                               *resonr*

  Description

Implementations of a second-order, two-pole two-zero bandpass filter
with variable frequency response.

  Syntax

ares resonr asig, xcf, xbw [, iscl] [, iskip]


===========================================================================
resonx                                                               *resonx*

  Description

resonx is equivalent to a filters consisting of more layers of reson
with the same arguments, serially connected. Using a stack of a larger
number of filters allows a sharper cutoff. They are faster than using a
larger number instances in a Csound orchestra of the old opcodes,
because only one initialization and k- cycle are needed at time and the
audio loop falls entirely inside the cache memory of processor.

  Syntax

ares resonx asig, xcf, xbw [, inumlayer] [, iscl] [, iskip]


===========================================================================
resonxk                                                             *resonxk*

  Description

resonxk is equivalent to a group of resonk filters, with the same
arguments, serially connected. Using a stack of a larger number of
filters allows a sharper cutoff.

  Syntax

kres resonxk ksig, kcf, kbw[, inumlayer, iscl, istor]


===========================================================================
resony                                                               *resony*

  Description

A bank of second-order bandpass filters, connected in parallel.

  Syntax

ares resony asig, kbf, kbw, inum, ksep [, isepmode] [, iscl] [, iskip]


===========================================================================
resonz                                                               *resonz*

  Description

Implementations of a second-order, two-pole two-zero bandpass filter
with variable frequency response.

  Syntax

ares resonz asig, xcf, xbw [, iscl] [, iskip]


===========================================================================
resyn                                                                 *resyn*

  Description

The resyn opcode takes an input containg a TRACKS pv streaming signal
(as generated, for instance by partials). It resynthesises the signal
using linear amplitude and cubic phase interpolation to drive a bank of
interpolating oscillators with amplitude and pitch scaling controls.
Resyn is a modified version of sinsyn, allowing for the resynthesis of
data with pitch and timescale changes.

  Syntax

asig resyn fin, kscal, kpitch, kmaxtracks, ifn


===========================================================================
return                                                               *return*

  Description

Return will return a value from an instrument at i-time. The value of a
global instrument (instrument 0) can be retrieved after compilation by
the evalstr opcode. The retrieval of values returned by other
instruments is not yet implemented.

  Syntax

return ival 


===========================================================================
reverb                                                               *reverb*

  Description

Reverberates an input signal with a “natural room” frequency response.

  Syntax

ares reverb asig, krvt [, iskip]


===========================================================================
reverb2                                                             *reverb2*

  Description

Same as the nreverb opcode.

  Syntax

ares reverb2 asig, ktime, khdif [, iskip] [,inumCombs] \
      [, ifnCombs] [, inumAlpas] [, ifnAlpas]

===========================================================================
reverbsc                                                           *reverbsc*

  Description

8 delay line stereo FDN reverb, with feedback matrix based upon physical
modeling scattering junction of 8 lossless waveguides of equal
characteristic impedance. Based on Csound orchestra version by Sean
Costello.

  Syntax

aoutL, aoutR reverbsc ainL, ainR, kfblvl, kfco[, israte[, ipitchm[, iskip]]] 


===========================================================================
rewindscore                                                     *rewindscore*

  Description

Rewinds the playback position of the current score performance..

  Syntax

 rewindscore


===========================================================================
rezzy                                                                 *rezzy*

  Description

A resonant low-pass filter.

  Syntax

ares rezzy asig, xfco, xres [, imode, iskip]


===========================================================================
rfft                                                                   *rfft*

  Description

Applies a forward Fast Fourier Transform to a real-value input
1-dimensional array. The output is another array containing the
transform, non-redundant, non-negative spectrum only. If the input array
is power-of-two, the output array size will match the input size, with
the first two points containing 0Hz and Nyquist frequency coefficients.
Otherwise, the output will have two extra values (input size + 2), and
the the Nyquist coefficient will be placed at kin[input_size] position
(kin[1] and kin[input_size+1] will be 0].

  Syntax

kout[] rfft kin[]


===========================================================================
rifft                                                                 *rifft*

  Description

Applies an Inverse Fast Fourier Transform to a complex-value input
1-dimensional array producing a real-valued output. The output is
another array containing the real-valued signal. If the input array is
power-of-two, the output array size will match the input size.
Otherwise, the output will have two fewer values (input size - 2).

  Syntax

kout[] rifft kin[]


===========================================================================
rigoto                                                               *rigoto*

  Description

Similar to igoto, but effective only during a reinit pass (i.e., no-op
at standard i-time). This statement is useful for bypassing units that
are not to be reinitialized.

  Syntax

rigoto label


===========================================================================
rireturn                                                           *rireturn*

  Description

Terminates a reinit pass (i.e., no-op at standard i-time). This
statement, or an endin, will cause normal performance to be resumed.

  Syntax

rireturn


===========================================================================
rms                                                                     *rms*

  Description

Determines the root-mean-square amplitude of an audio signal. It
low-pass filters the actual value, to average in the manner of a VU meter.

  Syntax

kres rms asig [, ihp] [, iskip]


===========================================================================
rnd                                                                     *rnd*

  Description

Returns a random number in a unipolar range at the rate given by the
input argument.

  Syntax

rnd(x) (init- or control-rate only)

Where the argument within the parentheses may be an expression. These
value converters sample a global random sequence, but do not reference
seed. The result can be a term in a further expression.


===========================================================================
rnd31                                                                 *rnd31*

  Description

31-bit bipolar random opcodes with controllable distribution. These
units are portable, i.e. using the same seed value will generate the
same random sequence on all systems. The distribution of generated
random numbers can be varied at k-rate.

  Syntax

ax rnd31 kscl, krpow [, iseed]

ix rnd31 iscl, irpow [, iseed]

kx rnd31 kscl, krpow [, iseed]


===========================================================================
round                                                                 *round*

  Description

The integer value nearest to x ; if the fractional part of x is exactly
0.5, the direction of rounding is undefined.

  Syntax

round(x) (init-, control-, or audio-rate arg allowed)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
rspline                                                             *rspline*

  Description

Generate random spline curves.

  Syntax

ares rspline xrangeMin, xrangeMax, kcpsMin, kcpsMax

kres rspline krangeMin, krangeMax, kcpsMin, kcpsMax


===========================================================================
rtclock                                                             *rtclock*

  Description

Read the real-time clock from the operating system.

  Syntax

ires rtclock

kres rtclock


===========================================================================
S                                                                         *S*

  Description

Returns a string containg the numeric value of its argument.

  Syntax

S(x) (control-rate or init-rate arg)


===========================================================================
s16b14                                                               *s16b14*

  Description

Creates a bank of 16 different 14-bit MIDI control message numbers.

  Syntax

i1,...,i16 s16b14 ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \
      initvalue1, ifn1,..., ictlno_msb16, ictlno_lsb16, imin16, imax16, initvalue16, ifn16

k1,...,k16 s16b14 ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \
      initvalue1, ifn1,..., ictlno_msb16, ictlno_lsb16, imin16, imax16, initvalue16, ifn16


===========================================================================
s32b14                                                               *s32b14*

  Description

Creates a bank of 32 different 14-bit MIDI control message numbers.

  Syntax

i1,...,i32 s32b14 ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \
      initvalue1, ifn1,..., ictlno_msb32, ictlno_lsb32, imin32, imax32, initvalue32, ifn32

k1,...,k32 s32b14 ichan, ictlno_msb1, ictlno_lsb1, imin1, imax1, \
      initvalue1, ifn1,..., ictlno_msb32, ictlno_lsb32, imin32, imax32, initvalue32, ifn32


===========================================================================
samphold                                                           *samphold*

  Description

Performs a sample-and-hold operation on its input.

  Syntax

ares samphold asig, agate [, ival] [, ivstor]

kres samphold ksig, kgate [, ival] [, ivstor]


===========================================================================
sandpaper                                                         *sandpaper*

  Description

sandpaper is a semi-physical model of a sandpaper sound. It is one of
the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic
Event Modeling) is an algorithmic approach for simulating collisions of
multiple independent sound producing objects.

  Syntax

ares sandpaper iamp, idettack [, inum] [, idamp] [, imaxshake]


===========================================================================
scale                                                                 *scale*

  Description

Scales incoming value to user-definable range. Similar to scale object
found in popular dataflow languages.

  Syntax

kscl scale kinput, kmax, kmin


===========================================================================
scalearray                                                       *scalearray*

  Description

The scalearray opcode scales a subregion of a vector to a given
minimum/maximum.

  Syntax

scalearray tarray, kmin, kmax[, kleft, kright]


===========================================================================
scanhammer                                                       *scanhammer*

  Description

This is is a variant of tablecopy, copying from one table to another,
starting at ipos, and with a gain control. The number of points copied
is determined by the length of the source. Other points are not changed.
This opcode can be used to “hit” a string in the scanned synthesis code.

  Syntax

scanhammer isrc, idst, ipos, imult


===========================================================================
scans                                                                 *scans*

  Description

Generate audio output using scanned synthesis.

  Syntax

ares scans kamp, kfreq, ifn, id [, iorder]


===========================================================================
scantable                                                         *scantable*

  Description

A simpler scanned synthesis implementation. This is an implementation of
a circular string scanned using external tables. This opcode will allow
direct modification and reading of values with the table opcodes.

  Syntax

aout scantable kamp, kpch, ipos, imass, istiff, idamp, ivel


===========================================================================
scanu                                                                 *scanu*

  Description

Compute the waveform and the wavetable for use in scanned synthesis.

  Syntax

scanu init, irate, ifnvel, ifnmass, ifnstif, ifncentr, ifndamp, kmass, \
      kstif, kcentr, kdamp, ileft, iright, kpos, kstrngth, ain, idisp, id


===========================================================================
schedkwhen                                                       *schedkwhen*

  Description

Adds a new score event generated by a k-rate trigger.

  Syntax

schedkwhen ktrigger, kmintim, kmaxnum, kinsnum, kwhen, kdur \
      [, ip4] [, ip5] [...]

schedkwhen ktrigger, kmintim, kmaxnum, "insname", kwhen, kdur \
      [, ip4] [, ip5] [...]


===========================================================================
schedkwhennamed                                             *schedkwhennamed*

  Description

Similar to schedkwhen but uses a named instrument at init-time.

  Syntax

schedkwhennamed ktrigger, kmintim, kmaxnum, "name", kwhen, kdur \
      [, ip4] [, ip5] [...]


===========================================================================
schedule                                                           *schedule*

  Description

Adds a new score event.

  Syntax

schedule insnum, iwhen, idur [, ip4] [, ip5] [...]

schedule "insname", iwhen, idur [, ip4] [, ip5] [...]


===========================================================================
schedwhen                                                         *schedwhen*

  Description

Adds a new score event.

  Syntax

schedwhen ktrigger, kinsnum, kwhen, kdur [, ip4] [, ip5] [...]

schedwhen ktrigger, "insname", kwhen, kdur [, ip4] [, ip5] [...]


===========================================================================
scoreline                                                         *scoreline*

  Description

Scoreline will issue one or more score events, if ktrig is 1 every
k-period. It can handle strings in the same conditions as the standard
score. Multi-line strings are accepted, using {{ }} to enclose the string.

  Syntax

scoreline Sin, ktrig


===========================================================================
scoreline_i                                                     *scoreline_i*

  Description

scoreline_i will issue score events at i-time. It can handle strings in
the same conditions as the standard score. Multi-line strings are
accepted, using {{ }} to enclose the string.

  Syntax

scoreline_i Sin


===========================================================================
seed                                                                   *seed*

  Description

Sets the global seed value for all x-class noise generators, as well as
other opcodes that use a random call, such as grain.

  Please Note

rand, randh, randi, rnd(x) and birnd(x) are not affected by seed.

  Syntax

seed ival


===========================================================================
sekere                                                               *sekere*

  Description

sekere is a semi-physical model of a sekere sound. It is one of the
PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic Event
Modeling) is an algorithmic approach for simulating collisions of
multiple independent sound producing objects.

  Syntax

ares sekere iamp, idettack [, inum] [, idamp] [, imaxshake]


===========================================================================
semitone                                                           *semitone*

  Description

Calculates a factor to raise/lower a frequency by a given amount of
semitones.

  Syntax

semitone(x)

This function works at a-rate, i-rate, and k-rate.


===========================================================================
sense                                                                 *sense*

  Description

Same as the sensekey opcode.

===========================================================================
sensekey                                                           *sensekey*

  Description

Returns the ASCII code of a key that has been pressed, or -1 if no key
has been pressed.

  Syntax

kres[, kkeydown] sensekey


===========================================================================
serialBegin                                                     *serialBegin*

  Description

Open a serial port for arduino.

  Syntax

iPort serialBegin SPortName [, ibaudRate]


===========================================================================
serialEnd                                                         *serialEnd*

  Description

Close a serial port for arduino.

  Syntax

 serialEnd iPort


===========================================================================
serialFlush                                                     *serialFlush*

  Description

Flush to the screen any bytes (up to 32k) in the input buffer. Note that
these bytes will be cleared from the buffer. use this opcode mainly for
debugging messages. If you want to mix debugging and other communication
messages over the same port, you will need to manually parse the data
with the serialRead opcode.

  Syntax

 serialFlush iPort


===========================================================================
serialPrint                                                     *serialPrint*

  Description

Print to the screen any bytes (up to 32k) in the input buffer. Note that
these bytes will be cleared from the buffer. use this opcode mainly for
debugging messages. If you want to mix debugging and other communication
messages over the same port, you will need to manually parse the data
with the serialRead opcode.

  Syntax

 serialPrint iPort


===========================================================================
serialRead                                                       *serialRead*

  Description

Read data from a serial port for arduino.

  Syntax

kByte serialRead iPort


===========================================================================
serialWrite_i                                                 *serialWrite_i*

  Description

Write data to a serial port for arduino.

  Syntax

 serialWrite_i iPort, iByte

 serialWrite_i iPort, SBytes


===========================================================================
serialWrite                                                     *serialWrite*

  Description

Write data to a serial port for arduino.

  Syntax

 serialWrite iPort, iByte

 serialWrite iPort, kByte

 serialWrite iPort, SBytes


===========================================================================
seqtime2                                                           *seqtime2*

  Description

Generates a trigger signal according to the values stored in a table.

  Syntax

ktrig_out seqtime2 ktrig_in, ktime_unit, kstart, kloop, kinitndx, kfn_times


===========================================================================
seqtime                                                             *seqtime*

  Description

Generates a trigger signal according to the values stored in a table.

  Syntax

ktrig_out seqtime ktime_unit, kstart, kloop, kinitndx, kfn_times


===========================================================================
setctrl                                                             *setctrl*

  Description

Configurable slider controls for realtime user input. Requires Winsound
or TCL/TK. setctrl sets a slider to a specific value, or sets a minimum
or maximum range.

  Syntax

setctrl inum, ival, itype


===========================================================================
setksmps                                                           *setksmps*

  Description

Sets the local ksmps value in an instrument or user-defined opcode block.

  Syntax

setksmps iksmps


===========================================================================
setrow                                                               *setrow*

  Description

Sets a given row of a 2-dimensional array. The output is an 2-d array
with the contents of the requested row set to values of the input array
(1-d; if 2-d the first row of the input array is used).

  Syntax

kout[] setrowkin[],krow


===========================================================================
setscorepos                                                     *setscorepos*

  Description

Sets the playback position of the current score performance to a given
position.

  Syntax

 setscorepos ipos


===========================================================================
sfilist                                                             *sfilist*

  Description

Prints a list of all instruments of a previously loaded SoundFont2 (SF2)
sample file. These opcodes allow management the sample-structure of SF2
files. In order to understand the usage of these opcodes, the user must
have some knowledge of the SF2 format, so a brief description of this
format can be found in the SoundFont2 File Format Appendix.

  Syntax

sfilist ifilhandle


===========================================================================
sfinstr3                                                           *sfinstr3*

  Description

Plays a SoundFont2 (SF2) sample instrument, generating a stereo sound
with cubic interpolation. These opcodes allow management the
sample-structure of SF2 files. In order to understand the usage of these
opcodes, the user must have some knowledge of the SF2 format, so a brief
description of this format can be found in the SoundFont2 File Format
Appendix.

  Syntax

ar1, ar2 sfinstr3 ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \
      [, iflag] [, ioffset]


===========================================================================
sfinstr3m                                                         *sfinstr3m*

  Description

Plays a SoundFont2 (SF2) sample instrument, generating a mono sound with
cubic interpolation. These opcodes allow management the sample-structure
of SF2 files. In order to understand the usage of these opcodes, the
user must have some knowledge of the SF2 format, so a brief description
of this format can be found in the SoundFont2 File Format Appendix.

  Syntax

ares sfinstr3m ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \
      [, iflag] [, ioffset]


===========================================================================
sfinstr                                                             *sfinstr*

  Description

Plays a SoundFont2 (SF2) sample instrument, generating a stereo sound.
These opcodes allow management the sample-structure of SF2 files. In
order to understand the usage of these opcodes, the user must have some
knowledge of the SF2 format, so a brief description of this format can
be found in the SoundFont2 File Format Appendix.

  Syntax

ar1, ar2 sfinstr ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \
      [, iflag] [, ioffset]


===========================================================================
sfinstrm                                                           *sfinstrm*

  Description

Plays a SoundFont2 (SF2) sample instrument, generating a mono sound.
These opcodes allow management the sample-structure of SF2 files. In
order to understand the usage of these opcodes, the user must have some
knowledge of the SF2 format, so a brief description of this format can
be found in the SoundFont2 File Format Appendix.

  Syntax

ares sfinstrm ivel, inotenum, xamp, xfreq, instrnum, ifilhandle \
      [, iflag] [, ioffset]


===========================================================================
sfload                                                               *sfload*

  Description

Loads an entire SoundFont2 (SF2) sample file into memory. These opcodes
allow management the sample-structure of SF2 files. In order to
understand the usage of these opcodes, the user must have some knowledge
of the SF2 format, so a brief description of this format can be found in
the SoundFont2 File Format Appendix.

sfload should be placed in the header section of a Csound orchestra.

  Syntax

ir sfload "filename"


===========================================================================
sflooper                                                           *sflooper*

  Description

Plays a SoundFont2 (SF2) sample preset, generating a stereo sound,
similarly to sfplay. Unlike that opcode, though, it ignores the looping
points set in the SF2 file and substitutes them for a user-defined
crossfade loop. It is a cross between sfplay and flooper2.

  Syntax

ar1, ar2 sflooper ivel, inotenum, kamp, kpitch, ipreindex, kloopstart, kloopend, kcrossfade \
      [, istart, imode, ifenv, iskip] 


===========================================================================
sfpassign                                                         *sfpassign*

  Description

Assigns all presets of a previously loaded SoundFont2 (SF2) sample file
to a sequence of progressive index numbers. These opcodes allow
management the sample-structure of SF2 files. In order to understand the
usage of these opcodes, the user must have some knowledge of the SF2
format, so a brief description of this format can be found in the
SoundFont2 File Format Appendix.

sfpassign should be placed in the header section of a Csound orchestra.

  Syntax

sfpassign istartindex, ifilhandle[, imsgs]


===========================================================================
sfplay3                                                             *sfplay3*

  Description

Plays a SoundFont2 (SF2) sample preset, generating a stereo sound with
cubic interpolation. These opcodes allow management the sample-structure
of SF2 files. In order to understand the usage of these opcodes, the
user must have some knowledge of the SF2 format, so a brief description
of this format can be found in the SoundFont2 File Format Appendix.

  Syntax

ar1, ar2 sfplay3 ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv]


===========================================================================
sfplay3m                                                           *sfplay3m*

  Description

Plays a SoundFont2 (SF2) sample preset, generating a mono sound with
cubic interpolation. These opcodes allow management the sample-structure
of SF2 files. In order to understand the usage of these opcodes, the
user must have some knowledge of the SF2 format, so a brief description
of this format can be found in the SoundFont2 File Format Appendix.

  Syntax

ares sfplay3m ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv]


===========================================================================
sfplay                                                               *sfplay*

  Description

Plays a SoundFont2 (SF2) sample preset, generating a stereo sound. These
opcodes allow management the sample-structure of SF2 files. In order to
understand the usage of these opcodes, the user must have some knowledge
of the SF2 format, so a brief description of this format can be found in
the SoundFont2 File Format Appendix.

  Syntax

ar1, ar2 sfplay ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv]


===========================================================================
sfplaym                                                             *sfplaym*

  Description

Plays a SoundFont2 (SF2) sample preset, generating a mono sound. These
opcodes allow management the sample-structure of SF2 files. In order to
understand the usage of these opcodes, the user must have some knowledge
of the SF2 format, so a brief description of this format can be found in
the SoundFont2 File Format Appendix.

  Syntax

ares sfplaym ivel, inotenum, xamp, xfreq, ipreindex [, iflag] [, ioffset] [, ienv]


===========================================================================
sfplist                                                             *sfplist*

  Description

Prints a list of all presets of a previously loaded SoundFont2 (SF2)
sample file. These opcodes allow management the sample-structure of SF2
files. In order to understand the usage of these opcodes, the user must
have some knowledge of the SF2 format, so a brief description of this
format can be found in the SoundFont2 File Format Appendix.

  Syntax

sfplist ifilhandle


===========================================================================
sfpreset                                                           *sfpreset*

  Description

Assigns an existing preset of a previously loaded SoundFont2 (SF2)
sample file to an index number. These opcodes allow management the
sample-structure of SF2 files. In order to understand the usage of these
opcodes, the user must have some knowledge of the SF2 format, so a brief
description of this format can be found in the SoundFont2 File Format
Appendix.

sfpreset should be placed in the header section of a Csound orchestra.

  Syntax

ir sfpreset iprog, ibank, ifilhandle, ipreindex


===========================================================================
shaker                                                               *shaker*

  Description

Audio output is a tone related to the shaking of a maraca or similar
gourd instrument. The method is a physically inspired model developed
from Perry Cook, but re-coded for Csound.

  Syntax

ares shaker kamp, kfreq, kbeans, kdamp, ktimes [, idecay]


===========================================================================
shiftin                                                             *shiftin*

  Description

This opcode can be used to push data from an audio variable into a
1-dimensional array. The array needs to be at least ksmps numbers long,
but can be longer. Data is shifted in circularly, with the writing
position moving by ksmps positions every k-cycle. When the array gets
full, the writing position wraps around to the beginning of the array
again (overwriting old positions). Together with the shiftout opcode, it
can form a FIFO queue.

  Syntax

kout[] shiftin asig


===========================================================================
shiftout                                                           *shiftout*

  Description

This opcode can be used to push data to an audio variable from a
1-dimensional array. The array needs to be at least ksmps numbers long,
but can be longer. Data is shifted out circularly, with the writing
position moving by ksmps positions every k-cycle. When the array gets
emptied, the writing position wraps around to the beginning of the array
again. Together with the shiftin opcode, it can form a FIFO queue.

  Syntax

asig shiftout kIn[][, ioff]


===========================================================================
signum                                                               *signum*

  Description

Returns the signum of x returning -1, 0 or 1.

  Syntax

signum(x) (no rate restriction)


===========================================================================
sin                                                                     *sin*

  Description

Returns the sine of x (x in radians).

  Syntax

sin(x) (no rate restriction)


===========================================================================
sinh                                                                   *sinh*

  Description

Returns the hyperbolic sine of x (x in radians).

  Syntax

sinh(x) (no rate restriction)


===========================================================================
sininv                                                               *sininv*

  Description

Returns the arcsine of x (x in radians).

  Syntax

sininv(x) (no rate restriction)


===========================================================================
sinsyn                                                               *sinsyn*

  Description

The sinsyn opcode takes an input containg a TRACKS pv streaming signal
(as generated, for instance by the partials opcode). It resynthesises
the signal using linear amplitude and cubic phase interpolation to drive
a bank of interpolating oscillators with amplitude scaling control.
sinsyn attempts to preserve the phase of the partials in the original
signal and in so doing it does not allow for pitch or timescale
modifications of the signal.

  Syntax

asig sinsyn fin, kscal, kmaxtracks, ifn


===========================================================================
sleighbells                                                     *sleighbells*

  Description

sleighbells is a semi-physical model of a sleighbell sound. It is one of
the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic
Event Modeling) is an algorithmic approach for simulating collisions of
multiple independent sound producing objects.

  Syntax

ares sleighbells kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \
      [, ifreq1] [, ifreq2]


===========================================================================
slicearray                                                       *slicearray*

  Description

Take a slice of a vector (one-dimensional k-rate array).

  Syntax

karray slicearray kinarray, istart, iend


===========================================================================
slider16                                                           *slider16*

  Description

Creates a bank of 16 different MIDI control message numbers.

  Syntax

i1,...,i16 slider16 ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \
      ictlnum16, imin16, imax16, init16, ifn16

k1,...,k16 slider16 ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \
      ictlnum16, imin16, imax16, init16, ifn16


===========================================================================
slider16f                                                         *slider16f*

  Description

Creates a bank of 16 different MIDI control message numbers, filtered
before output.

  Syntax

k1,...,k16 slider16f ichan, ictlnum1, imin1, imax1, init1, ifn1, \
      icutoff1,..., ictlnum16, imin16, imax16, init16, ifn16, icutoff16


===========================================================================
slider16table                                                 *slider16table*

  Description

Stores a bank of 16 different MIDI control messages to a table.

  Syntax

kflag slider16table ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \
      init1, ifn1, .... , ictlnum16, imin16, imax16, init16, ifn16


===========================================================================
slider16tablef                                               *slider16tablef*

  Description

Stores a bank of 16 different MIDI control messages to a table, filtered
before output.

  Syntax

kflag slider16tablef ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \
      init1, ifn1, icutoff1, .... , ictlnum16, imin16, imax16, init16, ifn16, icutoff16


===========================================================================
slider32                                                           *slider32*

  Description

Creates a bank of 32 different MIDI control message numbers.

  Syntax

i1,...,i32 slider32 ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \
      ictlnum32, imin32, imax32, init32, ifn32

k1,...,k32 slider32 ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \
      ictlnum32, imin32, imax32, init32, ifn32


===========================================================================
slider32f                                                         *slider32f*

  Description

Creates a bank of 32 different MIDI control message numbers, filtered
before output.

  Syntax

k1,...,k32 slider32f ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, \
      ..., ictlnum32, imin32, imax32, init32, ifn32, icutoff32


===========================================================================
slider32table                                                 *slider32table*

  Description

Creates a bank of 32 different MIDI control messages to a table.

  Syntax

kflag slider32table ichan, ioutTable, ioffset, ictlnum1, imin1, \
      imax1, init1, ifn1, .... , ictlnum32, imin32, imax32, init32, ifn32


===========================================================================
slider32tablef                                               *slider32tablef*

  Description

Stores a bank of 32 different MIDI control messages to a table, filtered
before output.

  Syntax

kflag slider32tablef ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \
      init1, ifn1, icutoff1, .... , ictlnum32, imin32, imax32, init32, ifn32, icutoff32


===========================================================================
slider64                                                           *slider64*

  Description

Creates a bank of 64 different MIDI control message numbers.

  Syntax

i1,...,i64 slider64 ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \
      ictlnum64, imin64, imax64, init64, ifn64

k1,...,k64 slider64 ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \
      ictlnum64, imin64, imax64, init64, ifn64


===========================================================================
slider64f                                                         *slider64f*

  Description

Creates a bank of 64 different MIDI control message numbers, filtered
before output.

  Syntax

k1,...,k64 slider64f ichan, ictlnum1, imin1, imax1, init1, ifn1, \
      icutoff1,..., ictlnum64, imin64, imax64, init64, ifn64, icutoff64


===========================================================================
slider64table                                                 *slider64table*

  Description

Creates a bank of 64 different MIDI control messages to a table.

  Syntax

kflag slider64table ichan, ioutTable, ioffset, ictlnum1, imin1, \
      imax1, init1, ifn1, .... , ictlnum64, imin64, imax64, init64, ifn64


===========================================================================
slider64tablef                                               *slider64tablef*

  Description

Stores a bank of 64 different MIDI MIDI control messages to a table,
filtered before output.

  Syntax

kflag slider64tablef ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \
      init1, ifn1, icutoff1, .... , ictlnum64, imin64, imax64, init64, ifn64, icutoff64


===========================================================================
slider8                                                             *slider8*

  Description

Creates a bank of 8 different MIDI control message numbers.

  Syntax

i1,...,i8 slider8 ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \
      ictlnum8, imin8, imax8, init8, ifn8

k1,...,k8 slider8 ichan, ictlnum1, imin1, imax1, init1, ifn1,..., \
      ictlnum8, imin8, imax8, init8, ifn8


===========================================================================
slider8f                                                           *slider8f*

  Description

Creates a bank of 8 different MIDI control message numbers, filtered
before output.

  Syntax

k1,...,k8 slider8f ichan, ictlnum1, imin1, imax1, init1, ifn1, icutoff1, \
      ..., ictlnum8, imin8, imax8, init8, ifn8, icutoff8


===========================================================================
slider8table                                                   *slider8table*

  Description

Stores a bank of 8 different MIDI control messages to a table.

  Syntax

kflag slider8table ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \
      init1, ifn1,..., ictlnum8, imin8, imax8, init8, ifn8


===========================================================================
slider8tablef                                                 *slider8tablef*

  Description

Stores a bank of 8 different MIDI control messages to a table, filtered
before output.

  Syntax

kflag slider8tablef ichan, ioutTable, ioffset, ictlnum1, imin1, imax1, \
      init1, ifn1, icutoff1, .... , ictlnum8, imin8, imax8, init8, ifn8, icutoff8


===========================================================================
sliderKawai                                                     *sliderKawai*

  Description

Creates a bank of 16 different MIDI control message numbers from a KAWAI
MM-16 midi mixer.

  Syntax

k1, k2, ...., k16 sliderKawai imin1, imax1, init1, ifn1, \
      imin2, imax2, init2, ifn2, ..., imin16, imax16, init16, ifn16


===========================================================================
sndloop                                                             *sndloop*

  Description

This opcode records input audio and plays it back in a loop with
user-defined duration and crossfade time. It also allows the pitch of
the loop to be controlled, including reversed playback.

  Syntax

asig, krec sndloop ain, kpitch, ktrig, idur, ifad


===========================================================================
sndwarp                                                             *sndwarp*

  Description

sndwarp reads sound samples from a table and applies time-stretching
and/or pitch modification. Time and frequency modification are
independent from one another. For example, a sound can be stretched in
time while raising the pitch!

The window size and overlap arguments are important to the result and
should be experimented with. In general they should be as small as
possible. For example, start with iwsize=sr/10 and ioverlap=15. Try
irandw=iwsize*0.2. If you can get away with less overlaps, the program
will be faster. But too few may cause an audible flutter in the
amplitude. The algorithm reacts differently depending upon the input
sound and there are no fixed rules for the best use in all
circumstances. But with proper tuning, excellent results can be achieved.

  Syntax

ares [, ac] sndwarp xamp, xtimewarp, xresample, ifn1, ibeg, iwsize, \
      irandw, ioverlap, ifn2, itimemode


===========================================================================
sndwarpst                                                         *sndwarpst*

  Description

sndwarpst reads stereo sound samples from a table and applies
time-stretching and/or pitch modification. Time and frequency
modification are independent from one another. For example, a sound can
be stretched in time while raising the pitch!

The window size and overlap arguments are important to the result and
should be experimented with. In general they should be as small as
possible. For example, start with iwsize=sr/10 and ioverlap=15. Try
irandw=iwsize*.2. If you can get away with less overlaps, the program
will be faster. But too few may cause an audible flutter in the
amplitude. The algorithm reacts differently depending upon the input
sound and there are no fixed rules for the best use in all
circumstances. But with proper tuning, excellent results can be achieved.

  Syntax

ar1, ar2 [,ac1] [, ac2] sndwarpst xamp, xtimewarp, xresample, ifn1, \
      ibeg, iwsize, irandw, ioverlap, ifn2, itimemode


===========================================================================
sockrecv                                                           *sockrecv*

  Description

Receives directly using the UDP (sockrecv and sockrecvs) or TCP (strecv)
protocol onto a network. The data is not subject to any encoding or
special routing. The sockrecvs opcode receives a stereo signal interleaved.

  Syntax

asig sockrecv iport, ilength

ksig sockrecv iport, ilength

asigl, asigr sockrecvs iport, ilength

asig strecv Sipaddr, iport


===========================================================================
socksend                                                           *socksend*

  Description

Transmits data directly using the UDP (socksend and socksends) or TCP
(stsend) protocol onto a network. The data is not subject to any
encoding or special routing. The socksends opcode send a stereo signal
interleaved.

  Syntax

socksend asig, Sipaddr, iport, ilength

socksend ksig, Sipaddr, iport, ilength

socksends asigl, asigr, Sipaddr, iport,
    ilength

stsend asig, Sipaddr, iport


===========================================================================
soundin                                                             *soundin*

  Description

Reads audio data from an external device or stream. Up to 24 channels
may be read before v5.14, extended to 40 in later versions.

  Syntax

ar1[, ar2[, ar3[, ... a24]]] soundin ifilcod [, iskptim] [, iformat] \
      [, iskipinit] [, ibufsize]


===========================================================================
space                                                                 *space*

  Description

space takes an input signal and distributes it among 4 channels using
Cartesian xy coordinates to calculate the balance of the outputs. The xy
coordinates can be defined in a separate text file and accessed through
a Function statement in the score using Gen28, or they can be specified
using the optional kx, ky arguments. The advantages to the former are:

 1. A graphic user interface can be used to draw and edit the trajectory
    through the Cartesian plane

 2. The file format is in the form time1 X1 Y1 time2 X2 Y2 time3 X3 Y3
    allowing the user to define a time-tagged trajectory

space then allows the user to specify a time pointer (much as is used
for pvoc, lpread and some other units) to have detailed control over the
final speed of movement.

  Syntax

a1, a2, a3, a4  space asig, ifn, ktime, kreverbsend, kx, ky


===========================================================================
spat3d                                                               *spat3d*

  Description

This opcode positions the input sound in a 3D space, with optional
simulation of room acoustics, in various output formats. spat3d allows
moving the sound at k-rate (this movement is interpolated internally to
eliminate "zipper noise" if sr not equal to kr).

  Syntax

aW, aX, aY, aZ spat3d ain, kX, kY, kZ, idist, ift, imode, imdel, iovr [, istor]


===========================================================================
spat3di                                                             *spat3di*

  Description

This opcode positions the input sound in a 3D space, with optional
simulation of room acoustics, in various output formats. With spat3di,
sound source position is set at i-time.

  Syntax

aW, aX, aY, aZ spat3di ain, iX, iY, iZ, idist, ift, imode [, istor]


===========================================================================
spat3dt                                                             *spat3dt*

  Description

This opcode positions the input sound in a 3D space, with optional
simulation of room acoustics, in various output formats. spat3dt can be
used to render the impulse response at i-time, storing output in a
function table, suitable for convolution.

  Syntax

spat3dt ioutft, iX, iY, iZ, idist, ift, imode, irlen [, iftnocl]


===========================================================================
spdist                                                               *spdist*

  Description

spdist uses the same xy data as space, also either from a text file
using Gen28 or from x and y arguments given to the unit directly. The
purpose of this unit is to make available the values for distance that
are calculated from the xy coordinates.

In the case of space, the xy values are used to determine a distance
which is used to attenuate the signal and prepare it for use in spsend.
But it is also useful to have these values for distance available to
scale the frequency of the signal before it is sent to the space unit.

  Syntax

k1 spdist ifn, ktime, kx, ky


===========================================================================
specaddm                                                           *specaddm*

  Description

Perform a weighted add of two input spectra.

  Syntax

wsig specaddm wsig1, wsig2 [, imul2]


===========================================================================
specdiff                                                           *specdiff*

  Description

Finds the positive difference values between consecutive spectral frames.

  Syntax

wsig specdiff wsigin


===========================================================================
specdisp                                                           *specdisp*

  Description

Displays the magnitude values of the spectrum.

  Syntax

specdisp wsig, iprd [, iwtflg]


===========================================================================
specfilt                                                           *specfilt*

  Description

Filters each channel of an input spectrum.

  Syntax

wsig specfilt wsigin, ifhtim


===========================================================================
spechist                                                           *spechist*

  Description

Accumulates the values of successive spectral frames.

  Syntax

wsig spechist wsigin


===========================================================================
specptrk                                                           *specptrk*

  Description

Estimate the pitch of the most prominent complex tone in the spectrum.

  Syntax

koct, kamp specptrk wsig, kvar, ilo, ihi, istr, idbthresh, inptls, \
      irolloff [, iodd] [, iconfs] [, interp] [, ifprd] [, iwtflg]


===========================================================================
specscal                                                           *specscal*

  Description

Scales an input spectral datablock with spectral envelopes.

  Syntax

wsig specscal wsigin, ifscale, ifthresh


===========================================================================
specsum                                                             *specsum*

  Description

Sums the magnitudes across all channels of the spectrum.

  Syntax

ksum specsum wsig [, interp]


===========================================================================
spectrum                                                           *spectrum*

  Description

Generate a constant-Q, exponentially-spaced DFT across all octaves of a
multiply-downsampled control or audio input signal.

  Syntax

wsig spectrum xsig, iprd, iocts, ifrqa [, iq] [, ihann] [, idbout] \
      [, idsprd] [, idsinrs]


===========================================================================
splitrig                                                           *splitrig*

  Description

splitrig splits a trigger signal (i.e. a timed sequence of control-rate
impulses) into several channels following a structure designed by the user.

  Syntax

splitrig ktrig, kndx, imaxtics, ifn, kout1 [,kout2,...,koutN]


===========================================================================
sprintf                                                             *sprintf*

  Description

sprintf write printf-style formatted output to a string variable,
similarly to the C function sprintf(). sprintf runs at i-time only.

  Syntax

Sdst sprintf Sfmt, xarg1[, xarg2[, ... ]]


===========================================================================
sprintfk                                                           *sprintfk*

  Description

sprintfk writes printf-style formatted output to a string variable,
similarly to the C function sprintf(). sprintfk runs both at
initialization and performance time.

  Syntax

Sdst sprintfk Sfmt, xarg1[, xarg2[, ... ]]


===========================================================================
spsend                                                               *spsend*

  Description

spsend depends upon the existence of a previously defined space. The
output signals from spsend are derived from the values given for xy and
reverb in the space and are ready to be sent to local or global reverb
units (see example below).

  Syntax

a1, a2, a3, a4 spsend


===========================================================================
sqrt                                                                   *sqrt*

  Description

Returns the square root of x (x non-negative).

The argument value is restricted for log, log10, and sqrt.

  Syntax

sqrt(x) (no rate restriction)

where the argument within the parentheses may be an expression. Value
converters perform arithmetic translation from units of one kind to
units of another. The result can then be a term in a further expression.


===========================================================================
sr                                                                       *sr*

  Description

These statements are global value assignments, made at the beginning of
an orchestra, before any instrument block is defined. Their function is
to set certain reserved symbol variables that are required for
performance. Once set, these reserved symbols can be used in expressions
anywhere in the orchestra.

  Syntax

sr = iarg


===========================================================================
statevar                                                           *statevar*

  Description

Statevar is a new digital implementation of the analogue state-variable
filter. This filter has four simultaneous outputs: high-pass, low-pass,
band-pass and band-reject. This filter uses oversampling for sharper
resonance (default: 3 times oversampling). It includes a resonance
limiter that prevents the filter from getting unstable.

  Syntax

ahp,alp,abp,abr statevar ain, xcf, xq [, iosamps, istor]


===========================================================================
stix                                                                   *stix*

  Description

stix is a semi-physical model of a stick sound. It is one of the PhISEM
percussion opcodes. PhISEM (Physically Informed Stochastic Event
Modeling) is an algorithmic approach for simulating collisions of
multiple independent sound producing objects.

  Syntax

ares stix iamp, idettack [, inum] [, idamp] [, imaxshake]


===========================================================================
STKBandedWG                                                     *STKBandedWG*

  Description

This opcode uses banded waveguide techniques to model a variety of
sounds, including bowed bars, glasses, and bowls.

  Syntax

asignal STKBandedWG ifrequency, iamplitude, [kpress, kv1[, kmot, kv2[, klfo, kv3[, klfodepth, kv4[, kvel, kv5[, kstrk, kv6[, kinstr, kv7]]]]]]]


===========================================================================
STKBeeThree                                                     *STKBeeThree*

  Description

STK Hammond-oid organ-like FM synthesis instrument.

This opcode a simple 4 operator topology, also referred to as algorithm
8 of the TX81Z. It simulates the sound of a Hammond-oid organ, and some
related sounds.

  Syntax

asignal STKBeeThree ifrequency, iamplitude, [kop4, kv1[, kop3, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]


===========================================================================
STKBlowBotl                                                     *STKBlowBotl*

  Description

This opcode implements a helmholtz resonator (biquad filter) with a
polynomial jet excitation (a la Cook).

  Syntax

asignal STKBlowBotl ifrequency, iamplitude, [knoise, kv1[, klfo, kv2[, klfodepth, kv3[, kvol, kv4]]]]


===========================================================================
STKBlowHole                                                     *STKBlowHole*

  Description

This opcode is based on the clarinet model, with the addition of a
two-port register hole and a three-port dynamic tonehole implementation.

In this implementation, the distances between the reed/register hole and
tonehole/bell are fixed. As a result, both the tonehole and register
hole will have variable influence on the playing frequency, which is
dependent on the length of the air column. In addition, the highest
playing freqeuency is limited by these fixed lengths.

  Syntax

asignal STKBlowHole ifrequency, iamplitude, [kreed, kv1[, knoise, kv2[, khole, kv3[, kreg, kv4[, kbreath, kv5]]]]]


===========================================================================
STKBowed                                                           *STKBowed*

  Description

STKBowed is a bowed string instrument, using a waveguide model.

  Syntax

asignal STKBowed ifrequency, iamplitude, [kpress, kv1[, kpos, kv2[, klfo, kv3[, klfodepth, kv4[, kvol, kv5]]]]]


===========================================================================
STKBrass                                                           *STKBrass*

  Description

STKBrass uses a simple brass instrument waveguide model, a la Cook.

  Syntax

asignal STKBrass ifrequency, iamplitude, [klip, kv1[, kslide, kv2[, klfo, kv3[, klfodepth, kv4[, kvol, kv5]]]]]


===========================================================================
STKClarinet                                                     *STKClarinet*

  Description

STKClarinet uses a simple clarinet physical model.

  Syntax

asignal STKClarinet ifrequency, iamplitude, [kstiff, kv1[, knoise, kv2[, klfo, kv3[, klfodepth, kv4[, kbreath, kv5]]]]]


===========================================================================
STKDrummer                                                       *STKDrummer*

  Description

STKDrummer is a drum sampling synthesizer using raw waves and one-pole
filters, The drum rawwave files are sampled at 22050 Hz, but will be
appropriately interpolated for other sample rates.

  Syntax

asignal STKDrummer ifrequency, iamplitude


===========================================================================
STKFlute                                                           *STKFlute*

  Description

STKFlute uses a simple flute physical model. The jet model uses a
polynomial, a la Cook.

  Syntax

asignal STKFlute ifrequency, iamplitude, [kjet, kv1[, knoise, kv2[, klfo, kv3[, klfodepth, kv4[, kbreath, kv5]]]]]


===========================================================================
STKFMVoices                                                     *STKFMVoices*

  Description

STKFMVoices is a singing FM synthesis instrument. It has 3 carriers and
a common modulator, also referred to as algorithm 6 of the TX81Z.

  Syntax

asignal STKFMVoices ifrequency, iamplitude, [kvowel, kv1[, kspec, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]


===========================================================================
STKHevyMetl                                                     *STKHevyMetl*

  Description

STKHevyMetl produces metal sounds, using FM synthesis. It uses 3 cascade
operators with feedback modulation, also referred to as algorithm 3 of
the TX81Z.

  Syntax

asignal STKHevyMetl ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]


===========================================================================
STKMandolin                                                     *STKMandolin*

  Description

STKMandolin produces mamdolin-like sounds, using "commuted synthesis"
techniques to model a mandolin instrument.

  Syntax

asignal STKMandolin ifrequency, iamplitude, [kbody, kv1[, kpos, kv2[, ksus, kv3[, kdetune, kv4[, kmic, kv5]]]]]


===========================================================================
STKModalBar                                                     *STKModalBar*

  Description

This opcode is a resonant bar instrument.It has a number of different
struck bar instruments.

  Syntax

asignal STKModalBar ifrequency, iamplitude, [khard, kv1[, kpos, kv2[, klfo, kv3[, klfodepth, kv4[, kmix, kv5[, kvol, kv6[, kinstr, kv7]]]]]]]


===========================================================================
STKMoog                                                             *STKMoog*

  Description

STKMoog produces moog-like swept filter sounds, using one attack wave,
one looped wave, and an ADSR envelope and adds two sweepable formant
filters.

  Syntax

asignal STKMoog ifrequency, iamplitude, [kq, kv1[, krate, kv2[, klfo, kv3[, klfodepth, kv4[, kvol, kv5]]]]]


===========================================================================
STKPercFlut                                                     *STKPercFlut*

  Description

STKPercFlut is a percussive flute FM synthesis instrument. The
instrument uses an algorithm like the algorithm 4 of the TX81Z.

  Syntax

asignal STKPercFlut ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]


===========================================================================
STKPlucked                                                       *STKPlucked*

  Description

STKPlucked uses a plucked string physical model based on the
Karplus-Strong algorithm.

  Syntax

asignal STKPlucked ifrequency, iamplitude


===========================================================================
STKResonate                                                     *STKResonate*

  Description

STKResonate is a noise driven formant filter. This instrument contains a
noise source, which excites a biquad resonance filter, with volume
controlled by an ADSR.

  Syntax

asignal STKResonate ifrequency, iamplitude, [kfreq, kv1[, kpole, kv2[, knotch, kv3[, kzero, kv4[, kenv, kv5]]]]]


===========================================================================
STKRhodey                                                         *STKRhodey*

  Description

STK Fender Rhodes-like electric piano FM synthesis instrument.

This opcode implements an instrument based on two simple FM Pairs summed
together, also referred to as algorithm 5 of the Yamaha TX81Z. It
simulates the sound of a Rhodes electric piano, and some related sounds.

  Syntax

asignal STKRhodey ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]


===========================================================================
STKSaxofony                                                     *STKSaxofony*

  Description

STKSaxofony is a faux conical bore reed instrument. This opcode uses a
"hybrid" digital waveguide instrument that can generate a variety of
wind-like sounds. It has also been referred to as the "blowed string"
model. The waveguide section is essentially that of a string, with one
rigid and one lossy termination. The non-linear function is a reed
table. The string can be "blown" at any point between the terminations,
though just as with strings, it is impossible to excite the system at
either end. If the excitation is placed at the string mid-point, the
sound is that of a clarinet. At points closer to the "bridge", the sound
is closer to that of a saxophone.

  Syntax

asignal STKSaxofony ifrequency, iamplitude, [kstiff, kv1[, kapert, kv2[, kblow, kv3[, knoise, kv4[, klfo, kv5[, klfodepth, kv6[, kbreath, kv7]]]]]]]


===========================================================================
STKShakers                                                       *STKShakers*

  Description

STKShakers are a set of PhISEM and PhOLIES instruments: PhISEM
(Physically Informed Stochastic Event Modeling) is an algorithmic
approach for simulating collisions of multiple independent sound
producing objects. It can simulate a Maraca, Sekere, Cabasa, Bamboo Wind
Chimes, Water Drops, Tambourine, Sleighbells, and a Guiro. On
http://soundlab.cs.princeton.edu/research/controllers/shakers/ PhOLIES
(Physically-Oriented Library of Imitated Environmental Sounds) there is
a similar approach for the synthesis of environmental sounds. It
simulates of breaking sticks, crunchy snow (or not), a wrench,
sandpaper, and more..

  Syntax

asignal STKShakers ifrequency, iamplitude, [kenerg, kv1[, kdecay, kv2[, kshake, kv3[, knum, kv4[, kres, kv5[, kinstr, kv6]]]]]]


===========================================================================
STKSimple                                                         *STKSimple*

  Description

STKSimple is a wavetable/noise instrument. It combines a looped wave, a
noise source, a biquad resonance filter, a one-pole filter, and an ADSR
envelope to create some interesting sounds.

  Syntax

asignal STKSimple ifrequency, iamplitude, [kpos, kv1[, kcross, kv2[, kenv, kv3[, kgain, kv4]]]]


===========================================================================
STKSitar                                                           *STKSitar*

  Description

STKSitar uses a plucked string physical model based on the
Karplus-Strong algorithm.

  Syntax

asignal STKSitar ifrequency, iamplitude


===========================================================================
STKStifKarp                                                     *STKStifKarp*

  Description

STKStifKarp is a plucked stiff string instrument. It a simple plucked
string algorithm (Karplus Strong) with enhancements, including string
stiffness and pluck position controls. The stiffness is modeled with
allpass filters.

  Syntax

asignal STKStifKarp ifrequency, iamplitude, [kpos, kv1[, ksus, kv2[, kstretch, kv3]]]


===========================================================================
STKTubeBell                                                     *STKTubeBell*

  Description

STKTubeBell is a tubular bell (orchestral chime) FM synthesis
instrument. It uses two simple FM Pairs summed together, also referred
to as algorithm 5 of the TX81Z.

  Syntax

asignal STKTubeBell ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]


===========================================================================
STKVoicForm                                                     *STKVoicForm*

  Description

STKVoicForm is a four formant synthesis instrument. This instrument
contains an excitation singing wavetable (looping wave with random and
periodic vibrato, smoothing on frequency, etc.), excitation noise, and
four sweepable complex resonances. Measured formant data is included,
and enough data is there to support either parallel or cascade
synthesis. In the floating point case cascade synthesis is the most
natural so that's what you'll find here.

  Syntax

asignal STKVoicForm ifrequency, iamplitude, [kmix, kv1[, ksel, kv2[, klfo, kv3[, klfodepth, kv4[, kloud, kv5]]]]]


===========================================================================
STKWhistle                                                       *STKWhistle*

  Description

STKWhistle produces (police) whistle sounds. It uses a hybrid
physical/spectral model of a police whistle (a la Cook).

  Syntax

asignal STKWhistle ifrequency, iamplitude, [kmod, kv1[, knoise, kv2[, kfipfreq, kv3[, kfipgain, kv4[, kvol, kv5]]]]]


===========================================================================
STKWurley                                                         *STKWurley*

  Description

STKWurley simulates a Wurlitzer electric piano FM synthesis instrument.
It uses two simple FM Pairs summed together, also referred to as
algorithm 5 of the TX81Z.

  Syntax

asignal STKWurley ifrequency, iamplitude, [kmod, kv1[, kcross, kv2[, klfo, kv3[, klfodepth, kv4[, kadsr, kv5]]]]]


===========================================================================
strchar                                                             *strchar*

  Description

Return the ASCII code of the character in Sstr at ipos (defaults to zero
which means the first character), or zero if ipos is out of range.
strchar runs at init time only.

  Syntax

ichr strchar Sstr[, ipos]


===========================================================================
strchark                                                           *strchark*

  Description

Return the ASCII code of the character in Sstr at kpos (defaults to zero
which means the first character), or zero if kpos is out of range.
strchark runs both at init and performance time.

  Syntax

kchr strchark Sstr[, kpos]


===========================================================================
strcpy                                                               *strcpy*

  Description

Assign to a string variable by copying the source which may be a
constant or another string variable. strcpy and = copy the string at
i-time only.

  Syntax

Sdst strcpy Ssrc

Sdst = Ssrc


===========================================================================
strcpyk                                                             *strcpyk*

  Description

Assign to a string variable by copying the source which may be a
constant or another string variable. strcpyk does the assignment both at
initialization and performance time.

  Syntax

Sdst strcpyk Ssrc


===========================================================================
strcat                                                               *strcat*

  Description

Concatenate two strings and store the result in a variable. strcat runs
at i-time only. It is allowed for any of the input arguments to be the
same as the output variable.

  Syntax

Sdst strcat Ssrc1, Ssrc2


===========================================================================
strcatk                                                             *strcatk*

  Description

Concatenate two strings and store the result in a variable. strcatk does
the concatenation both at initialization and performance time. It is
allowed for any of the input arguments to be the same as the output
variable.

  Syntax

Sdst strcatk Ssrc1, Ssrc2


===========================================================================
strcmp                                                               *strcmp*

  Description

Compare strings and set the result to -1, 0, or 1 if the first string is
less than, equal to, or greater than the second, respectively. strcmp
compares at i-time only.

  Syntax

ires strcmp S1, S2


===========================================================================
strcmpk                                                             *strcmpk*

  Description

Compare strings and set the result to -1, 0, or 1 if the first string is
less than, equal to, or greater than the second, respectively. strcmpk
does the comparison both at initialization and performance time.

  Syntax

kres strcmpk S1, S2


===========================================================================
streson                                                             *streson*

  Description

An audio signal is modified by a string resonator with variable
fundamental frequency.

  Syntax

ares streson asig, kfr, ifdbgain


===========================================================================
strfromurl                                                       *strfromurl*

  Description

strfromurl sets a string variable at initialization time to the value
found from reading an URL.

  Syntax

Sdst strfromurl StringURL


===========================================================================
strget                                                               *strget*

  Description

strget sets a string variable at initialization time to the value stored
in strset table at the specified index, or a string p-field from the
score. If there is no string defined for the index, the variable is set
to an empty string.

  Syntax

Sdst strget indx


===========================================================================
strindex                                                           *strindex*

  Description

Return the position of the first occurence of S2 in S1, or -1 if not
found. If S2 is empty, 0 is returned. strindex runs at init time only.

  Syntax

ipos strindex S1, S2


===========================================================================
strindexk                                                         *strindexk*

  Description

Return the position of the first occurence of S2 in S1, or -1 if not
found. If S2 is empty, 0 is returned. strindexk runs both at init and
performance time.

  Syntax

kpos strindexk S1, S2


===========================================================================
strlen                                                               *strlen*

  Description

Return the length of a string, or zero if it is empty. strlen runs at
init time only.

  Syntax

ilen strlen Sstr


===========================================================================
strlenk                                                             *strlenk*

  Description

Return the length of a string, or zero if it is empty. strlenk runs both
at init and performance time.

  Syntax

klen strlenk Sstr


===========================================================================
strlower                                                           *strlower*

  Description

Convert Ssrc to lower case, and write the result to Sdst. strlower runs
at init time only.

  Syntax

Sdst strlower Ssrc


===========================================================================
strlowerk                                                         *strlowerk*

  Description

Convert Ssrc to lower case, and write the result to Sdst. strlowerk runs
both at init and performance time.

  Syntax

Sdst strlowerk Ssrc


===========================================================================
strrindex                                                         *strrindex*

  Description

Return the position of the last occurence of S2 in S1, or -1 if not
found. If S2 is empty, the length of S1 is returned. strrindex runs at
init time only.

  Syntax

ipos strrindex S1, S2


===========================================================================
strrindexk                                                       *strrindexk*

  Description

Return the position of the last occurence of S2 in S1, or -1 if not
found. If S2 is empty, the length of S1 is returned. strrindexk runs
both at init and performance time.

  Syntax

kpos strrindexk S1, S2


===========================================================================
strset                                                               *strset*

  Description

Allows a string to be linked with a numeric value.

  Syntax

strset iarg, istring


===========================================================================
strsub                                                               *strsub*

  Description

Return a substring of the source string. strsub runs at init time only.

  Syntax

Sdst strsub Ssrc[, istart[, iend]]


===========================================================================
strsubk                                                             *strsubk*

  Description

Return a substring of the source string. strsubk runs both at init and
performance time.

  Syntax

Sdst strsubk Ssrc, kstart, kend


===========================================================================
strtod                                                               *strtod*

  Description

Convert a string to a floating point value. It is also possible to pass
an strset index or a string p-field from the score instead of a string
argument. If the string cannot be parsed as a floating point or integer
number, an init or perf error occurs and the instrument is deactivated.

  Syntax

ir strtod Sstr

ir strtod indx


===========================================================================
strtodk                                                             *strtodk*

  Description

Convert a string to a floating point value at i- or k-rate. It is also
possible to pass an strset index or a string p-field from the score
instead of a string argument. If the string cannot be parsed as a
floating point or integer number, an init or perf error occurs and the
instrument is deactivated.

  Note

If a k-rate index variable is used, it should be valid at i-time as well.

  Syntax

kr strtodk Sstr

kr strtodk kndx


===========================================================================
strtol                                                               *strtol*

  Description

Convert a string to a signed integer value. It is also possible to pass
an strset index or a string p-field from the score instead of a string
argument. If the string cannot be parsed as an integer number, an init
error occurs and the instrument is deactivated.

  Syntax

ir strtol Sstr

ir strtol indx


===========================================================================
strtolk                                                             *strtolk*

  Description

Convert a string to a signed integer value at i- or k-rate. It is also
possible to pass an strset index or a string p-field from the score
instead of a string argument. If the string cannot be parsed as an
integer number, an init or perf error occurs and the instrument is
deactivated.

  Note

If a k-rate index variable is used, it should be valid at i-time as well.

  Syntax

kr strtolk Sstr

kr strtolk kndx

strtolk can parse numbers in decimal, octal (prefixed by 0), and
hexadecimal (with a prefix of 0x) format.


===========================================================================
strupper                                                           *strupper*

  Description

Convert Ssrc to upper case, and write the result to Sdst. strupper runs
at init time only.

  Syntax

Sdst strupper Ssrc


===========================================================================
strupperk                                                         *strupperk*

  Description

Convert Ssrc to upper case, and write the result to Sdst. strupperk runs
both at init and performance time.

  Syntax

Sdst strupperk Ssrc


===========================================================================
subinstr                                                           *subinstr*

  Description

Creates an instance of another instrument and is used as if it were an
opcode.

  Syntax

a1, [...] [, a8] subinstr instrnum [, p4] [, p5] [...]

a1, [...] [, a8] subinstr "insname" [, p4] [, p5] [...]


===========================================================================
subinstrinit                                                   *subinstrinit*

  Description

Same as subinstr, but init-time only and has no output arguments.

  Syntax

subinstrinit instrnum [, p4] [, p5] [...]

subinstrinit "insname" [, p4] [, p5] [...]


===========================================================================
sum                                                                     *sum*

  Description

Sums any number of a-rate signals.

  Syntax

ares sum asig1 [, asig2] [, asig3] [...]


===========================================================================
sumarray                                                           *sumarray*

  Description

The sumarray opcode returns the sum of all elements in a k-rate array
array.

  Syntax

ksum sumarray karray


===========================================================================
svfilter                                                           *svfilter*

  Description

Implementation of a resonant second order filter, with simultaneous
lowpass, highpass and bandpass outputs.

  Syntax

alow, ahigh, aband svfilter  asig, kcf, kq [, iscl] [, iskip]


===========================================================================
syncgrain                                                         *syncgrain*

  Description

syncgrain implements synchronous granular synthesis. The source sound
for the grains is obtained by reading a function table containing the
samples of the source waveform. For sampled-sound sources, GEN01 is
used. syncgrain will accept deferred allocation tables.

The grain generator has full control of frequency (grains/sec), overall
amplitude, grain pitch (a sampling increment) and grain size (in secs),
both as fixed or time-varying (signal) parameters. An extra parameter is
the grain pointer speed (or rate), which controls which position the
generator will start reading samples in the table for each successive
grain. It is measured in fractions of grain size, so a value of 1 (the
default) will make each successive grain read from where the previous
grain should finish. A value of 0.5 will make the next grain start at
the midway position from the previous grain start and finish, etc.. A
value of 0 will make the generator read always from a fixed position of
the table (wherever the pointer was last at). A negative value will
decrement pointer positions. This control gives extra flexibility for
creating timescale modifications in the resynthesis.

syncgrain will generate any number of parallel grain streams (which will
depend on grain density/frequency), up to the iolaps value (default
100). The number of streams (overlapped grains) is determined by
grainsize*grain_freq. More grain overlaps will demand more calculations
and the synthesis might not run in realtime (depending on processor power).

syncgrain can simulate FOF-like formant synthesis, provided that a
suitable shape is used as grain envelope and a sinewave as the grain
wave. For this use, grain sizes of around 0.04 secs can be used. The
formant centre frequency is determined by the grain pitch. Since this is
a sampling increment, in order to use a frequency in Hz, that value has
to be scaled by tablesize/sr. Grain frequency will determine the
fundamental.

syncgrain uses floating-point indexing, so its precision is not affected
by large-size tables. This opcode is based on the SndObj library
SyncGrain class.

  Syntax

asig syncgrain kamp, kfreq, kpitch, kgrsize, kprate, ifun1, \
      ifun2, iolaps


===========================================================================
syncloop                                                           *syncloop*

  Description

syncloop is a variation on syncgrain, which implements synchronous
granular synthesis. syncloop adds loop start and end points and an
optional start position. Loop start and end control grain start
positions, so the actual grains can go beyond the loop points (if the
loop points are not at the extremes of the table), enabling seamless
crossfading. For more information on the granular synthesis process,
check the syncgrain manual page.

  Syntax

asig syncloop kamp, kfreq, kpitch, kgrsize, kprate, klstart, \
      klend, ifun1, ifun2, iolaps[,istart, iskip]


===========================================================================
syncphasor                                                       *syncphasor*

  Description

Produces a moving phase value between zero and one and an extra impulse
output ("sync out") whenever its phase value crosses or is reset to
zero. The phase can be reset at any time by an impulse on the "sync in"
parameter.

  Syntax

aphase, asyncout syncphasor xcps, asyncin, [, iphs]


===========================================================================
system                                                               *system*

  Description

system and system_i call any external command understood by the
operating system, similarly to the C function system(). system_i runs at
i-time only, while system runs both at initialization and performance time.

  Syntax

ires system_i itrig, Scmd, [inowait]

kres system ktrig, Scmd, [knowait]

tb0, tb1, tb2, tb3, tb4, tb5, tb6, tb7, tb8, tb9, tb10, tb11, tb12,
tb13, tb14, tb15, tb0_init, tb1_init, tb2_init, tb3_init, tb4_init,
tb5_init, tb6_init, tb7_init, tb8_init, tb9_init, tb10_init, tb11_init,
  Description

Allow to read tables in function fashion, to be used inside expressions.
At present time Csound only supports functions with a single input
argument. However, to access table elements, user must provide two
numbers, i.e. the number of table and the index of element. So, in order
to allow to access a table element with a function, a previous
preparation step should be done.

  Syntax

tb0_init ifn

tb1_init ifn

tb2_init ifn

tb3_init ifn

tb4_init ifn

tb5_init ifn

tb6_init ifn

tb7_init ifn

tb8_init ifn

tb9_init ifn

tb10_init ifn

tb11_init ifn

tb12_init ifn

tb13_init ifn

tb14_init ifn

tb15_init ifn

iout = tb0(iIndex)

kout = tb0(kIndex)

iout = tb1(iIndex)

kout = tb1(kIndex)

iout = tb2(iIndex)

kout = tb2(kIndex)

iout = tb3(iIndex)

kout = tb3(kIndex)

iout = tb4(iIndex)

kout = tb4(kIndex)

iout = tb5(iIndex)

kout = tb5(kIndex)

iout = tb6(iIndex)

kout = tb6(kIndex)

iout = tb7(iIndex)

kout = tb7(kIndex)

iout = tb8(iIndex)

kout = tb8(kIndex)

iout = tb9(iIndex)

kout = tb9(kIndex)

iout = tb10(iIndex)

kout = tb10(kIndex)

iout = tb11(iIndex)

kout = tb11(kIndex)

iout = tb12(iIndex)

kout = tb12(kIndex)

iout = tb13(iIndex)

kout = tb13(kIndex)

iout = tb14(iIndex)

kout = tb14(kIndex)

iout = tb15(iIndex)

kout = tb15(kIndex)


===========================================================================
tab                                                                     *tab*

  Description

Fast table opcodes. Faster than table and tablew because don't allow
wrap-around and limit and don't check index validity. Have been
implemented in order to provide fast access to arrays. Support non-power
of two tables (can be generated by any GEN function by giving a negative
length value).

  Syntax

ir tab_i indx, ifn[, ixmode]

kr tab kndx, ifn[, ixmode]

ar tab xndx, ifn[, ixmode]

tabw_i isig, indx, ifn [,ixmode]

tabw ksig, kndx, ifn [,ixmode]

tabw asig, andx, ifn [,ixmode]


===========================================================================
tabifd                                                               *tabifd*

  Description

The tabifd opcode takes an input function table and performs an
Instantaneous Frequency, magnitude and phase analysis, using the STFT
and tabifd (Instantaneous Frequency Distribution), as described in
Lazzarini et al, "Time-stretching using the Instantaneous Frequency
Distribution and Partial Tracking", Proc.of ICMC05, Barcelona. It
generates two PV streaming signals, one containing the amplitudes and
frequencies (a similar output to pvsanal) and another containing
amplitudes and unwrapped phases.

  Syntax

ffr,fphs tabifd ktimpt, kamp, kpitch, ifftsize, ihopsize, iwintype,ifn


===========================================================================
table                                                                 *table*

  Description

Accesses table values by direct indexing.

  Syntax

ares table andx, ifn [, ixmode] [, ixoff] [, iwrap]

ires table indx, ifn [, ixmode] [, ixoff] [, iwrap]

kres table kndx, ifn [, ixmode] [, ixoff] [, iwrap]


===========================================================================
table3                                                               *table3*

  Description

Accesses table values by direct indexing with cubic interpolation.

  Syntax

ares table3 andx, ifn [, ixmode] [, ixoff] [, iwrap]

ires table3 indx, ifn [, ixmode] [, ixoff] [, iwrap]

kres table3 kndx, ifn [, ixmode] [, ixoff] [, iwrap]


===========================================================================
tablecopy                                                         *tablecopy*

  Description

Simple, fast table copy opcode.

  Syntax

tablecopy kdft, ksft


===========================================================================
tablefilter                                                     *tablefilter*

  Description

This opcode can be used in order to filter values from function tables
following certain algorithms. The filtered output is written into a
destination table and the number of elements that have passed the filter
is returned.

  Syntax

knumpassed tablefilter kouttable, kintatble, kmode, kparam


===========================================================================
tablefilteri                                                   *tablefilteri*

  Description

This opcode can be used in order to filter values from function tables
following certain algorithms. The filtered output is written into a
destination table and the number of elements that have passed the filter
is returned.

  Syntax

inumpassed tablefilteri iouttable, iintatble, imode, iparam


===========================================================================
tablegpw                                                           *tablegpw*

  Description

Writes a table's guard point.

  Syntax

tablegpw kfn


===========================================================================
tablei                                                               *tablei*

  Description

Accesses table values by direct indexing with linear interpolation.

  Syntax

ares tablei andx, ifn [, ixmode] [, ixoff] [, iwrap]

ires tablei indx, ifn [, ixmode] [, ixoff] [, iwrap]

kres tablei kndx, ifn [, ixmode] [, ixoff] [, iwrap]


===========================================================================
tableicopy                                                       *tableicopy*

  Description

Simple, fast table copy opcode.

  Syntax

tableicopy idft, isft


===========================================================================
tableigpw                                                         *tableigpw*

  Description

Writes a table's guard point.

  Syntax

tableigpw ifn


===========================================================================
tableikt                                                           *tableikt*

  Description

k-rate control over table numbers. Function tables are read with linear
interpolation.

The standard Csound opcode tablei, when producing a k- or a-rate result,
can only use an init-time variable to select the table number. tableikt
accepts k-rate control as well as i-time. In all other respects they are
similar to the original opcodes.

  Syntax

ares tableikt xndx, kfn [, ixmode] [, ixoff] [, iwrap]

kres tableikt kndx, kfn [, ixmode] [, ixoff] [, iwrap]


===========================================================================
tableimix                                                         *tableimix*

  Description

Mixes two tables.

  Syntax

tableimix idft, idoff, ilen, is1ft, is1off, is1g, is2ft, is2off, is2g


===========================================================================
tableiw                                                             *tableiw*

  Description

This opcode operates on existing function tables, changing their
contents. tableiw is used when all inputs are init time variables or
constants and you only want to run it at the initialization of the
instrument. The valid combinations of variable types are shown by the
first letter of the variable names.

  Syntax

tableiw isig, indx, ifn [, ixmode] [, ixoff] [, iwgmode]


===========================================================================
tablekt                                                             *tablekt*

  Description

k-rate control over table numbers.

The standard Csound opcode table when producing a k- or a-rate result,
can only use an init-time variable to select the table number. tablekt
accepts k-rate control as well as i-time. In all other respects they are
similar to the original opcodes.

  Syntax

ares tablekt xndx, kfn [, ixmode] [, ixoff] [, iwrap]

kres tablekt kndx, kfn [, ixmode] [, ixoff] [, iwrap]


===========================================================================
tablemix                                                           *tablemix*

  Description

Mixes two tables.

  Syntax

tablemix kdft, kdoff, klen, ks1ft, ks1off, ks1g, ks2ft, ks2off, ks2g


===========================================================================
tableng                                                             *tableng*

  Description

Interrogates a function table for length.

  Syntax

ires tableng ifn

kres tableng kfn


===========================================================================
tablera                                                             *tablera*

  Description

These opcode reads tables in sequential locations to an a-rate variable.
Some thought is required before using it. It has at least two major, and
quite different, applications which are discussed below.

  Syntax

ares tablera kfn, kstart, koff


===========================================================================
tableseg                                                           *tableseg*

  Description

tableseg is like linseg but interpolate between values in a stored
function tables. The result is a new function table passed internally to
any following vpvoc which occurs before a subsequent tableseg (much like
lpread/lpreson pairs work). The uses of these are described below under
vpvoc.

  Syntax

tableseg ifn1, idur1, ifn2 [, idur2] [, ifn3] [...]


===========================================================================
tableshuffle                                                   *tableshuffle*

  Description

This opcode can be used in order to shuffle the content of function
tables into a random order but without loosing any of the elements.
Imagine shuffling a deck of cards. Each element of the table is copied
to a different random position. If that position was already chosen
before then the next free position is chosen. The length of the table
remains the same.

  Syntax

tableshuffle ktablenum

tableshufflei itablenum


===========================================================================
tablew                                                               *tablew*

  Description

This opcode operates on existing function tables, changing their
contents. tablew is for writing at k- or at a-rates, with the table
number being specified at init time. Using tablew with i-rate signal and
index values is allowed, but the specified data will always be written
to the function table at k-rate, not during the initialization pass. The
valid combinations of variable types are shown by the first letter of
the variable names.

  Syntax

tablew asig, andx, ifn [, ixmode] [, ixoff] [, iwgmode]

tablew isig, indx, ifn [, ixmode] [, ixoff] [, iwgmode]

tablew ksig, kndx, ifn [, ixmode] [, ixoff] [, iwgmode]


===========================================================================
tablewa                                                             *tablewa*

  Description

This opcode writes to a table in sequential locations to and from an
a-rate variable. Some thought is required before using it. It has at
least two major, and quite different, applications which are discussed
below.

  Syntax

kstart tablewa kfn, asig, koff


===========================================================================
tablewkt                                                           *tablewkt*

  Description

This opcode operates on existing function tables, changing their
contents. tablewkt uses a k-rate variable for selecting the table
number. The valid combinations of variable types are shown by the first
letter of the variable names.

  Syntax

tablewkt asig, andx, kfn [, ixmode] [, ixoff] [, iwgmode]

tablewkt ksig, kndx, kfn [, ixmode] [, ixoff] [, iwgmode]


===========================================================================
tablexkt                                                           *tablexkt*

  Description

Reads function tables with linear, cubic, or sinc interpolation.

  Syntax

ares tablexkt xndx, kfn, kwarp, iwsize [, ixmode] [, ixoff] [, iwrap]


===========================================================================
tablexseg                                                         *tablexseg*

  Description

tablexseg is like expseg but interpolate between values in a stored
function tables. The result is a new function table passed internally to
any following vpvoc which occurs before a subsequent tablexseg (much
like lpread/lpreson pairs work). The uses of these are described below
under vpvoc.

  Syntax

tablexseg ifn1, idur1, ifn2 [, idur2] [, ifn3] [...]


===========================================================================
tabmorph                                                           *tabmorph*

  Description

tabmorph allows morphing between a set of tables of the same size, by
means of a weighted average between two currently selected tables.

  Syntax

kout tabmorph kindex, kweightpoint, ktabnum1, ktabnum2, \
      ifn1, ifn2 [, ifn3, ifn4, ...,ifnN]


===========================================================================
tabmorpha                                                         *tabmorpha*

  Description

tabmorpha allows morphing between a set of tables of the same size, by
means of a weighted average between two currently selected tables.

  Syntax

aout tabmorpha aindex, aweightpoint, atabnum1, atabnum2, \
      ifn1, ifn2 [, ifn3, ifn4, ... ifnN]


===========================================================================
tabmorphak                                                       *tabmorphak*

  Description

tabmorphak allows morphing between a set of tables of the same size, by
means of a weighted average between two currently selected tables.

  Syntax

aout tabmorphak aindex, kweightpoint, ktabnum1, ktabnum2, \
      ifn1, ifn2 [, ifn3, ifn4, ... ifnN]


===========================================================================
tabmorphi                                                         *tabmorphi*

  Description

tabmorphi allows morphing between a set of tables of the same size, by
means of a weighted average between two currently selected tables.

  Syntax

kout tabmorphi kindex, kweightpoint, ktabnum1, ktabnum2, \
      ifn1, ifn2 [, ifn3, ifn4, ..., ifnN]


===========================================================================
tabplay                                                             *tabplay*

  Description

Plays-back control-rate signals on trigger-temporization basis.

  Syntax

tabplay  ktrig, knumtics, kfn, kout1 [,kout2,..., koutN]


===========================================================================
tabrec                                                               *tabrec*

  Description

Records control-rate signals on trigger-temporization basis.

  Syntax

tabrec   ktrig_start, ktrig_stop, knumtics, kfn, kin1 [,kin2,...,kinN]


===========================================================================
tabsum                                                               *tabsum*

  Description

Sums the values in an f-table in a consecutive range.

  Syntax

kr tabsum ifn[[, kmin] [, kmax]]


===========================================================================
tab2pvs                                                             *tab2pvs*

  Description

Copies a pvs frame from a t-variable or k-rate array. Currently only
AMP+FREQ is produced. This opcode requires the t-type to be defined,
which means it only works in the new bison/flex-based parser.

  Syntax

fsig tab2pvs tvar|karr[][,ihopsize, iwinsize, iwintype]


===========================================================================
tambourine                                                       *tambourine*

  Description

tambourine is a semi-physical model of a tambourine sound. It is one of
the PhISEM percussion opcodes. PhISEM (Physically Informed Stochastic
Event Modeling) is an algorithmic approach for simulating collisions of
multiple independent sound producing objects.

  Syntax

ares tambourine kamp, idettack [, inum] [, idamp] [, imaxshake] [, ifreq] \
      [, ifreq1] [, ifreq2]


===========================================================================
tan                                                                     *tan*

  Description

Returns the tangent of x (x in radians).

  Syntax

tan(x) (no rate restriction)


===========================================================================
tanh                                                                   *tanh*

  Description

Returns the hyperbolic tangent of x.

  Syntax

tanh(x) (no rate restriction)


===========================================================================
taninv                                                               *taninv*

  Description

Returns the arctangent of x (x in radians).

  Syntax

taninv(x) (no rate restriction)


===========================================================================
taninv2                                                             *taninv2*

  Description

Returns the arctangent of iy/ix, ky/kx, or ay/ax.

  Syntax

ares taninv2 ay, ax

ires taninv2 iy, ix

kres taninv2 ky, kx

...taninv2(ky, kx)... (no rate restriction)

Returns the arctangent of iy/ix, ky/kx, or ay/ax. If y is zero, taninv2
returns zero regardless of the value of x. If x is zero, the return
value is:

  * π/2, if y is positive.

  * -π/2, if y is negative.

  * 0, if y is 0.


===========================================================================
tbvcf                                                                 *tbvcf*

  Description

This opcode attempts to model some of the filter characteristics of a
Roland TB303 voltage-controlled filter. Euler's method is used to
approximate the system, rather than traditional filter methods. Cutoff
frequency, Q, and distortion are all coupled. Empirical methods were
used to try to unentwine, but frequency is only approximate as a result.
Future fixes for some problems with this opcode may break existing
orchestras relying on this version of tbvcf.

  Syntax

ares tbvcf asig, xfco, xres, kdist, kasym [, iskip]


===========================================================================
tempest                                                             *tempest*

  Description

Estimate the tempo of beat patterns in a control signal.

  Syntax

ktemp tempest kin, iprd, imindur, imemdur, ihp, ithresh, ihtim, ixfdbak, \
      istartempo, ifn [, idisprd] [, itweek]


===========================================================================
tempo                                                                 *tempo*

  Description

Apply tempo control to an uninterpreted score.

  Syntax

tempo ktempo, istartempo


===========================================================================
temposcal                                                         *temposcal*

  Description

temposcal implements phase-locked vocoder processing using function
tables containing sampled-sound sources, with GEN01, and temposcal will
accept deferred allocation tables.

This opcode allows for time and frequency-independent scaling. Time is
advanced internally, but controlled by a tempo scaling parameter; when
an onset is detected, timescaling is momentarily stopped to avoid
smearing of attacks. The quality of the effect is generally improved
with phase locking switched on.

temposcal will also scale pitch, independently of frequency, using a
transposition factor (k-rate).

  Syntax

asig temposcal ktimescal, kamp, kpitch, ktab, klock [,ifftsize, idecim, ithresh]


===========================================================================
tempoval                                                           *tempoval*

  Description

Reads the current value of the tempo.

  Syntax

kres tempoval


===========================================================================
tigoto                                                               *tigoto*

  Description

Similar to igoto but effective only during an i-time pass at which a new
note is being “tied” onto a previously held note. (See i Statement) It
does not work when a tie has not taken place. Allows an instrument to
skip initialization of units according to whether a proposed tie was in
fact successful. (See also tival).

  Syntax

tigoto label

where label is in the same instrument block and is not an expression.


===========================================================================
timedseq                                                           *timedseq*

  Description

An event-sequencer in which time can be controlled by a time-pointer.
Sequence data are stored into a table.

  Syntax

ktrig  timedseq  ktimpnt, ifn, kp1 [,kp2, kp3, ...,kpN]


===========================================================================
timeinstk                                                         *timeinstk*

  Description

Read absolute time, in k-rate cycles, since the start of an instance of
an instrument. Called at both i-time as well as k-time.

  Syntax

kres timeinstk


===========================================================================
timeinsts                                                         *timeinsts*

  Description

Read absolute time, in seconds, since the start of an instance of an
instrument.

  Syntax

kres timeinsts


===========================================================================
timek                                                                 *timek*

  Description

Read absolute time, in k-rate cycles, since the start of the performance.

  Syntax

ires timek

kres timek


===========================================================================
times                                                                 *times*

  Description

Read absolute time, in seconds, since the start of the performance.

  Syntax

ires times

kres times


===========================================================================
timout                                                               *timout*

  Description

Conditional branch during p-time depending on elapsed note time. istrt
and idur specify time in seconds. The branch to label will become
effective at time istrt, and will remain so for just idur seconds. Note
that timout can be reinitialized for multiple activation within a single
note (see example under reinit).

  Syntax

timout istrt, idur, label

where label is in the same instrument block and is not an expression.


===========================================================================
tival                                                                 *tival*

  Syntax

ir tival

  Description

Puts the value of the instrument's internal “tie-in” flag into the named
i-rate variable.


===========================================================================
tlineto                                                             *tlineto*

  Description

Generate glissandos starting from a control signal with a trigger.

  Syntax

kres tlineto ksig, ktime, ktrig


===========================================================================
tone                                                                   *tone*

  Description

A first-order recursive low-pass filter with variable frequency response.

tone is a 1 term IIR filter. Its formula is:

y_n = c1 * x_n + c2 * y_n-1

where

  * b = 2 - cos(2 π hp/sr);

  * c2 = b - sqrt(b^2 - 1.0)

  * c1 = 1 - c2

  Syntax

ares tone asig, khp [, iskip]


===========================================================================
tonek                                                                 *tonek*

  Description

A first-order recursive low-pass filter with variable frequency response.

  Syntax

kres tonek ksig, khp [, iskip]


===========================================================================
tonex                                                                 *tonex*

  Description

tonex is equivalent to a filter consisting of more layers of tone with
the same arguments, serially connected. Using a stack of a larger number
of filters allows a sharper cutoff. They are faster than using a larger
number instances in a Csound orchestra of the old opcodes, because only
one initialization and k- cycle are needed at time and the audio loop
falls entirely inside the cache memory of processor.

  Syntax

ares tonex  asig, khp [, inumlayer] [, iskip]

ares tonex  asig, ahp [, inumlayer] [, iskip]


===========================================================================
trandom                                                             *trandom*

  Description

Generates a controlled pseudo-random number series between min and max
values at k-rate whenever the trigger parameter is different to 0.

  Syntax

kout trandom ktrig, kmin, kmax


===========================================================================
tradsyn                                                             *tradsyn*

  Description

The tradsyn opcode takes an input containg a TRACKS pv streaming signal
(as generated, for instance by partials),as described in Lazzarini et
al, "Time-stretching using the Instantaneous Frequency Distribution and
Partial Tracking", Proc.of ICMC05, Barcelona. It resynthesises the
signal using linear amplitude and frequency interpolation to drive a
bank of interpolating oscillators with amplitude and pitch scaling
controls.

  Syntax

asig tradsyn fin, kscal, kpitch, kmaxtracks, ifn


===========================================================================
transeg                                                             *transeg*

  Description

Constructs a user-definable envelope.

  Syntax

ares transeg ia, idur, itype, ib [, idur2] [, itype] [, ic] ...

kres transeg ia, idur, itype, ib [, idur2] [, itype] [, ic] ...


===========================================================================
transegb                                                           *transegb*

  Description

Constructs a user-definable envelope in absolute time.

  Syntax

ares transegb ia, itim, itype, ib [, itim2] [, itype] [, ic] ...

kres transegb ia, itim, itype, ib [, itim2] [, itype] [, ic] ...


===========================================================================
transegr                                                           *transegr*

  Description

Constructs a user-definable envelope. It is the same as transeg, with an
extended release segment.

  Syntax

ares transegr ia, idur, itype, ib [, idur2] [, itype] [, ic] ...

kres transegr ia, idur, itype, ib [, idur2] [, itype] [, ic] ...


===========================================================================
trcross                                                             *trcross*

  Description

The trcross opcode takes two inputs containg TRACKS pv streaming signals
(as generated, for instance by partials) and cross-synthesises them into
a single TRACKS stream. Two different modes of operation are used: mode
0, cross-synthesis by multiplication of the amplitudes of the two inputs
and mode 1, cross-synthesis by the substititution of the amplitudes of
input 1 by the input 2. Frequencies and phases of input 1 are preserved
in the output. The cross-synthesis is done by matching tracks between
the two inputs using a 'search interval'. The matching algorithm will
look for tracks in the second input that are within the search interval
around each track in the first input. This interval can be changed at
the control rate. Wider search intervals will find more matches.

  Syntax

fsig trcross fin1, fin2, ksearch, kdepth [, kmode] 


===========================================================================
trfilter                                                           *trfilter*

  Description

The trfilter opcode takes an input containg a TRACKS pv streaming signal
(as generated, for instance by partials) and filters it using an
amplitude response curve stored in a function table. The function table
can have any size (no restriction to powers-of-two). The table lookup is
done by linear-interpolation. It is possible to create time-varying
filter curves by updating the amlitude response table with a
table-writing opcode.

  Syntax

fsig trfilter fin, kamnt, ifn


===========================================================================
trhighest                                                         *trhighest*

  Description

The trhighest opcode takes an input containg TRACKS pv streaming signals
(as generated, for instance by partials) and outputs only the highest
track. In addition it outputs two k-rate signals, corresponding to the
frequency and amplitude of the highest track signal.

  Syntax

fsig, kfr, kamp trhighest fin1, kscal


===========================================================================
trigger                                                             *trigger*

  Description

Informs when a krate signal crosses a threshold.

  Syntax

kout trigger ksig, kthreshold, kmode


===========================================================================
trigseq                                                             *trigseq*

  Description

Accepts a trigger signal as input and outputs a group of values.

  Syntax

trigseq ktrig_in, kstart, kloop, kinitndx, kfn_values, kout1 [, kout2] [...]


===========================================================================
trirand                                                             *trirand*

  Description

Triangular distribution random number generator. This is an x-class
noise generator.

  Syntax

ares trirand krange

ires trirand krange

kres trirand krange


===========================================================================
trlowest                                                           *trlowest*

  Description

The trlowest opcode takes an input containg TRACKS pv streaming signals
(as generated, for instance by partials) and outputs only the lowest
track. In addition it outputs two k-rate signals, corresponding to the
frequency and amplitude of the lowest track signal.

  Syntax

fsig, kfr, kamp trlowest fin1, kscal


===========================================================================
trmix                                                                 *trmix*

  Description

The trmix opcode takes two inputs containg TRACKS pv streaming signals
(as generated, for instance by partials) and mixes them into a single
TRACKS stream. Tracks will be mixed up to the available space (defined
by the original number of FFT bins in the analysed signals). If the sum
of the input tracks exceeds this space, the higher-ordered tracks in the
second input will be pruned.

  Syntax

fsig trmix fin1, fin2 


===========================================================================
trscale                                                             *trscale*

  Description

The trscale opcode takes an input containg a TRACKS pv streaming signal
(as generated, for instance by partials) and scales all frequencies by a
k-rate amount. It can also, optionally, scale the gain of the signal by
a k-rate amount (default 1). The result is pitch shifting of the input
tracks.

  Syntax

fsig trscale fin, kpitch[, kgain]


===========================================================================
trshift                                                             *trshift*

  Description

The trshift opcode takes an input containg a TRACKS pv streaming signal
(as generated, for instance by partials) and shifts all frequencies by a
k-rate frequency. It can also, optionally, scale the gain of the signal
by a k-rate amount (default 1). The result is frequency shifting of the
input tracks.

  Syntax

fsig trshift fin, kpshift[, kgain]


===========================================================================
trsplit                                                             *trsplit*

  Description

The trsplit opcode takes an input containg a TRACKS pv streaming signal
(as generated, for instance by partials) and splits it into two signals
according to a k-rate frequency 'split point'. The first output will
contain all tracks up from 0Hz to the split frequency and the second
will contain the tracks from the split frequency up to the Nyquist. It
can also, optionally, scale the gain of the output signals by a k-rate
amount (default 1). The result is two output signals containing only
part of the original spectrum.

  Syntax

fsiglow, fsighi trsplit fin, ksplit[, kgainlow, kgainhigh]


===========================================================================
turnoff                                                             *turnoff*

  Description

Enables an instrument to turn itself off or to turn an instance of
another instrument off.

  Syntax

turnoff

turnoff inst

turnoff knst


===========================================================================
turnoff2                                                           *turnoff2*

  Description

Turn off instance(s) of other instruments at performance time.

  Syntax

turnoff2 kinsno, kmode, krelease


===========================================================================
turnon                                                               *turnon*

  Description

Activate an instrument for an indefinite time.

  Syntax

turnon insnum [, itime]


===========================================================================
unirand                                                             *unirand*

  Description

Uniform distribution random number generator (positive values only).
This is an x-class noise generator.

  Syntax

ares unirand krange

ires unirand krange

kres unirand krange


===========================================================================
until                                                                 *until*

  Description

A syntactic looping construction.

  Syntax

until  condition do
    ... od


===========================================================================
unwrap                                                               *unwrap*

  Description

Applies a unwrapping operation to a vector of phases stored in an array.
The output is an array with phases in the range of [-pi,pi).

  Syntax

kout[] unwrap kin[] 


===========================================================================
upsamp                                                               *upsamp*

  Description

Modify a signal by up-sampling.

  Syntax

ares upsamp ksig


===========================================================================
urandom                                                             *urandom*

  Description

Truly random opcodes with controllable range. These units are for
Unix-like systems only and use /dev/urandom to construct Csound random
values

  Syntax

ax urandom [imin, imax]

ix urandom [imin, imax]

kx urandom [imin, imax]


===========================================================================
urd                                                                     *urd*

  Description

A discrete user-defined-distribution random generator that can be used
as a function.

  Syntax

aout = urd(ktableNum)

iout = urd(itableNum)

kout = urd(ktableNum)


===========================================================================
vactrol                                                             *vactrol*

  Description

Envelope follower unit generator emmulating a Perkin Elmer Vactrole
VTL5C3/2.

  Syntax

ares vactrol asig [iup, idown]


===========================================================================
vadd                                                                   *vadd*

  Description

Adds a scalar value to a vector in a table.

  Syntax

vadd  ifn, kval, kelements [, kdstoffset] [, kverbose]


===========================================================================
vadd_i                                                               *vadd_i*

  Description

Adds a scalar value to a vector in a table.

  Syntax

vadd_i  ifn, ival, ielements [, idstoffset]


===========================================================================
vaddv                                                                 *vaddv*

  Description

Performs addition between two vectorial control signals.

  Syntax

vaddv  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]


===========================================================================
vaddv_i                                                             *vaddv_i*

  Description

Performs addition between two vectorial control signals at init time.

  Syntax

vaddv_i  ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]


===========================================================================
vaget                                                                 *vaget*

  Description

Access values of the current buffer of an a-rate variable by indexing.
Useful for doing sample-by-sample manipulation at k-rate without using
setksmps 1.

  Note

Because this opcode does not do any bounds checking, the user must be
careful not to try to read values past ksmps (the size of a buffer for
an a-rate variable) by using index values greater than ksmps.

  Note

In Csound6 this opcode does do bounds checking.

  Syntax

kval vaget kndx, avar


===========================================================================
valpass                                                             *valpass*

  Description

Variably reverberates an input signal with a flat frequency response.

  Syntax

ares valpass asig, krvt, xlpt, imaxlpt [, iskip] [, insmps]


===========================================================================
vaset                                                                 *vaset*

  Description

Write values into the current buffer of an a-rate variable at the given
index. Useful for doing sample-by-sample manipulation at k-rate without
using setksmps 1.

  Note

Because this opcode does not do any bounds checking, the user must be
careful not to try to write values past ksmps (the size of a buffer for
an a-rate variable) by using index values greater than ksmps.

  Note

In Csound6 this opcode does do bounds checking.

  Syntax

vaset kval, kndx, avar


===========================================================================
vbap                                                                   *vbap*

  Description

Distributes an audio signal amongmany channels, up to 64 in the first
form, arbitrary in the second.

  Syntax

ar1[, ar2...] vbap asig, kazim [,
    kelev] [, kspread] [, ilayout]

array[] vbap asig, kazim [,
    kelev] [, kspread] [, ilayout]


===========================================================================
vbapmove                                                           *vbapmove*

  Description

Distributes an audio signal among upto 64 channels with moving virtual
sources.

  Syntax

ar1[, ar2...] vbapmove asig, idur, ispread, ifldnum, ifld1 \
      [, ifld2] [...]

aarray[] vbapmove asig, idur, ispread, ifldnum, ifld1 \
      [, ifld2] [...]


===========================================================================
vbapg                                                                 *vbapg*

  Description

Calculates the gains for a sound location for up to 64.

  Syntax

k1[, k2...] vbapg kazim [,kelev] [, kspread] [, ilayout]

karray[] vbapg kazim [,kelev] [, kspread] [, ilayout]


===========================================================================
vbapgmove                                                         *vbapgmove*

  Description

Calculates the gains for a sound location between multiple channels with
moving virtual sources.

  Syntax

kr1[, kr2...] vbapgmove idur, ispread, ifldnum, ifld1 \
      [, ifld2] [...]

karray[] vbapgmove idur, ispread, ifldnum, ifld1 \
      [, ifld2] [...]


===========================================================================
vbap16                                                               *vbap16*

  Description

Distributes an audio signal among 16 channels.

  Syntax

ar1, ..., ar16 vbap16 asig, kazim [, kelev] [, kspread]


===========================================================================
vbap16move                                                       *vbap16move*

  Description

Distribute an audio signal among 16 channels with moving virtual sources.

  Syntax

ar1, ..., ar16 vbap16move asig, idur, ispread, ifldnum, ifld1 \
      [, ifld2] [...]


===========================================================================
vbap4                                                                 *vbap4*

  Description

Distributes an audio signal among 4 channels.

  Syntax

ar1, ar2, ar3, ar4 vbap4 asig, kazim [, kelev] [, kspread]


===========================================================================
vbap4move                                                         *vbap4move*

  Description

Distributes an audio signal among 4 channels with moving virtual sources.

  Syntax

ar1, ar2, ar3, ar4 vbap4move asig, idur, ispread, ifldnum, ifld1 \
      [, ifld2] [...]


===========================================================================
vbap8                                                                 *vbap8*

  Description

Distributes an audio signal among 8 channels.

  Syntax

ar1, ..., ar8 vbap8 asig, kazim [, kelev] [, kspread]


===========================================================================
vbap8move                                                         *vbap8move*

  Description

Distributes an audio signal among 8 channels with moving virtual sources.

  Syntax

ar1, ..., ar8 vbap8move asig, idur, ispread, ifldnum, ifld1 \
      [, ifld2] [...]


===========================================================================
vbaplsinit                                                       *vbaplsinit*

  Description

Configures VBAP output according to loudspeaker parameters.

  Syntax

vbaplsinit idim, ilsnum [, idir1] [, idir2] [...] [, idir32]


===========================================================================
vbapz                                                                 *vbapz*

  Description

Writes a multi-channel audio signal to a ZAK array.

  Syntax

vbapz inumchnls, istartndx, asig, kazim [, kelev] [, kspread]


===========================================================================
vbapzmove                                                         *vbapzmove*

  Description

Writes a multi-channel audio signal to a ZAK array with moving virtual
sources.

  Syntax

vbapzmove inumchnls, istartndx, asig, idur, ispread, ifldnum, ifld1, \
      ifld2, [...]


===========================================================================
vcella                                                               *vcella*

  Description

Unidimensional Cellular Automata applied to Csound vectors

  Syntax

vcella ktrig, kreinit, ioutFunc, initStateFunc, \
      iRuleFunc, ielements, irulelen [, iradius]


===========================================================================
vco                                                                     *vco*

  Description

Implementation of a band limited, analog modeled oscillator, based on
integration of band limited impulses. vco can be used to simulate a
variety of analog wave forms.

  Syntax

ares vco xamp, xcps, iwave, kpw [, ifn] [, imaxd] [, ileak] [, inyx] \
      [, iphs] [, iskip]


===========================================================================
vco2                                                                   *vco2*

  Description

vco2 is similar to vco. But the implementation uses pre-calculated
tables of band-limited waveforms (see also GEN30) rather than
integrating impulses. This opcode can be faster than vco (especially if
a low control-rate is used) and also allows better sound quality.
Additionally, there are more waveforms and oscillator phase can be
modulated at k-rate. The disadvantage is increased memory usage. For
more details about vco2 tables, see also vco2init and vco2ft.

  Syntax

ares vco2 kamp, kcps [, imode] [, kpw] [, kphs] [, inyx]


===========================================================================
vco2ft                                                               *vco2ft*

  Description

vco2ft returns the function table number to be used for generating the
specified waveform at a given frequency. This function table number can
be used by any Csound opcode that generates a signal by reading function
tables (like oscilikt). The tables must be calculated by vco2init before
vco2ft is called and shared as Csound ftables (ibasfn).

  Syntax

kfn vco2ft kcps, iwave [, inyx]


===========================================================================
vco2ift                                                             *vco2ift*

  Description

vco2ift is the same as vco2ft, but works at i-time. It is suitable for
use with opcodes that expect an i-rate table number (for example, oscili).

  Syntax

ifn vco2ift icps, iwave [, inyx]


===========================================================================
vco2init                                                           *vco2init*

  Description

vco2init calculates tables for use by vco2 opcode. Optionally, it is
also possible to access these tables as standard Csound function tables.
In this case, vco2ft can be used to find the correct table number for a
given oscillator frequency.

In most cases, this opcode is called from the orchestra header. Using
vco2init in instruments is possible but not recommended. This is because
replacing tables during performance can result in a Csound crash if
other opcodes are accessing the tables at the same time.

Note that vco2init is not required for vco2 to work (tables are
automatically allocated by the first vco2 call, if not done yet),
however it can be useful in some cases:

  * Pre-calculate tables at orchestra load time. This is useful to avoid
    generating the tables during performance, which could interrupt
    real-time processing.

  * Share the tables as Csound ftables. By default, the tables can be
    accessed only by vco2.

  * Change the default parameters of tables (e.g. size) or use an
    user-defined waveform specified in a function table.

  Syntax

ifn vco2init iwave [, ibasfn] [, ipmul] [, iminsiz] [, imaxsiz] [, isrcft]


===========================================================================
vcomb                                                                 *vcomb*

  Description

Variably reverberates an input signal with a “colored” frequency response.

  Syntax

ares vcomb asig, krvt, xlpt, imaxlpt [, iskip] [, insmps]


===========================================================================
vcopy                                                                 *vcopy*

  Description

Copies between two vectorial control signals

  Syntax

vcopy  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [, kverbose]


===========================================================================
vcopy_i                                                             *vcopy_i*

  Description

Copies a vector from one table to another.

  Syntax

vcopy_i  ifn1, ifn2, ielements [,idstoffset, isrcoffset]


===========================================================================
vdelay                                                               *vdelay*

  Description

This is an interpolating variable time delay, it is not very different
from the existing implementation (deltapi), it is only easier to use.

  Syntax

ares vdelay asig, adel, imaxdel [, iskip]


===========================================================================
vdelay3                                                             *vdelay3*

  Description

vdelay3 is experimental. It is the same as vdelay except that it uses
cubic interpolation. (New in Version 3.50.)

  Syntax

ares vdelay3 asig, adel, imaxdel [, iskip]


===========================================================================
vdelayx                                                             *vdelayx*

  Description

A variable delay opcode with high quality interpolation.

  Syntax

aout vdelayx ain, adl, imd, iws [, ist]


===========================================================================
vdelayxq                                                           *vdelayxq*

  Description

A 4-channel variable delay opcode with high quality interpolation.

  Syntax

aout1, aout2, aout3, aout4 vdelayxq ain1, ain2, ain3, ain4, adl, imd, iws [, ist]


===========================================================================
vdelayxs                                                           *vdelayxs*

  Description

A stereo variable delay opcode with high quality interpolation.

  Syntax

aout1, aout2 vdelayxs ain1, ain2, adl, imd, iws [, ist]


===========================================================================
vdelayxw                                                           *vdelayxw*

  Description

Variable delay opcodes with high quality interpolation.

  Syntax

aout vdelayxw ain, adl, imd, iws [, ist]


===========================================================================
vdelayxwq                                                         *vdelayxwq*

  Description

Variable delay opcodes with high quality interpolation.

  Syntax

aout1, aout2, aout3, aout4 vdelayxwq ain1, ain2, ain3, ain4, adl, \
      imd, iws [, ist]


===========================================================================
vdelayxws                                                         *vdelayxws*

  Description

Variable delay opcodes with high quality interpolation.

  Syntax

aout1, aout2 vdelayxws ain1, ain2, adl, imd, iws [, ist]


===========================================================================
vdelayk                                                             *vdelayk*

  Description

Variable delay applied to a k-rate signal

  Syntax

kout vdelayk  ksig, kdel, imaxdel [, iskip, imode]


===========================================================================
vdivv                                                                 *vdivv*

  Description

Performs division between two vectorial control signals

  Syntax

vdivv  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]


===========================================================================
vdivv_i                                                             *vdivv_i*

  Description

Performs division between two vectorial control signals at init time.

  Syntax

vdivv_i  ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]


===========================================================================
vecdelay                                                           *vecdelay*

  Description

Generate a sort of 'vectorial' delay

  Syntax

vecdelay  ifn, ifnIn, ifnDel, ielements, imaxdel [, iskip]


===========================================================================
veloc                                                                 *veloc*

  Description

Get the velocity from a MIDI event.

  Syntax

ival veloc [ilow] [, ihigh]


===========================================================================
vexp                                                                   *vexp*

  Description

Performs power-of operations between a vector and a scalar

  Syntax

vexp  ifn, kval, kelements [, kdstoffset] [, kverbose]


===========================================================================
vexp_i                                                               *vexp_i*

  Description

Performs power-of operations between a vector and a scalar

  Syntax

vexp_i  ifn, ival, ielements[, idstoffset]


===========================================================================
vexpseg                                                             *vexpseg*

  Description

Generate exponential vectorial segments

  Syntax

vexpseg  ifnout, ielements, ifn1, idur1, ifn2 [, idur2, ifn3 [...]]


===========================================================================
vexpv                                                                 *vexpv*

  Description

Performs exponential operations between two vectorial control signals

  Syntax

vexpv  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]


===========================================================================
vexpv_i                                                             *vexpv_i*

  Description

Performs exponential operations between two vectorial control signals at
init time.

  Syntax

vexpv_i  ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]


===========================================================================
vibes                                                                 *vibes*

  Description

Audio output is a tone related to the striking of a metal block as found
in a vibraphone. The method is a physical model developed from Perry
Cook, but re-coded for Csound.

  Syntax

ares vibes kamp, kfreq, ihrd, ipos, imp, kvibf, kvamp, ivibfn, idec


===========================================================================
vibr                                                                   *vibr*

  Description

Easier-to-use user-controllable vibrato.

  Syntax

kout vibr kAverageAmp, kAverageFreq, ifn


===========================================================================
vibrato                                                             *vibrato*

  Description

Generates a natural-sounding user-controllable vibrato.

  Syntax

kout vibrato kAverageAmp, kAverageFreq, kRandAmountAmp, kRandAmountFreq, kAmpMinRate, kAmpMaxRate, kcpsMinRate, kcpsMaxRate, ifn [, iphs


===========================================================================
vincr                                                                 *vincr*

  Description

vincr increments one audio variable with another signal, i.e. it
accumulates output.

  Syntax

vincr accum, aincr


===========================================================================
vlimit                                                               *vlimit*

  Description

Limits elements of vectorial control signals.

  Syntax

vlimit  ifn, kmin, kmax, ielements


===========================================================================
vlinseg                                                             *vlinseg*

  Description

Generate linear vectorial segments

  Syntax

vlinseg  ifnout, ielements, ifn1, idur1, ifn2 [, idur2, ifn3 [...]]


===========================================================================
vlowres                                                             *vlowres*

  Description

A bank of filters in which the cutoff frequency can be separated under
user control

  Syntax

ares vlowres asig, kfco, kres, iord, ksep


===========================================================================
vmap                                                                   *vmap*

  Description

Maps elements from a vector onto another according to the indexes of a
this vector.

  Syntax

vmap  ifn1, ifn2, ielements [,idstoffset, isrcoffset]


===========================================================================
vmirror                                                             *vmirror*

  Description

'Reflects' elements of vectorial control signals on thresholds.

  Syntax

vmirror  ifn, kmin, kmax, ielements


===========================================================================
vmult                                                                 *vmult*

  Description

Multiplies a vector in a table by a scalar value.

  Syntax

vmult  ifn, kval, kelements [, kdstoffset] [, kverbose]


===========================================================================
vmult_i                                                             *vmult_i*

  Description

Multiplies a vector in a table by a scalar value.

  Syntax

vmult_i  ifn, ival, ielements [, idstoffset]


===========================================================================
vmultv                                                               *vmultv*

  Description

Performs mutiplication between two vectorial control signals

  Syntax

vmultv  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]


===========================================================================
vmultv_i                                                           *vmultv_i*

  Description

Performs mutiplication between two vectorial control signals at init time.

  Syntax

vmultv_i  ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]


===========================================================================
voice                                                                 *voice*

  Description

An emulation of a human voice.

  Syntax

ares voice kamp, kfreq, kphoneme, kform, kvibf, kvamp, ifn, ivfn


===========================================================================
vosim                                                                 *vosim*

  Description

This opcode produces a simple vocal simulation based on glottal pulses
with formant characteristics. Output is a series of sound events, where
each event is composed of a burst of squared sine pulses followed by
silence. The VOSIM (VOcal SIMulation) synthesis method was developed by
Kaegi and Tempelaars in the 1970's.

  Syntax

ar vosim kamp, kFund, kForm, kDecay, kPulseCount, kPulseFactor, ifn [, iskip]


===========================================================================
vphaseseg                                                         *vphaseseg*

  Description

vphaseseg allows one-dimensional HVS (Hyper-Vectorial Synthesis).

  Syntax

vphaseseg kphase, ioutab, ielems, itab1,idist1,itab2 \
      [,idist2,itab3, ... ,idistN-1,itabN]


===========================================================================
vport                                                                 *vport*

  Description

Generate a sort of 'vectorial' portamento

  Syntax

vport ifn, khtime, ielements [, ifnInit]


===========================================================================
vpow                                                                   *vpow*

  Description

Raises each element of a vector to a scalar power.

  Syntax

vpow  ifn, kval, kelements [, kdstoffset] [, kverbose]


===========================================================================
vpow_i                                                               *vpow_i*

  Description

Raises each element of a vector to a scalar power

  Syntax

vpow_i  ifn, ival, ielements [, idstoffset]


===========================================================================
vpowv                                                                 *vpowv*

  Description

Performs power-of operations between two vectorial control signals

  Syntax

vpowv ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]


===========================================================================
vpowv_i                                                             *vpowv_i*

  Description

Performs power-of operations between two vectorial control signals at
init time.

  Syntax

vpowv_i ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]


===========================================================================
vpvoc                                                                 *vpvoc*

  Description

Implements signal reconstruction using an fft-based phase vocoder and an
extra envelope.

  Syntax

ares vpvoc ktimpnt, kfmod, ifile [, ispecwp] [, ifn]


===========================================================================
vrandh                                                               *vrandh*

  Description

Generates a vector of random numbers stored into a table, holding the
values for a period of time. Generates a sort of 'vectorial band-limited
noise'.

  Syntax

vrandh  ifn,  krange, kcps, ielements [, idstoffset] [, iseed] \
      [, isize] [, ioffset]


===========================================================================
vrandi                                                               *vrandi*

  Description

Generate a sort of 'vectorial band-limited noise'

  Syntax

vrandi  ifn,  krange, kcps, ielements [, idstoffset] [, iseed] \
      [, isize] [, ioffset]


===========================================================================
vstaudio, vstaudiog                                                *vstaudio*

  Syntax

aout1,aout2 vstaudio instance, [ain1, ain2]

aout1,aout2 vstaudiog instance, [ain1, ain2]

  Description

vstaudio and vstaudiog are used for sending and receiving audio from a
VST plugin.

vstaudio is used within an instrument definition that contains a
vstmidiout or vstnote opcode. It outputs audio for only that one
instrument. Any audio remaining in the plugin after the end of the note,
for example a reverb tail, will be cut off and should be dealt with
using a damping envelope.

vstaudiog (vstaudio global) is used in a separate instrument to process
audio from any number of VST notes or MIDI events that share the same
VST plugin instance (instance). The vstaudiog instrument must be
numbered higher than all the instruments receiving notes or MIDI data,
and the note controlling the vstplug instrument must have an indefinite
duration, or at least a duration as long as the VST plugin is active.


===========================================================================
vstbankload                                                     *vstbankload*

  Syntax

vstbankload instance, ipath

  Description

vstbankload is used for loading parameter banks to a VST plugin.


===========================================================================
vstedit                                                             *vstedit*

  Syntax

vstedit instance

  Description

vstedit opens the custom GUI editor window for a VST plugin. Note that
not all VST plugins have custom GUI editors. It may be necessary to use
the --displays command-line option to ensure that Csound handles events
from the editor window and displays it properly.


===========================================================================
vstinit                                                             *vstinit*

  Syntax

instance vstinit ilibrarypath [,iverbose]

  Description

vstinit is used to load a VST plugin into memory for use with the other
vst4cs opcodes. Both VST effects and instruments (synthesizers) can be used.


===========================================================================
vstinfo                                                             *vstinfo*

  Syntax

vstinfo instance

  Description

vstinfo displays the parameters and the programs of a VST plugin.

Note: The verbose flag in vstinit gives the same information as vstinfo.
vstinfo is useful after loading parameter banks, or when the plugin
changes parameters dynamically.


===========================================================================
vstmidiout                                                       *vstmidiout*

  Syntax

vstmidiout instance, kstatus, kchan, kdata1, kdata2

  Description

vstmidiout is used for sending MIDI information to a VST plugin.


===========================================================================
vstnote                                                             *vstnote*

  Syntax

vstnote instance, kchan, knote, kveloc, kdur

  Description

vstnote sends a MIDI note with definite duration to a VST plugin.


===========================================================================
vstparamset,vstparamget                                         *vstparamset*

  Syntax

vstparamset instance, kparam, kvalue

kvalue vstparamget instance, kparam

  Description

vstparamset and vstparamget are used for parameter comunication to and
from a VST plugin.


===========================================================================
vstprogset                                                       *vstprogset*

  Syntax

vstprogset instance, kprogram

  Description

vstprogset sets one of the programs in an |.fxb| bank.


===========================================================================
vsubv                                                                 *vsubv*

  Description

Performs subtraction between two vectorial control signals

  Syntax

vsubv  ifn1, ifn2, kelements [, kdstoffset] [, ksrcoffset] [,kverbose]


===========================================================================
vsubv_i                                                             *vsubv_i*

  Description

Performs subtraction between two vectorial control signals at init time.

  Syntax

vsubv_i  ifn1, ifn2, ielements [, idstoffset] [, isrcoffset]


===========================================================================
vtable1k                                                           *vtable1k*

  Description

This opcode reads vectors from tables at k-rate.

  Syntax

vtable1k  kfn,kout1 [, kout2, kout3, .... , koutN ]


===========================================================================
vtablei                                                             *vtablei*

  Description

This opcode reads vectors from tables.

  Syntax

vtablei  indx, ifn, interp, ixmode, iout1 [, iout2, iout3, .... , ioutN ]


===========================================================================
vtablek                                                             *vtablek*

  Description

This opcode reads vectors from tables at k-rate.

  Syntax

vtablek  kndx, kfn, kinterp, ixmode, kout1 [, kout2, kout3, .... , koutN ]


===========================================================================
vtablea                                                             *vtablea*

  Description

This opcode reads vectors from tables at a-rate.

  Syntax

vtablea  andx, kfn, kinterp, ixmode, aout1 [, aout2, aout3, .... , aoutN ]


===========================================================================
vtablewi                                                           *vtablewi*

  Description

This opcode writes vectors to tables at init time.

  Syntax

vtablewi  indx, ifn, ixmode, inarg1 [, inarg2, inarg3 , .... , inargN ]


===========================================================================
vtablewk                                                           *vtablewk*

  Description

This opcode writes vectors to tables at k-rate.

  Syntax

vtablewk  kndx, kfn, ixmode, kinarg1 [, kinarg2, kinarg3 , .... , kinargN ]


===========================================================================
vtablewa                                                           *vtablewa*

  Description

This opcode writes vectors to tables at a-rate.

  Syntax

vtablewa  andx, kfn, ixmode, ainarg1 [, ainarg2, ainarg3 , .... , ainargN ]


===========================================================================
vtabi                                                                 *vtabi*

  Description

This opcode reads vectors from tables.

  Syntax

vtabi  indx, ifn, iout1 [, iout2, iout3, .... , ioutN ]


===========================================================================
vtabk                                                                 *vtabk*

  Description

This opcode reads vectors from tables at k-rate.

  Syntax

vtabk  kndx, ifn, kout1 [, kout2, kout3, .... , koutN ]


===========================================================================
vtaba                                                                 *vtaba*

  Description

This opcode reads vectors from tables at a-rate.

  Syntax

vtaba  andx, ifn, aout1 [, aout2, aout3, .... , aoutN ]


===========================================================================
vtabwi                                                               *vtabwi*

  Description

This opcode writes vectors to tables at init time.

  Syntax

vtabwi  indx, ifn, inarg1 [, inarg2, inarg3 , .... , inargN ]


===========================================================================
vtabwk                                                               *vtabwk*

  Description

This opcode writes vectors to tables at k-rate.

  Syntax

vtabwk  kndx, ifn, kinarg1 [, kinarg2, kinarg3 , .... , kinargN ]


===========================================================================
vtabwa                                                               *vtabwa*

  Description

This opcode writes vectors to tables at a-rate.

  Syntax

vtabwa  andx, ifn, ainarg1 [, ainarg2, ainarg3 , .... , ainargN ]


===========================================================================
vwrap                                                                 *vwrap*

  Description

Wraps elements of vectorial control signals.

  Syntax

vwrap  ifn, kmin, kmax, ielements


===========================================================================
waveset                                                             *waveset*

  Description

A simple time stretch by repeating cycles.

  Syntax

ares waveset ain, krep [, ilen]


===========================================================================
websocket                                                         *websocket*

  Description

websocket reads and writes N signals and arrays using a websocket
connection.

  Syntax

xout1[, xout2, xout3, ..., xoutN] websocket iport, xin1[, xin2, xin3, ..., xinN]


===========================================================================
weibull                                                             *weibull*

  Description

Weibull distribution random number generator (positive values only).
This is an x-class noise generator

  Syntax

ares weibull ksigma, ktau

ires weibull ksigma, ktau

kres weibull ksigma, ktau


===========================================================================
wgbow                                                                 *wgbow*

  Description

Audio output is a tone similar to a bowed string, using a physical model
developed from Perry Cook, but re-coded for Csound.

  Syntax

ares wgbow kamp, kfreq, kpres, krat, kvibf, kvamp \
    [, ifn] [, iminfreq]


===========================================================================
wgbowedbar                                                       *wgbowedbar*

  Description

A physical model of a bowed bar, belonging to the Perry Cook family of
waveguide instruments.

  Syntax

ares wgbowedbar kamp, kfreq, kpos, kbowpres, kgain [, iconst] [, itvel] \
      [, ibowpos] [, ilow]


===========================================================================
wgbrass                                                             *wgbrass*

  Description

Audio output is a tone related to a brass instrument, using a physical
model developed from Perry Cook, but re-coded for Csound.

  Syntax

ares wgbrass kamp, kfreq, ktens, iatt, kvibf, kvamp \
    [, ifn] [, iminfreq]


===========================================================================
wgclar                                                               *wgclar*

  Description

Audio output is a tone similar to a clarinet, using a physical model
developed from Perry Cook, but re-coded for Csound.

  Syntax

ares wgclar kamp, kfreq, kstiff, \
    iatt, idetk, kngain, kvibf, kvamp [, ifn] [, iminfreq]


===========================================================================
wgflute                                                             *wgflute*

  Description

Audio output is a tone similar to a flute, using a physical model
developed from Perry Cook, but re-coded for Csound.

  Syntax

ares wgflute kamp, kfreq, kjet, iatt,
    idetk, kngain, kvibf, kvamp [, ifn] [, iminfreq] [, ijetrf] [, iendrf]


===========================================================================
wgpluck                                                             *wgpluck*

  Description

A high fidelity simulation of a plucked string, using interpolating
delay-lines.

  Syntax

ares wgpluck icps, iamp, kpick, iplk, idamp, ifilt, axcite


===========================================================================
wgpluck2                                                           *wgpluck2*

  Description

wgpluck2 is an implementation of the physical model of the plucked
string, with control over the pluck point, the pickup point and the
filter. Based on the Karplus-Strong algorithm.

  Syntax

ares wgpluck2 iplk, kamp, icps, kpick, krefl


===========================================================================
wguide1                                                             *wguide1*

  Description

A simple waveguide model consisting of one delay-line and one
first-order lowpass filter.

  Syntax

ares wguide1 asig, xfreq, kcutoff, kfeedback


===========================================================================
wguide2                                                             *wguide2*

  Description

A model of beaten plate consisting of two parallel delay-lines and two
first-order lowpass filters.

  Syntax

ares wguide2 asig, xfreq1, xfreq2, kcutoff1, kcutoff2, \
      kfeedback1, kfeedback2


===========================================================================
while                                                                 *while*

  Description

A syntactic looping construction.

  Syntax

while  condition do
    ... od


===========================================================================
wiiconnect                                                       *wiiconnect*

  Description

Opens and at control-rate polls up to four external Nintendo Wiimote
controllers.

  Syntax

ires wiiconnect [itimeout, imaxnum]


===========================================================================
wiidata                                                             *wiidata*

  Description

Reads data fields from upto four external Nintendo Wiimote controllers.

  Syntax

kres wiidata kcontrol[, knum]


===========================================================================
wiirange                                                           *wiirange*

  Description

Sets scaling and range limits for certain Wiimote fields.

  Syntax

 wiirange icontrol, iminimum, imaximum[, inum]


===========================================================================
wiisend                                                             *wiisend*

  Description

Sends data to one of a number of external Nintendo Wiimote controllers.

  Syntax

kres wiisend kcontrol, kvalue[, knum]


===========================================================================
window                                                               *window*

  Description

Applies a given window shape to a vector stored in an array. The output
is an array with the windowed vector.


===========================================================================
wrap                                                                   *wrap*

  Description

Wraps-around the signal that exceeds the low and high thresholds.

  Syntax

ares wrap asig, klow, khigh

ires wrap isig, ilow, ihigh

kres wrap ksig, klow, khigh


===========================================================================
writescratch                                                   *writescratch*

  Description

The writescratch opcode writes one of four scalar values to be stored in
the instance of an instrument.

  Syntax

writescratchival[, index]


===========================================================================
wterrain                                                           *wterrain*

  Description

A simple wave-terrain synthesis opcode.

  Syntax

aout wterrain kamp, kpch, k_xcenter, k_ycenter, k_xradius, k_yradius, \
      itabx, itaby


===========================================================================
xadsr                                                                 *xadsr*

  Description

Calculates the classical ADSR envelope

  Syntax

ares xadsr iatt, idec, islev, irel [, idel]

kres xadsr iatt, idec, islev, irel [, idel]


===========================================================================
xin                                                                     *xin*

  Description

The xin and xout opcodes copy variables to and from the opcode
definition, allowing communication with the calling instrument.

The types of input and output variables are defined by the parameters
intypes and outtypes.

  Notes

  * xin and xout should be called only once, and xin should precede
    xout, otherwise an init error and deactivation of the current
    instrument may occur.

  * These opcodes actually run only at i-time. Performance time copying
    is done by the user opcode call. This means that skipping xin or
    xout with kgoto has no effect, while skipping with igoto affects
    both init and performance time operation.

  Syntax

xinarg1 [, xinarg2] ... [xinargN] xin


===========================================================================
xout                                                                   *xout*

  Description

The xin and xout opcodes copy variables to and from the opcode
definition, allowing communication with the calling instrument.

The types of input and output variables are defined by the parameters
intypes and outtypes.

  Notes

  * xin and xout should be called only once, and xin should precede
    xout, otherwise an init error and deactivation of the current
    instrument may occur.

  * These opcodes actually run only at i-time. Performance time copying
    is done by the user opcode call. This means that skipping xin or
    xout with kgoto has no effect, while skipping with igoto affects
    both init and performance time operation.

  Syntax

xout xoutarg1 [, xoutarg2] ... [, xoutargN]


===========================================================================
xscanmap                                                           *xscanmap*

  Description

Allows the position and velocity of a node in a scanned process to be read.

  Syntax

kpos, kvel xscanmap iscan, kamp, kvamp [, iwhich]


===========================================================================
xscansmap                                                         *xscansmap*

  Description

Allows the position and velocity of a node in a scanned process to be read.

  Syntax

xscansmap kpos, kvel, iscan, kamp, kvamp [, iwhich]


===========================================================================
xscans                                                               *xscans*

  Description

Experimental version of scans. Allows much larger matrices and is faster
and smaller but removes some (unused?) flexibility. If liked, it will
replace the older opcode as it is syntax compatible but extended.

  Syntax

ares xscans kamp, kfreq, ifntraj, id [, iorder]


===========================================================================
xscanu                                                               *xscanu*

  Description

Experimental version of scanu. Allows much larger matrices and is faster
and smaller but removes some (unused?) flexibility. If liked, it will
replace the older opcode as it is syntax compatible but extended.

  Syntax

xscanu init, irate, ifnvel, ifnmass, ifnstif, ifncentr, ifndamp, kmass, \
      kstif, kcentr, kdamp, ileft, iright, kpos, kstrngth, ain, idisp, id


===========================================================================
xtratim                                                             *xtratim*

  Description

Extend the duration of real-time generated events and handle their extra
life (Usually for usage along with release instead of linenr, linsegr,
etc).

  Syntax

xtratim iextradur


===========================================================================
xyin                                                                   *xyin*

  Description

Sense the cursor position in an output window. When xyin is called the
position of the mouse within the output window is used to reply to the
request. This simple mechanism does mean that only one xyin can be used
accurately at once. The position of the mouse is reported in the output
window.

  Syntax

kx, ky xyin iprd, ixmin, ixmax, iymin, iymax [, ixinit] [, iyinit]


===========================================================================
zacl                                                                   *zacl*

  Description

Clears one or more variables in the za space.

  Syntax

zacl kfirst, klast


===========================================================================
zakinit                                                             *zakinit*

  Description

Establishes zak space. Must be called only once.

  Syntax

zakinit isizea, isizek


===========================================================================
zamod                                                                 *zamod*

  Description

Modulates one a-rate signal by a second one.

  Syntax

ares zamod asig, kzamod


===========================================================================
zar                                                                     *zar*

  Description

Reads from a location in za space at a-rate.

  Syntax

ares zar kndx


===========================================================================
zarg                                                                   *zarg*

  Description

Reads from a location in za space at a-rate, adds some gain.

  Syntax

ares zarg kndx, kgain


===========================================================================
zaw                                                                     *zaw*

  Description

Writes to a za variable at a-rate without mixing.

  Syntax

zaw asig, kndx


===========================================================================
zawm                                                                   *zawm*

  Description

Writes to a za variable at a-rate with mixing.

  Syntax

zawm asig, kndx [, imix]


===========================================================================
zfilter2                                                           *zfilter2*

  Description

General purpose custom filter with time-varying pole control. The filter
coefficients implement the following difference equation:

(1)*y(n) = b0*x[n] + b1*x[n-1] +...+ bM*x[n-M] - a1*y[n-1] -...- aN*y[n-N]

the system function for which is represented by:

           B(Z)      b0 + b1*Z^-1   + ... + bM*Z^-M
  H(Z)  =  ----  =  --------------------------
           A(Z)       1 + a1*Z^-1   + ... + aN*Z^-N

  Syntax

ares zfilter2 asig, kdamp, kfreq, iM, iN, ib0, ib1, ..., ibM, \
      ia1,ia2, ..., iaN


===========================================================================
zir                                                                     *zir*

  Description

Reads from a location in zk space at i-rate.

  Syntax

ir zir indx


===========================================================================
ziw                                                                     *ziw*

  Description

Writes to a zk variable at i-rate without mixing.

  Syntax

ziw isig, indx


===========================================================================
ziwm                                                                   *ziwm*

  Description

Writes to a zk variable to an i-rate variable with mixing.

  Syntax

ziwm isig, indx [, imix]


===========================================================================
zkcl                                                                   *zkcl*

  Description

Clears one or more variables in the zk space.

  Syntax

zkcl kfirst, klast


===========================================================================
zkmod                                                                 *zkmod*

  Description

Facilitates the modulation of one signal by another.

  Syntax

kres zkmod ksig, kzkmod


===========================================================================
zkr                                                                     *zkr*

  Description

Reads from a location in zk space at k-rate.

  Syntax

kres zkr kndx


===========================================================================
zkw                                                                     *zkw*

  Description

Writes to a zk variable at k-rate without mixing.

  Syntax

zkw ksig, kndx


===========================================================================
zkwm                                                                   *zkwm*

  Description

Writes to a zk variable at k-rate with mixing.

  Syntax

zkwm ksig, kndx [, imix]


===========================================================================
a Statement (or Advance Statement)                                        *a*

  Description

This causes score time to be advanced by a specified amount without
producing sound samples.

  Syntax

a p1  p2  p3


===========================================================================
b Statement                                                               *b*

  Description

This statement resets the clock.

  Syntax

b p1


===========================================================================
e Statement                                                               *e*

  Description

This statement may be used to mark the end of the last section of the
score.

  Syntax

e [time]


===========================================================================
f Statement (or Function Table Statement)                                 *f*

  Description

This causes a GEN subroutine to place values in a stored function table
for use by instruments.

  Syntax

f p1  p2  p3  p4  p5 ... PMAX


===========================================================================
i Statement (Instrument or Note Statement)                                *i*

  Description

This statement calls for an instrument to be made active at a specific
time and for a certain duration. The parameter field values are passed
to that instrument prior to its initialization, and remain valid
throughout its Performance.

  Syntax

i  p1  p2  p3  p4  ...


===========================================================================
m Statement (Mark Statement)                                              *m*

  Description

Sets a named mark in the score, which can be used by an n statement.

  Syntax

m p1


===========================================================================
n Statement                                                               *n*

  Description

Repeats a section from the referenced m statement.

  Syntax

n p1


===========================================================================
q Statement                                                               *q*

  Description

This statement may be used to quiet an instrument.

  Syntax

q p1  p2  p3


===========================================================================
r Statement (Repeat Statement)                                            *r*

  Description

Starts a repeated section, which lasts until the next s, r or e statement.

  Syntax

r p1 p2


===========================================================================
s Statement                                                               *s*

  Description

The s statement marks the end of a section.

  Syntax

s [time]


===========================================================================
t Statement (Tempo Statement)                                             *t*

  Description

This statement sets the tempo and specifies the accelerations and
decelerations for the current section. This is done by converting beats
into seconds.

  Syntax

t  p1  p2  p3  p4 ... (unlimited)


===========================================================================
v Statement                                                               *v*

  Description

The v statement provides for locally variable time warping of score events.

  Syntax

v p1


===========================================================================
x Statement                                                               *x*

  Description

This statement may be used to skip the rest of the current section.

  Syntax

x anything


===========================================================================
y Statement (or Seed Statement)                                           *y*

  Description

Set seed for random numbers, either from p1 or, if omitted, the clock.

  Syntax

y [p1]


===========================================================================
{ Statement                                                               *{*

  Description

The { and } statements can be used to repeat a group of score
statements. These loops do not constitute independent score sections and
thus may repeat events within the same section. Multiple loops may
overlap in time or be nested within each other.

  Syntax

{ p1 p2


===========================================================================
} Statement                                                               *}*

  Description

The { and } statements can be used to repeat a group of score
statements. These loops do not constitute independent score sections and
thus may repeat events within the same section. Multiple loops may
overlap in time or be nested within each other.

  Syntax

}


===========================================================================
GEN01                                                                 *GEN01*

  Description

This subroutine transfers data from a soundfile into a function table.

  Syntax

f#  time  size  1  filcod  skiptime  format  channel


===========================================================================
GEN02                                                                 *GEN02*

  Description

This subroutine transfers data from immediate pfields into a function
table.

  Syntax

f # time size 2 v1 v2 v3 ...


===========================================================================
GEN03                                                                 *GEN03*

  Description

This subroutine generates a stored function table by evaluating a
polynomial in x over a fixed interval and with specified coefficients.

  Syntax

f  #  time  size  3  xval1  xval2  c0  c1  c2  ...  cn


===========================================================================
GEN04                                                                 *GEN04*

  Description

This subroutine generates a normalizing function by examining the
contents of an existing table.

  Syntax

f  #  time  size  4  source#  sourcemode


===========================================================================
GEN05                                                                 *GEN05*

  Description

Constructs functions from segments of exponential curves.

  Syntax

f # time size 5 a n1 b n2 c ...


===========================================================================
GEN06                                                                 *GEN06*

  Description

This subroutine will generate a function comprised of segments of cubic
polynomials, spanning specified points just three at a time.

  Syntax

f  #   time   size   6   a   n1   b   n2   c   n3   d ...


===========================================================================
GEN07                                                                 *GEN07*

  Description

Constructs functions from segments of straight lines.

  Syntax

f  #    time    size   7   a   n1   b   n2   c  ...


===========================================================================
GEN08                                                                 *GEN08*

  Description

This subroutine will generate a piecewise cubic spline curve, the
smoothest possible through all specified points.

  Syntax

f # time size 8 a n1 b n2 c n3 d ...


===========================================================================
GEN09                                                                 *GEN09*

  Description

These subroutines generate composite waveforms made up of weighted sums
of simple sinusoids. The specification of each contributing partial
requires 3 p-fields using GEN09.

  Syntax

f # time size 9 pna stra phsa pnb strb phsb ...


===========================================================================
GEN10                                                                 *GEN10*

  Description

These subroutines generate composite waveforms made up of weighted sums
of simple sinusoids. The specification of each contributing partial
requires 1 pfield using GEN10.

  Syntax

f # time size 10 str1 str2 str3 str4 ...


===========================================================================
GEN11                                                                 *GEN11*

  Description

This subroutine generates an additive set of cosine partials, in the
manner of Csound generators buzz and gbuzz.

  Syntax

f # time size 11 nh [lh] [r]


===========================================================================
GEN12                                                                 *GEN12*

  Description

This generates the log of a modified Bessel function of the second kind,
order 0, suitable for use in amplitude-modulated FM.

  Syntax

f # time size 12 xint


===========================================================================
GEN13                                                                 *GEN13*

  Description

Uses Chebyshev coefficients to generate stored polynomial functions
which, under waveshaping, can be used to split a sinusoid into harmonic
partials having a pre-definable spectrum.

  Syntax

f # time size 13 xint xamp h0 h1 h2 ...


===========================================================================
GEN14                                                                 *GEN14*

  Description

Uses Chebyshev coefficients to generate stored polynomial functions
which, under waveshaping, can be used to split a sinusoid into harmonic
partials having a pre-definable spectrum.

  Syntax

f # time size 14 xint xamp h0 h1 h2 ...


===========================================================================
GEN15                                                                 *GEN15*

  Description

This subroutine creates two tables of stored polynomial functions,
suitable for use in phase quadrature operations.

  Syntax

f # time size 15 xint xamp h0 phs0 h1 phs1 h2 phs2 ...


===========================================================================
GEN16                                                                 *GEN16*

  Description

Creates a table from beg value to end value of dur steps.

  Syntax

f # time size 16 val1 dur1 type1 val2 [dur2 type2 val3 ... typeX valN]


===========================================================================
GEN17                                                                 *GEN17*

  Description

This subroutine creates a step function from given x-y pairs.

  Syntax

f # time size 17 x1 a x2 b x3 c  ...


===========================================================================
GEN18                                                                 *GEN18*

  Description

Writes composite waveforms made up of pre-existing waveforms. Each
contributing waveform requires 4 pfields and can overlap with other
waveforms.

  Syntax

f # time size 18 fna ampa starta finisha fnb ampb startb finishb ...


===========================================================================
GEN19                                                                 *GEN19*

  Description

These subroutines generate composite waveforms made up of weighted sums
of simple sinusoids. The specification of each contributing partial
requires 4 p-fields using GEN19.

  Syntax

f # time size  19  pna   stra  phsa  dcoa  pnb strb  phsb  dcob  ...


===========================================================================
GEN20                                                                 *GEN20*

  Description

This subroutine generates functions of different windows. These windows
are usually used for spectrum analysis or for grain envelopes.

  Syntax

f # time size 20 window max [opt]


===========================================================================
GEN21                                                                 *GEN21*

  Description

This generates tables of different random distributions. (See also
betarand, bexprnd, cauchy, exprand, gauss, linrand, pcauchy, poisson,
trirand, unirand, and weibull)

  Syntax

f # time size 21 type level [arg1  [arg2]]


===========================================================================
GEN23                                                                 *GEN23*

  Description

This subroutine reads numeric values from an external ASCII file.

  Syntax

f # time size -23 "filename.txt"


===========================================================================
GEN24                                                                 *GEN24*

  Description

This subroutine reads numeric values from another allocated
function-table and rescales them according to the max and min values
given by the user.

  Syntax

f # time size -24 ftable min max


===========================================================================
GEN25                                                                 *GEN25*

  Description

These subroutines are used to construct functions from segments of
exponential curves in breakpoint fashion.

  Syntax

f # time size 25 x1 y1 x2 y2 x3  ...


===========================================================================
GEN27                                                                 *GEN27*

  Description

Construct functions from segments of straight lines in breakpoint fashion.

  Syntax

f # time size 27 x1  y1 x2 y2 x3 ...


===========================================================================
GEN28                                                                 *GEN28*

  Description

This function generator reads a text file which contains sets of three
values representing the xy coordinates and a time-tag for when the
signal should be placed at that location, allowing the user to define a
time-tagged trajectory. The file format is in the form:

time1    X1      Y1
time2    X2      Y2
time3    X3      Y3

The configuration of the xy coordinates in space places the signal in
the following way:

  * a1 is -1, 1

  * a2 is 1, 1

  * a3 is -1, -1

  * a4 is 1, -1

This assumes a loudspeaker set up as a1 is left front, a2 is right
front, a3 is left back, a4 is right back. Values greater than 1 will
result in sounds being attenuated as if in the distance. GEN28 creates
values to 10 milliseconds of resolution.

  Syntax

f # time size 28 ifilcod


===========================================================================
GEN30                                                                 *GEN30*

  Description

Extracts a range of harmonic partials from an existing waveform.

  Syntax

f # time size  30  src  minh maxh [ref_sr] [interp]


===========================================================================
GEN31                                                                 *GEN31*

  Description

This routine is similar to GEN09, but allows mixing any waveform
specified in an existing table.

  Syntax

f # time size  31  src  pna stra phsa  pnb strb phsb  ...


===========================================================================
GEN32                                                                 *GEN32*

  Description

This routine is similar to GEN31, but allows specifying source ftable
for each partial. Tables can be resampled either with FFT, or linear
interpolation.

  Syntax

f # time size  32  srca  pna stra phsa  srcb pnb strb phsb  ...


===========================================================================
GEN33                                                                 *GEN33*

  Description

These routines generate composite waveforms by mixing simple sinusoids,
similarly to GEN09, but the parameters of the partials are specified in
an already existing table, which makes it possible to calculate any
number of partials in the orchestra.

The difference between GEN33 and GEN34 is that GEN33 uses inverse FFT to
generate output, while GEN34 is based on the algorithm used in oscils
opcode. GEN33 allows integer partials only, and does not support power
of two plus 1 table size, but may be significantly faster with a large
number of partials. On the other hand, with GEN34, it is possible to use
non-integer partial numbers and extended guard point, and this routine
may be faster if there is only a small number of partials (note that
GEN34 is also several times faster than GEN09, although the latter may
be more accurate).

  Syntax

f # time size  33  src nh scl [fmode]


===========================================================================
GEN34                                                                 *GEN34*

  Description

These routines generate composite waveforms by mixing simple sinusoids,
similarly to GEN09, but the parameters of the partials are specified in
an already existing table, which makes it possible to calculate any
number of partials in the orchestra.

The difference between GEN33 and GEN34 is that GEN33 uses inverse FFT to
generate output, while GEN34 is based on the algorithm used in oscils
opcode. GEN33 allows integer partials only, and does not support power
of two plus 1 table size, but may be significantly faster with a large
number of partials. On the other hand, with GEN34, it is possible to use
non-integer partial numbers and extended guard point, and this routine
may be faster if there is only a small number of partials (note that
GEN34 is also several times faster than GEN09, although the latter may
be more accurate).

  Syntax

f # time size  34  src nh scl [fmode]


===========================================================================
GEN40                                                                 *GEN40*

  Description

Generates a continuous random distribution function starting from the
shape of a user-defined distribution histogram.

  Syntax

f # time size 40 shapetab


===========================================================================
GEN41                                                                 *GEN41*

  Description

Generates a discrete random distribution function by giving a list of
numerical pairs.

  Syntax

f # time size -41 value1 prob1 value2 prob2 value3 prob3 ... valueN probN 


===========================================================================
GEN42                                                                 *GEN42*

  Description

Generates a random distribution function of discrete ranges of values by
giving a list of groups of three numbers.

  Syntax

f # time size -42  min1 max1 prob1 min2 max2 prob2 min3 max3 prob3 ...  minN maxN probN


===========================================================================
GEN43                                                                 *GEN43*

  Description

This subroutine loads a PVOCEX file containing the PV analysis
(amp-freq) of a soundfile and calculates the average magnitudes of all
analysis frames of one or all audio channels. It then creates a table
with these magnitudes for each PV bin.

  Syntax

f # time size 43 filecod channel


===========================================================================
GEN49                                                                 *GEN49*

  Description

This subroutine transfers data from an MP3 soundfile into a function table.

  Syntax

f#  time  size  49  filcod  skiptime  format


===========================================================================
GEN51                                                                 *GEN51*

  Description

This subroutine fills a table with a fully customized micro-tuning
scale, in the manner of Csound opcodes cpstun, cpstuni et cpstmid.

  Syntax

f # time size -51 numgrades interval basefreq basekey tuningRatio1 tuningRatio2  .... tuningRationN


===========================================================================
GEN52                                                                 *GEN52*

  Description

GEN52 creates an interleaved multichannel table from the specified
source tables, in the format expected by the ftconv opcode. It can also
be used to extract a channel from a multichannel table and store it in a
normal mono table, copy tables with skipping some samples, adding delay,
or store in reverse order, etc.

Three parameters must be given for each channel to be processed. fsrc
declares the source f-table number. The parameter offset specifies an
offset for the source file. If different to 0, the source file is not
read from the beginning, but the offset number of values are skipped.
The offset is used to determine the channel number to be read from
interleaved f-tables, e.g. for channel 2, offset must be 1. It can also
be used to set a read offset on the source table. This parameter gives
absolute values, so if a skip of 20 sample frames for a 2 channel
f-table is desired, offset must be set to 40. The srcchnls parameter is
used to declare the number of channels in the source f-table. This
parameter sets the skip size when reading the source f-table.

When more than one channel (nchannels > 1) is given, source f-tables are
interleaved in the newly created table.

If the source f-table is finished before the destination f-table is
full, the remaining values are set to 0.

  Syntax

f # time size 52 nchannels fsrc1 offset1 srcchnls1 [fsrc2 offset2 srcchnls2 ... fsrcN offsetN srcchnlsN]


===========================================================================
GENtanh                                                             *GENtanh*

  Description

Creates an ftable with values of the tanh function.

  Syntax

f # time size "tanh" start end rescale


===========================================================================
GENexp                                                               *GENexp*

  Description

Creates an ftable with values of the exp function.

  Syntax

f # time size "exp" start end rescale


===========================================================================
GENsone                                                             *GENsone*

  Description

Creates an ftable with values of the sone function for equal power.

  Syntax

f # time size "sone" start end equalpoint rescale


===========================================================================
GENfarey                                                           *GENfarey*

  Description

A Farey Sequence F_n of order n is a list of fractions in their lowest
terms between 0 and 1 and in ascending order. Their denominators do not
exceed n. This means a fraction a/b belongs to F_n if 0 ≤ a ≤ b ≤ n. The
numerator and denominator of each fraction are always coprime. 0 and 1
are included in F_n as the fractions 0/1 and 1/1. For example F_5 =
{0/1, 1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5, 1/1} Some properties
of the Farey Sequence:

  * If a/b and c/d are two successive terms of F_n , then bc - ad = 1.
  * If a/b, c/d, e/f are three successive terms of F_n , then: c/d =
    (a+e) / (b+f). In this case c/d is called the mediant fraction
    between a/b and e/f.
  * If n > 1, then no two successive terms ofF_n have the same denominator. 

The length of any Farey Sequence F_n is determined by |F_n | = 1 + SUM
over n (phi(m)) where phi(m) is Euler's totient function, which gives
the number of integers ≤ m that are coprime to m.

Some values for the length of F_n given n:

n       F_n
1       2
2       3
3       5
4       7
5       11
6       13
7       19
8       23
9       29
10      33
11      43
12      47
13      59
14      65
15      73
16      81
17      97
18      103
19      121
20      129

  Syntax

f # time size "farey" fareynum mode


===========================================================================
GENwave                                                             *GENwave*

  Description

Creates a compactly supported wavelet, scaling function or wavelet
packet. The output function is obtained by deconvolution of
corresponding mirror filter impulse response. This procedure is applied
in an iterative fashion.

The filter bank used in classic discrete wavelet transform grows only
towards low frequencies. Meanwhile wavelet packet transform introduces
any possible direction of tree's growth. The sequence of mirror filters
used in deconvolution is determined by binary form of seq value. "0"
corresponds to low-pass filter and "1" to high-pass.

The number of iteration steps is determined by filter's length and size
of function table. I.e. for filter length 8 and table size 256 there are
log2(256/8) = 5 iterations available.

  Syntax

f # time size "wave" fnsf seq rescale


===========================================================================
GENpadsynth                                                     *GENpadsynth*

  Description

Paul Octavian Nasca's "padsynth algorithm" adds bandwidth to each
partial of a periodic weaveform. This bandwidth is heard as color,
movement, and additional richness of sound.

First, the waveform is defined by the user as a series of harmonic
partials. Then, bandwidth is added by independently spreading each
partial of the original waveform from a single frequency across
neighboring frequencies, according to a "profile" function: a Gaussian
curve, a square, or a rising and then falling expontential.

The partials of the original waveform may be considered to be samples in
a discrete Fourier transform of the waveform. Normally there is not an
exact one-to-one correspondence between the frequencies of the samples
(frequency bins) of the discrete Fourier transform with the frequencies
of the partials of the original waveform, because any frequency in the
inverse of the discrete Fourier transform might be synthesized by
interference between any number of bins. However, the padsynth algorithm
uses a simple trick to create this correspondence. The discrete Fourier
transform is simply made so large that the frequency of any partial of
the original waveform will be very close to the frequency of the
corresponding bin in the Fourier transform. Once this correspondence has
been created, the bandwidth profile can be applied by centering it over
the frequency bin of the original partial, scaling the profile by the
bandwidth, and simply multiplying the original partial by each sample of
the profile and adding the product to the corresponding bin of the
Fourier transform.

As the frequencies of the partials increase, their bandwidth may
optionally become wider or (less often) narrower.

Once each partial has been spread out in this way, the discrete Fourier
transform may be given random phases, and is then simply inverted to
synthesize the desired waveform, which may be used as the wavetable for
a digital oscillator.

N.B.: The size of the function table does NOT necessarily reflect one
periodic cycle of the waveform that it contains. The fundamental
frequency must be used to generate the desired pitch from an oscillator
using the function table, e.g.

|oscillator_hz = desired_hz * (sr / padsynth_size / fundamental_hz) |

  Syntax

f # score_time table_size "padsynth" fundamental_frequency
    partial_bandwidth partial_scale harmonic_stretch profile_shape profile_shape_parameter
    partial1_amplitude [partial2_amplitude ...]


 vim:tw=78:ts=8:ft=help:norl:
